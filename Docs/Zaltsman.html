<html>

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Ю.А. Зальцман, МИКРО-ЭВМ БК-0010. АРХИТЕКТУРА И ПРОГРАММИРОВАНИЕ НА ЯЗЫКЕ АССЕМБЛЕРА</title>
<link href="css/cmmn.css" rel="stylesheet">
<link href="css/styledb.css" rel="stylesheet">
<style type="text/css">
ol#ctrlq > li {
	font-style: italic;
}
ul#ctrla > li {
	list-style-type: disc;
	font-style: normal;
}
ol#ctrlq * p {
	text-indent: 0;
}
b {
	font-style: italic;
}
i {
	color: #003;
}
</style>
</head>

<body>

<div id="content">
	<p class="right"><em>Книга Ю.А. Зальцмана, опубликованная в журнале &laquo;Персональный 
	компьютер БК-0010, БК-0011М&raquo; №№1-5 за 1994 г., 1-3 за 1995 г.</em></p>
	<p>&nbsp;</p>
	<p><strong>Ю.А. Зальцман,</strong></p>
	<p><em>480091, Алма-Ата, ул. Джамбула, 55/51, кв. 8. Тел. 69-17-97.</em></p>
	<h1><a name="toc_01"></a>МИКРО-ЭВМ БК-0010. АРХИТЕКТУРА И ПРОГРАММИРОВАНИЕ НА 
	ЯЗЫКЕ АССЕМБЛЕРА</h1>
	<div class="mw-content-ltr">
		<div id="toc" class="toc">
			<h2>ОГЛАВЛЕНИЕ</h2>
			<ul>
				<li class="toclevel-2"><a href="#toc_02"><span class="toctext">Введение</span></a></li>
				<li class="toclevel-2"><a href="#toc_03"><span class="toctext">Рекомендуемая 
				литература</span></a></li>
				<li class="toclevel-2"><a href="#toc_04"><span class="toctext">Архитектура 
				БК-0010</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_05">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_06"><span class="toctext">Адресное 
				пространство БК-0010</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_07">
					<span class="toctext">Распределение адресного пространства</span></a></li>
					<li class="toclevel-3"><a href="#toc_08">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_09"><span class="toctext">Мониторная 
				система диагностики (МСД)</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_10">
					<span class="toctext">Директивы МСД</span></a></li>
					<li class="toclevel-3"><a href="#toc_11">
					<span class="toctext">Диагностические сообщения МСД</span></a></li>
					<li class="toclevel-3"><a href="#toc_12">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_13"><span class="toctext">Системные 
				регистры</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_14">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_15"><span class="toctext">Как 
				работает ЭВМ</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_16">
					<span class="toctext">Дополнительный код</span></a></li>
					<li class="toclevel-3"><a href="#toc_17">
					<span class="toctext">Контрольные вопросы и задания:</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_18"><span class="toctext">Центральный 
				процессор</span></a></li>
				<li class="toclevel-2"><a href="#toc_19"><span class="toctext">Векторы 
				прерываний</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_20">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_21"><span class="toctext">Языки 
				программирования.</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_22">
					<span class="toctext">Что такое ассемблер</span></a></li>
					<li class="toclevel-3"><a href="#toc_23">
					<span class="toctext">Ассемблер-системы</span></a></li>
					<li class="toclevel-3"><a href="#toc_24">
					<span class="toctext">Работа с ассемблером. Формат команды</span></a></li>
					<li class="toclevel-3"><a href="#toc_25">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_26"><span class="toctext">Способы 
				адресации</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_27">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_28"><span class="toctext">Оператор 
				прямого присваивания. Выражения</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_30">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_31"><span class="toctext">Операторы 
				ассемблера</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_32">
					<span class="toctext">1. Вычислительные операторы</span></a></li>
					<li class="toclevel-3"><a href="#toc_33">
					<span class="toctext">2. Операторы управления программой</span></a></li>
					<li class="toclevel-3"><a href="#toc_34">
					<span class="toctext">3. Операторы прерывания</span></a></li>
					<li class="toclevel-3"><a href="#toc_35">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_36"><span class="toctext">Операторы 
				управления машиной</span></a></li>
				<li class="toclevel-2"><a href="#toc_37"><span class="toctext">Прочие 
				операторы</span></a></li>
				<li class="toclevel-2"><a href="#toc_38"><span class="toctext">Псевдооператоры</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_39">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_40"><span class="toctext">Временные 
				характеристики команд БК-0010</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_41">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_42"><span class="toctext">Векторы 
				прерывания и программирование</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_43">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_44"><span class="toctext">Концепция 
				системных драйверов</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_45">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_46"><span class="toctext">Системная 
				область БК-0010</span></a></li>
				<li class="toclevel-2"><a href="#toc_48"><span class="toctext">Для 
				чего предназначен ассемблер?</span></a></li>
				<li class="toclevel-2"><a href="#toc_49"><span class="toctext">&laquo;<em>Стандартные</em>&raquo; 
				подпрограммы</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_50">
					<span class="toctext">Контрольные вопросы и задания</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_51"><span class="toctext">Трансляция 
				и компоновка</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_52">
					<span class="toctext">Ошибки при программировании на ассемблере</span></a></li>
					<li class="toclevel-3"><a href="#toc_53">
					<span class="toctext">Позиционно-независимое программирование</span></a></li>
				</ul>
				</li>
				<li class="toclevel-2"><a href="#toc_54"><span class="toctext">Схемотехника 
				БК-0010</span></a>
				<ul>
					<li class="toclevel-3"><a href="#toc_55">
					<span class="toctext">Возможные доработки БК-0010</span></a></li>
				</ul>
				</li>
				<li class="toclevel-1"><a href="#toc_56"><span class="toctext">ПРИЛОЖЕНИЯ</span></a>
				<ul>
					<li class="toclevel-2"><a href="#toc_57">
					<span class="toctext">Перечень общепринятых в литературе о БК 
					сокращений</span></a></li>
					<li class="toclevel-2"><a href="#toc_58">
					<span class="toctext">Цоколёвка разъёмов БК-0010(.01)</span></a></li>
					<li class="toclevel-2"><a href="#toc_59">
					<span class="toctext">Полный список системных переменных монитора 
					БК-0010</span></a></li>
					<li class="toclevel-2"><a href="#toc_60">
					<span class="toctext">Раздел <span class="nmbr">26</span>. Стандартизация 
					программного обеспечения.</span></a></li>
				</ul>
				</li>
			</ul>
		</div>
	</div>
	<p>&laquo;В начале было слово...&raquo; Точнее, не слово, а множество вопросов 
	пользователей БК-0010 к автору данной статьи, на самые различные темы, касающиеся 
	программирования и архитектуры этой микро-ЭВМ. Сначала вопросы по поводу программирования 
	на языке Фокал, затем - на языке Бейсик, а ещё позже - по программированию в 
	машинных кодах, или на языке ассемблера. Если число вопросов по Фокалу и Бейсику 
	было относительно невелико и быстро пошло на убыль (это, видимо, объясняется 
	тем, что эти языки достаточно полно описаны в прилагаемой к БК-0010 документации 
	и различных периодических изданиях), то вопросы по программированию в машинных 
	кодах не прекращаются и по сей день.</p>
	<h2><a name="toc_02"></a>Введение</h2>
	<p>Микро-ЭВМ «Электроника БК-0010» серийно выпускается в СССР несколькими предприятиями 
	с 1985 г. Не очень рискуя ошибиться, можно сказать, что парк БК-0010 сегодня 
	по численности превосходит все остальные персональные ЭВМ, эксплуатирующиеся 
	в СССР, вместе взятые.</p>
	<p>Что же представляет собой наш самый массовый компьютер? О БК-0010 писали 
	много и по-разному. Писали в специальной литературе и в газетах хорошо и плохо, 
	профессионалы и дилетанты. Среди лиц, избалованных мощной импортной техникой, 
	распространено презрительное отношение к БК, как к &laquo;<i>большому калькулятору</i>&raquo;, &laquo;<i>уродцу 
	в семействе ЭВМ</i>&raquo; и т.п. Но создаётся впечатление, что подобные отзывы 
	исходят в основном от людей, либо совсем не знакомых с БК, либо пытавшихся с 
	ней работать, но не имеющих навыков программирования и вследствие этого просто 
	не справившихся с этим &laquo;<i>калькулятором</i>&raquo;. Такие люди привыкли 
	к тому, что ЭВМ всё делает за них сама, а на дискетах имеется полный набор первоклассных 
	фирменных программ - графические и текстовые редакторы, трансляторы языков высокого 
	уровня, базы данных, электронные таблицы... Пользователю надо лишь освоить работу 
	в операционной системе, и ему становятся доступны все возможности компьютера. 
	Можно писать программы, например на Паскале. Или составлять каталог своей личной 
	библиотеки, или готовить статью в &laquo;<i>Литературную газету</i>&raquo; о 
	том, какая это плохая ЭВМ - БК-0010 и какие плохие люди её делают...</p>
	<p>Но прервём разбег фантазии. Все мы знаем, что хороший компьютер лучше, чем 
	плохой. роший компьютер лучше, чем плохой. Однако на сегодняшний день наша страна, 
	увы, сильно отстает от передовых компьютерных держав мира. Так что всё-таки 
	БК-0010 такое? И так ли уж он плох?</p>
	<p>Уважаемый читатель, давайте чуть отвлечёмся от темы. Вам нравятся микро-ЭВМ 
	семейства ДВК? <i>ДВК-1</i>, <i>ДВК-2</i>, <i>ДВК-3</i>, наконец, <em>ДВК-4</em>? 
	Если вам приходилось работать с этой техникой, ответ, скорее всего, будет либо 
	положительный, либо нейтральный - дело вкуса. Но никто, конечно, не скажет, 
	что <i>ДВК-2М</i>, например, - это большой калькулятор. Машина как машина... 
	Ну, а теперь внимание: БК-0010 - полный аналог ДВК, и не только по системе команд, 
	но и по многим другим параметрам! БК-0010, как и ДВК, изготовлен на базе микропроцессорного 
	комплекта К1801, имеет такой же центральный процессор (К1801ВМ1), как и ДВК-1, 
	такое же быстродействие (300 тыс. операций регистр-регистр в секунду), такое 
	же адресное пространство (64К байта). Можно ли сказать, что БК-0010 - это, с 
	точки зрения пользователя, практически ДВК-1? Не совсем. БК-0010 лучше!</p>
	<p>Да, в нём ОЗУ пользователя всего <span class="nmbr">16</span> Кбайт. Но зато 
	экранное ОЗУ входит в общее адресное пространство и с экраном можно работать, 
	как с ОЗУ пользователя. Вы удивлены и не понимаете, что это за преимущество? 
	Достаточно отметить, что это позволяет очень легко и просто организовать работу 
	ЭВМ в графическом режиме. Но мало того, очень многие задачи (начиная с компьютерных 
	игр и кончая &laquo;<i>системами распознавания образов</i>&raquo;) позволяют 
	использовать экранное ОЗУ БК-0010 как часть ОЗУ пользователя и решать задачи 
	прямо на экране, не занимая основную память ЭВМ.</p>
	<p>В БК-0010 реализована чёрно-белая графика довольно высокого разрешения -
	<span class="nmbr">512</span> х <span class="nmbr">256</span> точек, что в
	<span class="nmbr">2</span>,<span class="nmbr">5</span> раза выше, чем на столь 
	популярной за рубежом ЭВМ &laquo;<i>Синклер</i>&raquo;, и даже чуть выше, чем 
	на первых мониторах (CGA) IBM PC. Заметим также, что на <i>ДВК-1</i> и <i>ДВК-2</i> 
	графического режима нет вообще! Кроме того, БК-0010 имеет цветной режим, позволяя 
	выводить на экран цветного монитора четыре основных цвета - красный, зелёный, 
	синий и чёрный, причём программным путём можно легко увеличить число цветов 
	до <span class="nmbr">8</span>-<span class="nmbr">16</span>.</p>
	<p>БК-0010 не имеет дисковода. Это серьёзный минус, но это и плюс! Отсюда его 
	относительно низкая стоимость и высокая надёжность. Монитор-драйверная система 
	(МДС, или та же ОС) БК-0010 записана в постоянных запоминающих устройствах (ПЗУ) 
	компьютера и поэтому не требует загрузки извне. Она не &laquo;<i>зависает</i>&raquo;, 
	не даёт сбоев, нечувствительна к &laquo;<i>вирусам</i>&raquo;. В состав ОС (МДС) 
	БК-0010 помимо основных программ, обеспечивающих работу ЭВМ, её связь с внешними 
	устройствами, и т.д., входят два интерпретатора языков высокого уровня - вильнюсский 
	Бейсик (по возможностям близкий к BASIC-MSX микро-ЭВМ &laquo;<i>Ямаха-2</i>&raquo;) 
	и Фокал - очень простой и гибкий язык, предназначенный для решения научно-технических 
	задач, к сожалению, до сих пор малознакомый программистам. Фокал БК-0010 имеет 
	расширенный набор средств, в том числе графические операторы, и вполне может 
	потягаться с Бейсиком по своим возможностям. Все эти средства доступны сразу 
	после включения ЭВМ! Вам даже не нужно устанавливать в дисковод дискету и обращаться 
	к помощи ОС.</p>
	<p>Есть в БК-0010 и так называемая <b>мониторная система диагностики</b> - МСД. 
	Она не только даёт возможность проверить работоспособность и исправность ЭВМ, 
	но и содержит средства, позволяющие писать, запускать и отлаживать программы 
	непосредственно в машинных кодах. БК-0010 имеет довольно большой (для бытового 
	компьютера) набор шрифтов и псевдографических символов. может выводить на экран 
	дисплея два формата шрифта - <span class="nmbr">64</span> и
	<span class="nmbr">32</span> символа в строке...</p>
	<p>Опытный пользователь персональных ЭВМ уже давно, наверное, с усмешкой читает 
	этот панегирик БК-0010. У него готов вопрос: &laquo;А прикладное программное 
	обеспечение? Ведь известно, что за рубежом его стоимость обычно в
	<span class="nmbr">5</span>-<span class="nmbr">10</span> раз превышает стоимость &quot;железа&quot;, 
	т.е. самого компьютера! А чем может похвастать БК?&raquo; Может, уважаемый оппонент, 
	и очень многим! На сегодня для БК-0010 разработано свыше <span class="nmbr">
	6000</span> прикладных, системных и инструментальных программ. На БК адаптированы 
	языки: <i>Бейсик</i> (около <span class="nmbr">10</span> версий), <i>Форт</i> 
	(<span class="nmbr">3</span>-<span class="nmbr">4</span> основных версии),
	<i>Си</i> (<span class="nmbr">2</span> основные версии), <i>Т-язык</i>. Ведётся 
	работа по адаптации языков Паскаль и Лисп. Разработан совершенно новый специализированный 
	язык-транслятор <i>ALMIC</i>. На БК имеется не менее <span class="nmbr">40</span> 
	версий редакторов текста (на любой вкус), столько же, если не больше, графических 
	редакторов, очень удобные и мощные ассемблер-системы. И, конечно, игры. Любые 
	- логические (в том числе шахматы), динамические, игры-приключения, с графикой 
	и текстовые, с объёмными изображениями и звуковыми эффектами, чёрно-белые и 
	цветные, полиэкранные, многосерийные и всякие другие, какие только можно вообразить. 
	Ну а что касается математических программ (статистическая обработка данных, 
	вычисления по формулам и т.п.), то их такое множество, что автор не решается 
	даже перечислить их основные классы. Многие из них представляют результаты обработки 
	данных и вычислений не только в цифровом виде, но и графически, в том числе 
	в цвете. А как с базами данных? Имеется несколько простых версий, но есть и 
	СУБД, аналогичная dBASE IBM PC. Есть специальные программы сортировки по алфавиту, 
	драйверы для печати на принтерах разных систем, от <i>Консул-<span class="nmbr">254</span></i> 
	до <i>EPSON</i> и <i>ThinkJet</i>, и электронные таблицы. Есть программы упаковки 
	и вывода изображений и текстов, уплотнения записей на магнитной ленте (МЛ) и 
	даже синтезатор речи с неограниченным словарём русского языка!</p>
	<p>Однако тут самое время остановиться, ведь даже простое перечисление имеющихся 
	для БК программных средств займёт не одну страницу, а может быть, даже не одну 
	книгу! Пусть-ка лучше автор ответит на вопросы: откуда они взялись? И где эти 
	программные средства взять?</p>
	<p>Что же, вопрос резонный. Почти все перечисленные средства написаны не профессиональными 
	программистами, а любителями. Но в большинстве случаев это ничуть не снижает 
	их качество. Ведь что такое профессиональный программист (если, конечно, это 
	действительно программист, а не ремесленник)? Это просто любитель, получающий 
	зарплату за свой труд. Будем смотреть на вещи трезво - в нашей стране почти 
	никто из так называемых профессиональных программистов не имеет специального 
	программистского образования... И почти никто из имеющих такое образование программистом 
	не работает! Эта в высшей степени парадоксальная ситуация, видимо, объясняется 
	тем, что программирование скорее призвание, талант, чем банальная профессия. 
	Но если в театральное училище никогда не примут человека, лишенного артистического 
	дарования, то в технический вуз или университет принимают, увы, всех, сдавших 
	экзамены...</p>
	<p>Итак, ассортимент разработанных для БК-0010 программ довольно широк, и многие 
	из них сделаны на высоком профессиональном уровне. Почему же, несмотря на это, 
	до сих пор наблюдается острый дефицит программных средств? Дело в том, что в 
	СССР так и не были приняты законы, защищающие авторские права программиста, 
	в связи с чем авторы <b>не заинтересованы</b> были в распространении своих программ. 
	(Закон Российской Федерации о правовой охране программ для ЭВМ и баз данных 
	принят лишь <span class="nmbr">23</span> сентября <span class="nmbr">1992</span> 
	г. Полный текст этого документа опубликован в журнале &laquo;<i>Информатика 
	и образование</i>&raquo; №<span class="nmbr">1</span> за <span class="nmbr">
	1993</span> г. - <em>Прим. ред.</em>) Нет до сих пор и единой системы распространения 
	программных средств, единых расценок и гарантий оплаты. Многие государственные 
	и кооперативные предприятия, торгующие программным обеспечением, делают это 
	без всякого согласия авторов и не выплачивают им вознаграждения. Понятно, что 
	при этом авторы даже препятствуют распространению программ, а те из них, которые 
	тиражируются, зачастую представляют собой устаревшие версии или имеют ошибки, 
	в том числе и намеренно внесённые как автором, так и неаккуратными распространителями. 
	Однако уже сегодня есть целый ряд организаций, тиражирующих программы по договорам 
	с авторами и предлагающих пользователям за весьма умеренную плату лучшие образцы 
	творчества программистов для БК-0010. Пользователю нужно только следить за рекламой 
	в журналах.</p>
	<p>Теперь, после этого несколько затянувшегося, но, по-видимому, необходимого 
	вступления, перейдём к вопросу: чего же всё-таки не хватает БК-0010? Прежде 
	всего, конечно, памяти. Хотя в настоящее время разработано уже несколько подходов 
	для расширения ОЗУ и ПЗУ БК-0010, вряд ли можно ожидать, что их применение станет 
	массовым, пока промышленность не наладит серийный выпуск таких &laquo;<i>расширителей</i>&raquo;. 
	Кроме малого объёма ОЗУ пользователи БК-0010 также жалуются на её низкое быстродействие. 
	Но прошу минуту терпения! Обе эти жалобы относятся в основном к программированию 
	на языках высокого уровня. Действительно, Фокал - весьма медленный язык, а вильнюсский 
	Бейсик оставляет желать лучшего в распределении памяти и оптимальности написания 
	программ. Однако есть способ, позволяющий как резко поднять скорость исполнения 
	программ, так и в большинстве случаев существенно экономить память микро-ЭВМ. 
	Это переход к программированию в машинных кодах, или. что по существу одно и 
	то же, на языке ассемблера. Кроме общих преимуществ ассемблера на любой ЭВМ, 
	система команд БК соответствует принятой для компьютеров фирмы Digital Equipment 
	Corp. и имеет существенные преимущества перед стандартом для компьютеров фирмы 
	IBM. Достаточно сказать, например, что, недавно реализованная на БК игра BLOCK 
	OUT (объёмный <i>Тетрис</i>), практически не уступающая аналогичной игре на 
	IBM PC, занимает менее <span class="nmbr">16</span> Кбайт (на IBM PC - около
	<span class="nmbr">200</span> Кбайт!).</p>
	<p>Когда можно считать, что пользователь БК-0010 &laquo;<i>созрел</i>&raquo; 
	для перехода на ассемблер? Прежде всего тогда, когда он ставит перед собой задачу, 
	неразрешимую средствами Бейсика или Фокала. Затем он должен знать основы информатики 
	и программирования и уметь программировать хотя бы на одном из языков, имеющихся 
	на БК-0010 или другой ЭВМ. При невыполнении последнего условия осваивать программирование 
	на языке ассемблера будет очень трудно. Далее, как уже было сказано выше, нужны 
	некоторые способности (но не большие, чем для программирования на Бейсике), 
	а главное - желание и терпение, необходимые для всякого дела, а для программирования 
	на ассемблере в особенности, ибо первые практические результаты будут получены 
	не так уж скоро.</p>
	<p>В данной статье автор ставит перед собой задачу, во-первых, дать читателю 
	возможность досконально изучить архитектуру БК-0010, а во-вторых, познакомить 
	его с основами программирования на самом гибком и мощном из языков любой ЭВМ 
	- языке ассемблера.</p>
	<p>По возможности будут пояснены также некоторые общие вопросы информатики и 
	устройства ЭВМ. Ограниченный объём публикации, к сожалению, не позволяет вдаваться 
	в подробности. Приходится также учитывать различный уровень подготовки читателей: 
	одним, например, вопросы схемотехники компьютера совершенно недоступны, другим 
	скучно изложение основ информатики, с которыми они давно знакомы... Поэтому 
	предполагается, что эти общие (или, наоборот, узкоспециальные) вопросы читатель 
	может изучить самостоятельно, с помощью имеющейся обширной литературы, в зависимости 
	от своего желания и возможностей. Автор старался сделать изложение материала 
	как можно более живым и доступным пониманию, что иногда вынужденно приводило 
	к некоторой нестрогости изложения, расплывчатости формулировок и прочим дефектам, 
	избежать которых полностью, конечно, не удалось. Но при написании статьи и не 
	ставилась целью подготовка профессиональных программистов, а излагаемый материал 
	отнюдь не претендует на роль истины в последней инстанции.</p>
	<p>Автор приносит искреннюю благодарность всем программистам и пользователям 
	БК-0010, с которыми он вёл переписку и лично встречался за последние четыре 
	года, за их ценные советы, предложения, вопросы и пожелания, которые, собственно, 
	и привели к мысли написать руководство по программированию на БК-0010 и без 
	которых полное изложение материала, по-видимому, вообще было бы невозможно. 
	Хотелось бы особо упомянуть программистов С.А. Кумандина и Д.Г. Гаева (Москва), 
	А.В. Цаплева и А.Г. Макеева (Ленинград), В.А. Михайлова (Алма-Ата), С.И. Никанорова 
	(Керчь).</p>
	<p>Данное руководство может быть полезным не только программистам и пользователям 
	БК-0010, но и пользователям других ЭВМ, имеющих аналогичную систему команд и 
	похожий язык ассемблера («Электроника-60», ДВК, СМ-3, СМ-4, PDP-11 и т. п.)</p>
	<h2><a name="toc_03"></a>Рекомендуемая литература:</h2>
	<ol>
		<li>Руководства и пособия, входящие в комплект БК-0010 (разные предприятия, 
		выпускающие БК, комплектуют его различным набором литературы и под несколько 
		отличающимися названиями, но примерно одного содержания).</li>
		<li><em>Вигдорчик Г.В., Воробьёв А.Ю., Праченко В.Д.</em> Основы программирования 
		на ассемблере для СМ ЭВМ. М.: Финансы и статистика, 1983.</li>
		<li><em>Сингер М.</em> Мини-ЭВМ PDP-11: программирование на языке ассемблера 
		и организация машины. М.: Мир, 1984.</li>
		<li><em>Фролов Г.И., Гембицкий Р.А.</em> Микропроцессоры. Вып. 7. Автоматизированные 
		системы контроля объектов. М.: Высшая школа, 1984.</li>
		<li><em>Брусенцов Н.П.</em> Микрокомпьютеры. М.: Наука, 1985.</li>
		<li><em>Фрэнк Т.С.</em> PDP-11. Архитектура и программирование. М.: Радио 
		и связь, 1986.</li>
		<li><em>Брябрин В.М.</em> Программное обеспечение персональных ЭВМ. М.: 
		Наука, 1988.</li>
		<li><em>Осетинский Л.Г., Осетинский М.Г., Писаревский А.Н.</em> Фокал для 
		микро- и мини-компьютеров. Л.: Машиностроение, 1988.</li>
		<li><em>Талов И.Л., Соловьев А.Н., Борисенков В.Д.</em> Микро-ЭВМ. В 8 кн. 
		Кн. 1. Семейство ЭВМ &laquo;Электроника-60&raquo;. М.: Высшая школа, 1988.</li>
		<li><em>Фролов Г.И., Шахнов В.А., Смирнов Н.А.</em> Микро-ЭВМ. В 8 кн. Кн. 
		8. Микро-ЭВМ в учебных заведениях. М.: Высшая школа, 1988.</li>
		<li><em>Лин В.</em> PDP-11 и VAX-И. Архитектура ЭВМ и программирование на 
		языке ассемблера. М.: Радио и связь. 1989.</li>
		<li><em>Напрасник М.В.</em> Микропроцессоры и микро-ЭВМ. М.: Высшая школа, 
		1989.</li>
	</ol>
	<p>Данным списком вовсе не исчерпывается вся возможная литература. Просто её 
	перечень так велик, что привести все источники не представляется возможным. 
	Ценные сведения нередко встречаются и в периодических изданиях - журналах «Информатика 
	и образование», «Микропроцессорные средства и системы» и др.</p>
	<h2><a name="toc_04"></a>Архитектура БК-0010</h2>
	<p>Что такое архитектура ЭВМ? По аналогии с архитектурой города можно догадаться, 
	что это - общее построение аппаратных средств машины. Действительно, город, 
	состоящий из улиц и домов, построенных из кирпичей, имеет <b>архитектуру</b>, 
	т.е. эти кирпичи расположены определённым образом. С точки зрения жителей города, 
	нас обычно не интересует, что это за кирпичи, их химический состав, размеры 
	и т.п. Зато очень важны расположение районов, ширина улиц, удобство и размеры 
	домов и прочее, с чем мы постоянно имеем дело, живя в городе. Немаловажным вопросом 
	является и городской транспорт. Чтобы узнать, из каких материалов построен дом, 
	его надо разобрать, а это уже дело не его жителей, а строителей или ремонтников. 
	Жителя же интересует обычно только то, что он может увидеть, не прибегая к помощи 
	отбойного молотка. Итак, <b>архитектура ЭВМ</b> - это её аппаратные средства,
	<b>доступные программным путём</b>. Если программист не может обратиться к каким-либо 
	средствам ЭВМ, то они, по мнению автора, к архитектуре не относятся.</p>
	<p>Любая ЭВМ предназначена для обработки информации, причём, как правило, она 
	осуществляет эту обработку <b>опосредованно</b> - представляя информацию в виде 
	чисел. Для работы с числами машина имеет специальную важнейшую часть - <b>центральный 
	процессор</b> (ЦП). Это универсальное логическое устройство, которое оперирует 
	с двоичными числами, осуществляя простейшие логические и математические операции 
	- сдвиг, сложение, сравнение и т.п., и делает это не просто как придётся, а 
	в соответствии с <b>программой</b>, т.е. в заданной последовательности.</p>
	<p>Чтобы оперировать с данными, их нужно откуда-то брать, а значит, они должны 
	предварительно где-то храниться. Также где-то должна храниться и необходимая 
	последовательность действий ЦП - программа. Для этого служит <b>запоминающее 
	устройство</b> - ЗУ. ЗУ бывают <b>постоянные</b> (ПЗУ), в которых информация 
	хранится, не изменяясь, сколь угодно долго, и <b>оперативные</b> (ОЗУ), информация 
	в которых может быть в любой момент изменена в соответствии с результатами её 
	обработки. Информация в ПЗУ записывается при их изготовлении, а откуда берётся 
	исходная информация в ОЗУ?</p>
	<p>Для ввода информации в ЭВМ служат <b>внешние устройства</b> - <b>клавиатура</b> 
	и <b>накопитель на магнитной ленте</b> (НМЛ). Другое внешнее устройство - <b>
	дисплей</b> - служит для <b>вывода</b> информации. Отметим, что вывод информации 
	может осуществляться и на НМЛ, после чего она может храниться там неограниченно 
	долго и вновь использоваться. На более мощных ЭВМ существует ряд других внешних 
	устройств: печатающие устройства, или <b>принтеры</b>, накопители на гибких 
	(НГМД) и жёстких (НМД, &laquo;<i>винчестер</i>&raquo;) магнитных дисках и т.п. 
	Все эти возможности &laquo;<i>открыты</i>&raquo; и для БК, но рассказ о подключении 
	принтеров и дисководов не входил в планы автора данной статьи. (О подключении 
	дисководов читайте в журнале &laquo;Персональный компьютер БК-0010 - БК-0011М&raquo;, 
	№<span class="nmbr">1</span> за <span class="nmbr">1993</span> г. - <em>Прим. 
	ред.</em> )</p>
	<p>Как же ЦП общается с ОЗУ, ПЗУ и внешними устройствами? Через так называемое
	<b>адресное пространство ЭВМ</b>, в котором каждое из внешних устройств (а также 
	каждая ячейка памяти) имеет свой адрес, подобно тому как имеет номер каждый 
	дом в городе. Но мы знаем, что в городах есть и многоквартирные дома, где, войдя 
	в дом, мы ещё не достигаем конечной цели - нужно найти квартиру, а возможно, 
	и позвонить нужное число раз. Или представьте, что, попав в нужный дом, мы обнаружили, 
	что там - почтовое отделение, а в нём своя система адресов и свои правила работы. 
	Есть такие &laquo;<i>дома</i>&raquo; и в ЭВМ - это <b>регистры внешних устройств</b>, 
	или <b>системные регистры</b> (СР). Обратившись к такому адресу, мы как бы выходим 
	за пределы нашего города, перед нами открыт весь мир! Но чтобы общаться с ним, 
	мы должны знать правила: как написать на конверте адрес, куда конверт опустить, 
	а когда получим ответ - как его понять, вообще, куда он придёт и каким будет.</p>
	<p>Такова в общих чертах и архитектура БК-0010. Но мы рассмотрели её очень поверхностно 
	и схематично. Чтобы перейти к подробному рассмотрению, нам придётся чуть отвлечься 
	и разобраться, с какой же информацией и как ЭВМ работает.</p>
	<p>Что такое системы счисления, вы. наверное, знаете. Привычная нам десятичная 
	система очень неудобна для ЭВМ - ведь для обработки каждого числа нужно иметь
	<span class="nmbr">10</span> устройств, каждое из которых &laquo;<i>знает</i>&raquo; 
	одну цифру из десяти - <span class="nmbr">0</span>, <span class="nmbr">1</span>, 
	..., <span class="nmbr">9</span>. Однако любое число можно выразить и проще 
	- в двоичной системе, где есть всего две цифры - <span class="nmbr">0</span> 
	и <span class="nmbr">1</span>. Правда, при этом запись числа становится очень 
	объёмной и неудобной для человека, а перевести двоичное число в десятичное весьма 
	сложно. Есть компромисс - восьмеричная система, где запись чисел довольно компактна, 
	а перевод в двоичную и обратно очень прост. В этой системе мы и будем общаться 
	с ЭВМ, не забывая, однако, о том, что сама ЭВМ работает только с двоичными числами. 
	Кратко напомним правила перевода двоичного числа в восьмеричное. Для этого нужно 
	разбить двоичное число справа налево на тройки чисел (триады), а затем заменить 
	каждую тройку на соответствующую восьмеричную цифру:</p>
	<table id="mcmd" class="border">
		<tr>
			<th>
			<p>Двоичное число</p>
			</th>
			<th>
			<p>Восьмеричная цифра</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">000</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">001</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">010</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">011</span></p>
			</td>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">100</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">101</span></p>
			</td>
			<td>
			<p><span class="nmbr">5</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">110</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">111</span></p>
			</td>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
		</tr>
	</table>
	<p>Пример:</p>
	<table id="cntr">
		<tr>
			<td colspan="6">
			<p class="right"><span class="nmbr">1010100011111101</span></p>
			</td>
			<td>
			<p class="left">- исходное число</p>
			</td>
		</tr>
		<tr>
			<td width="30">
			<p><span class="nmbr">001</span></p>
			</td>
			<td width="30">
			<p><span class="nmbr">010</span></p>
			</td>
			<td width="30">
			<p><span class="nmbr">100</span></p>
			</td>
			<td width="30">
			<p><span class="nmbr">011</span></p>
			</td>
			<td width="30">
			<p><span class="nmbr">111</span></p>
			</td>
			<td width="30">
			<p><span class="nmbr">101</span></p>
			</td>
			<td>
			<p class="left">- разбиваем на триады</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p><span class="nmbr">5</span></p>
			</td>
			<td>
			<p>- восьмеричное число <span class="nmbr">124375</span></p>
			</td>
		</tr>
	</table>
	<p>Заметим, что мы дополнили двоичное число слева двумя незначащими нулями, 
	чтобы получить полную триаду, но это не обязательно. Перевод из восьмеричной 
	системы в двоичную делается в обратном порядке и также несложен.</p>
	<p>Все цифровые данные в дальнейшем мы будем приводить в восьмеричном виде, 
	а в тех случаях, когда необходимо использовать десятичное число, будем помечать 
	его буквой &laquo;<strong>д</strong>&raquo;. Заметим кстати, что восьмеричные 
	числа от <span class="nmbr">0</span> до <span class="nmbr">7</span> равны десятичным 
	и безразлично, в какой системе они приведены. Если же в составе числа встречаются 
	цифры <span class="nmbr">8</span> и <span class="nmbr">9</span>, то ясно, что 
	число десятичное, и в пометке &laquo;<strong>д</strong>&raquo; оно не нуждается. 
	Если нужно будет привести двоичное число, то это будет специально оговорено. 
	Другие системы счисления мы использовать не будем.</p>
	<p>Теперь несколько слов о нашем &laquo;<i>городском транспорте</i>&raquo;. 
	Существуют две основные, как их называют, <b>конфигурации ЭВМ</b> - с раздельными 
	шинами адрес-данные и с общей. По названию фирм, разработавших то или иное направление, 
	они носят название INTEL и DEC, соответственно. Не останавливаясь в подробностях 
	на преимуществах и недостатках каждой системы (а они есть и у той, и у другой), 
	скажем лишь, что БК-0010 имеет конфигурацию DEC, или <b>общая шина адреса-данных</b>. 
	Это означает, что и адрес, и данные передаются в ЭВМ по одним и тем же линиям, 
	связывающим её блоки. Но ЭВМ построена так, что программист не ощущает особенностей 
	её конфигурации, и ему не так уж важно, как она работает, а поэтому он может 
	по-прежнему манипулировать адресом и данными отдельно и независимо, не путая 
	их друг с другом. Одним словом, конфигурация ЭВМ (определяемая, кстати, в основном 
	типом ЦП) к архитектуре ЭВМ (в нашем определении) не относится и поэтому нас 
	мало интересует. Продолжая сравнение с городом, можно сказать, что транспорт 
	у нас - только такси. Довольно сесть и назвать адрес, и нас по нему доставят. 
	О маршруте мы можем не беспокоиться, это не наша забота.</p>
	<p>Однако в конце &laquo;<i>поездки</i>&raquo; придётся платить, и на ЭВМ наша &laquo;<i>плата</i>&raquo; 
	- это время. Если мы укажем адрес не оптимально (&laquo;в центр - через пригород!&raquo;), &laquo;<i>счётчик</i>&raquo; 
	может &laquo;<i>нащёлкать</i>&raquo; слишком много, нам не расплатиться - ЭВМ 
	будет слишком долго обрабатывать информацию. Косвенно мы всё-таки учитываем 
	конфигурацию ЭВМ через <b>способы адресации</b>, а как раз они-то в системе 
	команд, рассчитанной на конфигурацию DEC, чрезвычайно гибки и разнообразны. 
	Это и есть основное преимущество &laquo;<i>дековской</i>&raquo; системы команд. 
	Но обо всём - в своё время.</p>
	<h3><a name="toc_05"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Что такое архитектура ЭВМ?
		<ul id="ctrla">
			<li>
			<p>Это аппаратные средства ЭВМ, доступные программным путём.</p>
			</li>
		</ul>
		</li>
		<li>Какова важнейшая часть ЭВМ, её сокращённое наименование?
		<ul id="ctrla">
			<li>
			<p>Центральный процессор (ЦП).</p>
			</li>
		</ul>
		</li>
		<li>Как сокращённо обозначаются оперативное и постоянное запоминающие устройства?
		<ul id="ctrla">
			<li>
			<p>ОЗУ, ПЗУ.</p>
			</li>
		</ul>
		</li>
		<li>Какие внешние устройства ЭВМ БК-0010 вы знаете?
		<ul id="ctrla">
			<li>
			<p>Клавиатура, накопитель на магнитной ленте, дисплей.</p>
			</li>
		</ul>
		</li>
		<li>Через какие регистры БК обращается к своим внешним устройствам, их сокращённое 
		наименование?
		<ul id="ctrla">
			<li>
			<p>Регистры внешних устройств, или системные регистры (СР).</p>
			</li>
		</ul>
		</li>
		<li>Переведите восьмеричное число <span class="nmbr">3747</span> в двоичное 
		(можно пользоваться таблицей, приведённой выше).
		<ul id="ctrla">
			<li>
			<p>Порядок перевода:</p>
			<table id="cntr">
				<tr>
					<td width="30">
					<p><span class="nmbr">3</span></p>
					</td>
					<td width="30">
					<p><span class="nmbr">7</span></p>
					</td>
					<td width="30">
					<p><span class="nmbr">4</span></p>
					</td>
					<td width="30">
					<p><span class="nmbr">7</span></p>
					</td>
				</tr>
				<tr>
					<td>
					<p><span class="nmbr">011</span></p>
					</td>
					<td>
					<p><span class="nmbr">111</span></p>
					</td>
					<td>
					<p><span class="nmbr">100</span></p>
					</td>
					<td>
					<p><span class="nmbr">111</span></p>
					</td>
				</tr>
			</table>
			<p>Ответ: <span class="nmbr">11111100111</span>.</p>
			</li>
		</ul>
		</li>
		<li>Какова конфигурация БК-0010? Как она называется по наименованию фирмы, 
		разработавшей данное направление?
		<ul id="ctrla">
			<li>
			<p>Общая шина адрес-данные (конфигурация DEC).</p>
			</li>
		</ul>
		</li>
		<li>Какие конкретные преимущества и недостатки конфигураций DEC и INTEL 
		приводит автор?
		<ul id="ctrla">
			<li>
			<p>Конфигурация DEC имеет меньшее число линий связи между элементами 
			системы, что позволяет наращивать разрядность с меньшими затратами. 
			Связь организована по принципу &laquo;запрос-ответ&raquo;, т.е. асинхронно, 
			что позволяет наращивать систему, не заботясь об удалённости её частей 
			друг от друга и об общей синхронизации. Всё это позволяет с большей 
			лёгкостью <b>распараллеливать</b> систему и тем наращивать её мощность 
			и возможности.</p>
			<p>Конфигурация INTEL имеет более высокое быстродействие вследствие 
			того, что адрес выставляется по отдельным линиям связи и не требуется 
			дожидаться ответа вызываемого устройства. Но это достигается только 
			тогда, когда вся система размещена на одной плате или в одном корпусе, 
			и время задержки сигнала в проводниках можно не учитывать. Элементы 
			системы конфигурации INTEL заметно проще, чем конфигурации DEC (но с 
			тем же ограничением). Шире ассортимент микросхем, особенно микросхем 
			памяти, рассчитанных на подключение к этой шине.</p>
			<p>В общем же обе конфигурации жизнеспособны и продолжают развиваться 
			параллельно. В нашей стране почему-то бытует мнение, что конфигурация 
			DEC не перспективна, - все журналы, посвящённые компьютерной тематике, 
			упорно публикуют материалы только по вопросам, связанным с IBM PC (конфигурация 
			INTEL). Но фирма Digital Equipment Corp. это мнение явно не разделяет, 
			оставаясь вторым в мире после IBM производителем компьютеров, хотя и 
			в основном не персональных.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_06"></a>Адресное пространство БК-0010</h2>
	<p>Войдём в наш &laquo;<i>город</i>&raquo; - БК-0010. Мы сразу заметим его особенность 
	- в нём всего одна &laquo;<i>улица</i>&raquo;, зато какая! В
	<span class="nmbr">65536</span> &laquo;<i>домов</i>&raquo;! Это и есть <b>адресное 
	пространство</b> нашей ЭВМ - <span class="nmbr">65536</span><sub>д</sub> <b>
	байт</b>. А что такое байт? Это блок информации, состоящий из
	<span class="nmbr">8</span> двоичных разрядов, или БИТ. Самое маленькое число, 
	которое может быть записано в одном байте, - это, конечно, ноль (<span class="nmbr">000</span>), 
	самое большое - <span class="nmbr">255</span><sub>д</sub> (<span class="nmbr">377</span>). 
	Переведём последнее число в двоичный формат. Что получилось? Правильно, восемь 
	единиц - <span class="nmbr">11111111</span>.</p>
	<p>Но в нашем &laquo;<i>городе</i>&raquo; нумерация &laquo;<i>домов</i>&raquo; 
	немного сложнее. Они как бы стоят в два ряда. Не правда ли, вы и в своём городе 
	такое встречали? Дом <span class="nmbr">56</span> и <span class="nmbr">56</span>а,
	<span class="nmbr">78</span> и <span class="nmbr">78</span>/<span class="nmbr">1</span>. 
	Только у нас удобнее - каждый &laquo;<i>дом</i>&raquo; имеет свой номер, причём 
	в &laquo;<i>первой линии</i>&raquo; стоят только чётные &laquo;<i>дома</i>&raquo;. 
	Если каждый &laquo;<i>дом</i>&raquo; - это байт, то два байта называются <b>
	машинным словом</b> или просто <b>словом</b>. Чётные байты имеют, конечно, и 
	чётные номера - <span class="nmbr">0</span>, <span class="nmbr">2</span>, ...,
	<span class="nmbr">177776</span>, причём номера чётного байта и слова, которому 
	он принадлежит, совпадают. А нечётные? Они - &laquo;<i>на задворках</i>&raquo;, 
	и их номер на <span class="nmbr">1</span> больше, чем номер слова. Чётный байт 
	ещё называют <b>младшим</b>, а нечётный - <b>старшим</b> байтом слова, в соответствии 
	с их номерами, ведь номер нечётного байта больше. Зачем так сделано? Дело в 
	том, что во многих случаях мы обращаемся сразу к двум соседним байтам, т.е. 
	к слову, и для этого байты объединены в слова. Но бывает, что нужен и более 
	точный адрес - байт. К нечётному обратиться легко - его адрес отличается от 
	адреса любого слова, а как быть с чётным, адрес которого совпадает с адресом 
	слова? Весьма просто - ЭВМ для обращения к байту (в отличие от обращения к слову) 
	имеет специальные команды, они-то и определяют, что нам нужно не слово, а чётный 
	байт. И ещё особенность - видели ли вы где-нибудь номер дома или квартиры &laquo;<span class="nmbr">0</span>&raquo;? 
	А у нас в ЭВМ везде и всюду ноль - такое же равноправное число, как любое другое, 
	и даже больше - нумерация всегда начинается с него!</p>
	<p>Заметим, что каждый из разрядов (битов) байта или слова (а слове их, понятно, 
	вдвое больше, чем в байте, - <span class="nmbr">16</span><sub>д</sub>) тоже 
	имеет свой номер. Нумерация их идёт справа налево и, как принято, начинается 
	с <span class="nmbr">0</span>. Правый, или <b>младший</b>, бит слова имеет номер
	<span class="nmbr">00</span>, левый, или <b>старший</b>, - номер
	<span class="nmbr">15</span><sub>д</sub> (для битов, как ни странно, принята 
	десятичная нумерация: традиция, а кроме того, по определённым соображениям это 
	удобно). Можно сказать, что номера битов - это номера &laquo;<i>квартир</i>&raquo; 
	в наших &laquo;<i>домах</i>&raquo; - байтах, причём в &laquo;домах
	<span class="nmbr">2</span>-й линии&raquo; (нечётных байтах) они имеют двойную 
	нумерацию - сквозную для слова (<span class="nmbr">8</span>...<span class="nmbr">15</span><sub>д</sub>) 
	и собственную для байта (<span class="nmbr">0</span>...<span class="nmbr">7</span>).</p>
	<p>Назовём и ещё одну единицу измерения информации, с которой нам придётся встретиться, 
	- <b>килобайт</b> (Кб). Приставка &laquo;<i>кило</i>&raquo; говорит о том, что 
	килобайт в <span class="nmbr">1000</span> раз больше байта, но это только приблизительно! 
	В действительности же <span class="nmbr">1</span> Кб = <span class="nmbr">1024</span><sub>д</sub> 
	байта что удобно в двоичной системе счисления, так как именно
	<span class="nmbr">1024</span><sub>д</sub>, а не <span class="nmbr">1000</span> 
	является степенью числа <span class="nmbr">2</span>.</p>
	<p>Итак, наш &laquo;<i>город</i>&raquo; из одной &laquo;<i>улицы</i>&raquo; 
	имеет <span class="nmbr">100000</span> слов, или <span class="nmbr">200000</span> 
	байт, от <span class="nmbr">0</span> до <span class="nmbr">177777</span>. А 
	есть ли в этом &laquo;<i>городе</i>&raquo; районы? А как же!</p>
	<h3><a name="toc_07"></a>Распределение адресного пространства</h3>
	<p>Когда-то, давным-давно, в незапамятные времена (а точнее
	<span class="nmbr">30</span>-<span class="nmbr">40</span> лет назад), когда 
	ЭВМ только-только появились, а &laquo;<i>динозавры</i>&raquo; - механические 
	счётные машины - ещё не &laquo;<i>вымерли</i>&raquo;, у первых ЭВМ память была 
	раздельной: в одних определённых её ячейках хранилась программа, а в других 
	- данные, т.е. обрабатываемая информация. Позже от такой организации в большинстве 
	систем отказались, и теперь почти во всех универсальных ЭВМ программа и данные 
	могут занимать любые ячейки памяти во всём адресном пространстве. И всё же отдельные 
	адреса адресного пространства (или, говоря проще, но менее строго, <b>адреса 
	памяти</b>) на любой ЭВМ, как правило, имеют особое назначение. Начнём с нулевого 
	адреса нашего БК и посмотрим, каково распределение его адресного пространства.</p>
	<p>Адреса <span class="nmbr">0</span>...<span class="nmbr">777</span> - <b>системная 
	область</b> и <b>стек</b>. Это специально выделенные зоны ОЗУ, используемые 
	чаще всего для нужд самой ЭВМ. Более подробно об этом мы поговорим дальше.</p>
	<p>Адреса <span class="nmbr">1000</span>...<span class="nmbr">37777</span> -
	<b>ОЗУ пользователя</b>. В этой зоне ОЗУ можно размещать программу и данные 
	- что хотите и как хотите, это исключительное право программиста. Общая длина 
	этой зоны памяти - <span class="nmbr">15</span>,<span class="nmbr">5</span> 
	Кб.</p>
	<p>Адреса <span class="nmbr">40000</span>...<span class="nmbr">77777</span> 
	- <b>экранное ОЗУ</b>. Мы уже говорили, что оно входит в общее адресное пространство 
	и никак от него не отличается. Никак? Но ведь это экран дисплея, и записанная 
	туда информация может быть в любой момент разрушена. Стоит только нажать любую 
	клавишу - на экране появится символ, т.е. информация в зоне экранного ОЗУ изменится, 
	а если нажать клавишу &laquo;<i>СБР</i>&raquo; - она будет мгновенно уничтожена 
	(экран очищен). Поэтому, используя экранное ОЗУ, мы всегда должны иметь это 
	в виду. Экранное ОЗУ занимает <span class="nmbr">16</span> Кб.</p>
	<p>Но посмотрим ещё раз на уже известные зоны ОЗУ. Экран занимает так много! 
	Нельзя ли всё-таки использовать хоть часть этой памяти? Можно, и в БК-0010 это 
	предусмотрено. Если нажать клавиши АР2 + &laquo;<i>СБР</i>&raquo;, то экран &laquo;<i>сожмётся</i>&raquo; 
	до размера <span class="nmbr">4</span> строки текста, а программист получит 
	в своё распоряжение дополнительную память, &laquo;<i>отрезанную</i>&raquo; от 
	экрана. При этом распределение адресного пространства меняется:
	<span class="nmbr">1000</span>...<span class="nmbr">67777</span> - ОЗУ пользователя, 
	а <span class="nmbr">70000</span>...<span class="nmbr">77777</span> - экранное 
	ОЗУ. Заметим, что при этом переходе в режим <b>расширения памяти</b> (РП) та 
	часть экранного ОЗУ. которая &laquo;<i>отсекается</i>&raquo; в пользу ОЗУ пользователя, 
	сохраняет старую информацию, хотя на экране её уже не видно. Напротив, при обратном 
	переходе к большому экрану он очищается и информация, которая была до этого 
	записана по адресам <span class="nmbr">40000</span>...<span class="nmbr">67777</span>, 
	безвозвратно теряется. Размер экранного ОЗУ в режиме РП - <span class="nmbr">
	4</span> Кб, а ОЗУ пользователя увеличивается на <span class="nmbr">12</span> 
	Кб. (Путём использования служебных ячеек системной области БК-0010 можно произвольным 
	образом изменять распределение памяти между ОЗУ пользователя и экранным ОЗУ, 
	однако при этом программа и данные, помещаемые в область, &laquo;<i>отрезанную</i>&raquo; 
	от экрана, воспроизводятся на нём в виде своеобразной &laquo;<i>пестроты</i>&raquo;. 
	Примером является программа VorteX!. - <em>Прим. ред.</em>)</p>
	<p>Следующий большой &laquo;<i>район</i>&raquo; нашего &laquo;<i>города</i>&raquo; 
	начинается с адреса <span class="nmbr">100000</span> и тянется почти до конца &laquo;<i>улицы</i>&raquo; 
	- по адрес <span class="nmbr">177577</span>. Это <b>область ПЗУ</b>. Каковы 
	её особенности? Если в область ОЗУ вы можете записать любую информацию по любому 
	адресу (к чему это приведёт - другой вопрос), то из области ПЗУ вы можете информацию 
	только <b>читать</b>, на запись по этим адресам наложен запрет. Но тогда откуда 
	же взялась та информация, которую мы оттуда читаем? По этим адресам &laquo;<i>расположены</i>&raquo; 
	специальные микросхемы, в которые информация записана (или, как говорят, &laquo;<i>зашита</i>&raquo;) 
	на заводе-изготовителе, и изменить её нельзя никакими средствами, доступными 
	программисту. Это как бы &laquo;<i>наследственная память</i>&raquo; нашей ЭВМ, 
	то, что она &laquo;<i>знает от рождения</i>&raquo;. Что же это за знания и как 
	они размещены?</p>
	<p><span class="nmbr">100000</span>...<span class="nmbr">117777</span> - <b>
	монитор</b>-<b>драйверная система</b> (МДС). Это, без преувеличения, важнейшая 
	часть ЭВМ, без которой она превращается в мёртвое &laquo;<i>железо</i>&raquo;. 
	Здесь записаны все &laquo;<i>основные инстинкты</i>&raquo; ЭВМ. Ни одна операция, 
	включая даже ввод символа с клавиатуры и вывод его на экран, не обходится без 
	МДС. Эта часть ПЗУ так тесно связана в обеспечении работоспособности ЭВМ с процессором 
	и содержит столь важные программы функционирования всех систем машины, что иногда 
	её называют <b>виртуальным процессором</b> (здесь мы не станем расшифровывать 
	этот термин).</p>
	<p>Далее идёт уже, так сказать, &laquo;<i>кора головного мозга</i>&raquo;. Если 
	без МДС машина мертва, то только с ней она тоже немногое может - загрузить программу, 
	запустить её... Но ни десятичной арифметики, ни чего-либо иного машина &laquo;<i>не 
	знает</i>&raquo;. Она даже не может дать нам возможность &laquo;<i>просмотреть</i>&raquo; 
	свою собственную память. Вся &laquo;<i>надежда</i>&raquo; - на программы, загружаемые 
	в ОЗУ! Но у машины есть и другие микросхемы ПЗУ, причём они отличаются для различных 
	типов БК-0010, а в последних моделях БК-0010.01 есть все их виды:</p>
	<ul>
		<li><span class="nmbr">120000</span>...<span class="nmbr">137777</span> 
		- <b>интерпретатор языка Бейсик</b> или <b>языка Фокал</b>.</li>
		<li><span class="nmbr">140000</span>...<span class="nmbr">157777</span> 
		- <b>интерпретатор языка Бейсик</b> или <b>резервное адресное пространство</b> 
		(&laquo;<i>пустое место</i>&raquo;).</li>
		<li><span class="nmbr">160000</span>...<span class="nmbr">177577</span> 
		- <b>интерпретатор языка Бейсик</b> или <b>мониторная система тестов и диагностики</b> 
		(МСД, МСТД).</li>
	</ul>
	<p>Уточним, что по техническим причинам одна микросхема ПЗУ БК-0010 включает 
	не более <span class="nmbr">20000</span> байт (или <span class="nmbr">8</span> 
	Кб) информации, поэтому все ранее перечисленные &laquo;<i>части</i>&raquo; ПЗУ, 
	кроме последней, имеют эту длину.</p>
	<p>Теперь вам ясно, что интерпретатор языка Фокал занимает одну микросхему ПЗУ, 
	а языка Бейсик - три. Ясно также, что Фокал не может работать одновременно с 
	Бейсиком, а Бейсик - с МСД, так как они занимают одни и те же адреса.</p>
	<h3><a name="toc_08"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Каков размер (в байтах) адресного пространства БК-0010?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">65536</span> байт</p>
			</li>
		</ul>
		</li>
		<li>Сколько бит в байте? В слове?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">8</span> и <span class="nmbr">16</span>, соответственно.</p>
			</li>
		</ul>
		</li>
		<li>Номер какого байта, старшего или младшего, равен номеру слова?
		<ul id="ctrla">
			<li>
			<p>Младшего.</p>
			</li>
		</ul>
		</li>
		<li>Старший байт слова имеет чётный номер?
		<ul id="ctrla">
			<li>
			<p>Нет, чётный номер имеет младший байт.</p>
			</li>
		</ul>
		</li>
		<li>Как машина различает обращение к младшему байту или к слову, имеющим 
		один и тот же адрес?
		<ul id="ctrla">
			<li>
			<p>В зависимости от команды обращения по этому адресу.</p>
			</li>
		</ul>
		</li>
		<li>В каком направлении нумеруются биты в слове - слева направо или справа 
		налево? Какой номер имеет младший бит?
		<ul id="ctrla">
			<li>
			<p>Справа налево. Младший бит имеет номер <span class="nmbr">0</span>.</p>
			</li>
		</ul>
		</li>
		<li>Чему равен килобайт? Его сокращённое обозначение?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">1024</span><sub>д</sub> байта; &laquo;<i>К</i>&raquo;.</p>
			</li>
		</ul>
		</li>
		<li>Могут ли программа и данные располагаться в памяти произвольно? От чего 
		это зависит?
		<ul id="ctrla">
			<li>
			<p>Да, по желанию программиста.</p>
			</li>
		</ul>
		</li>
		<li>Нарисуйте распределение адресного пространства БК-0010, изображая отдельные 
		зоны прямоугольниками и наращивая адреса сверху вниз. Подпишите их наименования. 
		Укажите адреса начала и конца каждой зоны и её длину в Кб (при выполнении 
		последнего задания можно воспользоваться текстом статьи). Сделайте такой 
		же рисунок для режима РП. Выучите распределение адресного пространства наизусть 
		- это очень важно.
		<ul id="ctrla">
			<li>
			<p>Последнюю область, &laquo;<i>Область СР</i>&raquo;, вы имели полное 
			право не изображать, так как мы с ней ещё не знакомы. Но на рисунке 
			приведено всё, &laquo;<i>как положено</i>&raquo;, чтобы к этому вопросу 
			больше не возвращаться.</p>
			</li>
		</ul>
		</li>
		<li>Какова информационная ёмкость одной микросхемы ПЗУ БК-0010? Может ли 
		быть изменена записанная туда информация?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">8</span> Кб. Не может. Заметим, что микросхемы 
			ПЗУ БК-0010 - так называемые <b>масочные</b>, типа К1801РЕ2, в них информация 
			заносится в процессе изготовления кристалла микросхемы. Существует &laquo;<i>легенда</i>&raquo;, 
			что можно эту информацию переписать заново с помощью специального <b>
			программатора</b>. Не верьте, дети, сказкам - это неправда. Зато существуют 
			особые перепрограммируемые ПЗУ (ППЗУ), например, типа К<span class="nmbr">573</span>РФЗ, 
			КМ<span class="nmbr">1801</span>РР1. В них действительно можно записать 
			и переписать информацию, но в БК-0010 их нет и никогда не было, они 
			используются в основном при разработке новых ЭВМ. (Однако ППЗУ некоторых 
			типов являются аналогами использованных в БК масочных ПЗУ и могут быть 
			установлены взамен последних без каких-либо изменений в схеме. В одном 
			из выпусков редакция планирует вернуться к этой теме разговора. -
			<em>Прим. ред.</em>)</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_09"></a>Мониторная система диагностики (МСД)</h2>
	<p>Сразу оговоримся, что в состав МСД входит также система тестов нашей микро-ЭВМ.</p>
	<table id="flat" class="border2">
		<tr>
			<th width="70">
			<p>&nbsp;</p>
			</th>
			<th width="120">
			<p>Обычный режим</p>
			</th>
			<th width="70">
			<p>&nbsp;</p>
			</th>
			<th width="70">
			<p>&nbsp;</p>
			</th>
			<th width="120">
			<p>Режим РП</p>
			</th>
			<th width="70">
			<p>&nbsp;</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">000000</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">000000</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cstr_ls">
			<p>системная область<br>и стек</p>
			</td>
			<td>
			<p><span class="nmbr">0,5</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cstr_ls">
			<p>системная область<br>и стек</p>
			</td>
			<td>
			<p><span class="nmbr">0,5</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">001000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">001000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>ОЗУ пользователя</p>
			</td>
			<td>
			<p><span class="nmbr">15,5</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>ОЗУ пользователя</p>
			</td>
			<td>
			<p><span class="nmbr">27,5</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">040000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">070000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>экранное ОЗУ</p>
			</td>
			<td>
			<p><span class="nmbr">16</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>экранное ОЗУ</p>
			</td>
			<td>
			<p><span class="nmbr">4</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">100000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">100000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>МДС</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>МДС</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">120000</span></p>
			</td>
			<td class="cs_rbls">&nbsp;</td>
			<td>&nbsp;</td>
			<td>
			<p><span class="nmbr">120000</span></p>
			</td>
			<td class="cs_rbls">&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или Фокал</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или Фокал</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">140000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">140000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или резерв</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или резерв</p>
			</td>
			<td>
			<p><span class="nmbr">8</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">160000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">160000</span></p>
			</td>
			<td class="cs_rbls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или МСД</p>
			</td>
			<td>
			<p><span class="nmbr">7,875</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs_r_ls">
			<p>Бейсик или МСД</p>
			</td>
			<td>
			<p><span class="nmbr">7,875</span>К</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">177600</span></p>
			</td>
			<td class="cs_r_ls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">177600</span></p>
			</td>
			<td class="cs_r_ls">
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cstrbls">
			<p>Область СР</p>
			</td>
			<td>
			<p><span class="nmbr">0,125</span>К</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cstrbls">
			<p>Область СР</p>
			</td>
			<td>
			<p><span class="nmbr">0,125</span>К</p>
			</td>
		</tr>
	</table>
	<p>ЭВМ - настолько сложное устройство, что проверить её может только она сама! 
	Поэтому и созданы специальные тест-программы, с которыми, конечно, вы знакомы, 
	ведь ваш БК-0010, наверное, проверялся согласно инструкции, как при покупке, 
	так и в дальнейшем. Напомним, как это делается. После включения нажмите клавиши 
	ЛАТ и ЗАГЛ (если у вас БК-0010.01, то перед включением должен быть подключён 
	блок МСТД), а затем нажимайте последовательно: <span class="symb">Р</span>,
	<span class="symb">ПРОБЕЛ</span>, <span class="symb">Т</span>,
	<span class="symb">ВВОД</span>. На экране появится приглашение тест-системы: &laquo;<span class="symb">+</span>&raquo;. 
	Теперь, в зависимости от того, какой из тестов вы хотите провести, нажмите одну 
	из цифровых клавиш <span class="nmbr">1</span>...<span class="nmbr">5</span> 
	и выполняйте указания БК. Набор из пяти тестов проверяет все системы микро-ЭВМ 
	исчерпывающим образом (правда, с оговоркой, что алгоритмы некоторых тестов довольно 
	примитивны).</p>
	<p>А как перейти в МСД? Мы не зря вспомнили про тесты - выход в МСД производится 
	через тест-систему. Перейдя в тесты, нажмите клавиши: <span class="symb">РУС</span>,
	<span class="symb">Т</span>, <span class="symb">С</span>. На экране появится 
	приглашение МСД: - &laquo;<span class="symb">&curren;</span>&raquo;. Это так 
	называемый &laquo;<i>знак денежной единицы</i>&raquo;, или, на программистском 
	жаргоне, <b>колесо</b> (иногда его называют также &laquo;<i>черепашка</i>&raquo;, &laquo;<i>солнышко</i>&raquo;). 
	МСД, как и пусковой монитор (выход в который из Фокала - <span class="symb">
	Р</span>, <span class="symb">ПРОБЕЛ</span>, <span class="symb">М</span>,
	<span class="symb">ВВОД</span>; из Бейсика - <span class="symb">MON</span>,
	<span class="symb">ВВОД</span>; приглашение &laquo;<span class="symb">?</span>&raquo;), 
	также имеет ряд команд, или директив, но количество их и, соответственно, возможности 
	МСД, намного больше, чем в мониторе. Отметим, что МСД ещё называют <b>системой 
	отладки</b> программ в кодах, что само по себе уже кое о чем говорит. Что же 
	может МСД? Удобнее всего отвечать на этот вопрос, изучая её директивы.</p>
	<h3><a name="toc_10"></a>Директивы МСД</h3>
	<p>МСД &laquo;<i>понимает</i>&raquo; директивы, состоящие из символов (русские 
	заглавные буквы и латинская G) и цифр, причём если в составе директивы присутствуют 
	цифры, то число, следующее <b>до</b> буквы, задаёт какой-либо параметр. Буква 
	без предшествующих цифр соответствующий параметр не задаёт, а индицирует, т.е. 
	выводит на экран какое-либо значение. Помимо директив для работы с памятью ЭВМ 
	в набор команд МСД входят и команды работы с магнитофоном. Все цифровые данные 
	МСД принимает и индицирует только в восьмеричной системе счисления. Эти данные 
	мы будем обозначать как (...). Они могут состоять максимум из шести восьмеричных 
	цифр, причём если их введено больше, то действительны только последние шесть. 
	Незначащие нули слева можно не набирать. Ошибку можно исправить с помощью клавиши &laquo;<i>ЗАБОЙ</i>&raquo; 
	(перемещение курсора влево со стиранием символа, код клавиши -
	<span class="nmbr">30</span>). Итак, директивы:</p>
	<ul>
		<li>(...)<span class="var">А</span> - установить значение текущего адреса. 
		Если мы введём, например. <span class="nmbr">1000</span><span class="var">А</span>, 
		то текущий адрес будет равен <span class="nmbr">1000</span>.</li>
		<li><span class="var">А</span> - проконтролировать значение текущего адреса. 
		МСД выдаёт ответ &laquo;<span class="strn">=(...)</span>&raquo;, в нашем 
		случае: &laquo;<span class="strn">А=<span class="nmbr">1000</span></span>&raquo;.</li>
		<li>(...)<span class="var">Д</span> - установить длину массива (в байтах).</li>
		<li><span class="var">Д</span> - проконтролировать длину массива. Выполняется 
		аналогично директиве <span class="var">А</span>.</li>
		<li>(...)<span class="var">Р</span> - размножить число (...) в заданном 
		диапазоне адресов, т.е. записать число (...) во все слова с адреса
		<span class="var">А</span> до <span class="var">А</span>+<span class="var">Д</span> 
		(не включая последний!). Например, если нам нужно &laquo;<i>обнулить</i>&raquo; 
		(попросту говоря, стереть, или очистить) участок памяти, начиная с адреса
		<span class="nmbr">1000</span> до <span class="nmbr">4000</span>, мы набираем:
		<span class="nmbr">1000</span><span class="var">А</span><span class="nmbr">3000</span><span class="var">Д</span><span class="nmbr">0</span><span class="var">Р</span>. 
		Так как запись производится по словам, а <span class="var">А</span> и
		<span class="var">Д</span> задаются в байтах, то следует задавать лишь чётные
		<span class="var">А</span> и <span class="var">Д</span>. Иначе используется 
		ближайшее чётное значение, меньшее заданного. (Это замечание относится ко 
		всем случаям, когда параметры задаются в байтах, а работа производится со 
		словом).</li>
		<li><span class="var">X</span> - подсчитать контрольную сумму массива, размещённого 
		в памяти, начиная с адреса <span class="var">А</span> до
		<span class="var">А</span>+<span class="var">Д</span>. МСД выдаёт ответ: &laquo;<span class="strn">=(...)</span>&raquo;. 
		Например, подсчитаем контрольную сумму ПЗУ МДС: <span class="nmbr">100000</span><span class="var">А</span><span class="nmbr">20000</span><span class="var">ДХ</span>. 
		Ответ: &laquo;<span class="strn">=<span class="nmbr">177777</span></span>&raquo;, 
		т.е. то же самое значение, которое БК выдаёт для первого ПЗУ, когда мы проводим
		<b>тест <span class="nmbr">1</span></b>. Тут, может быть, уместно пояснить, 
		что это такое. <b>Циклическая контрольная сумма</b> вычисляется сложением 
		всех слов (в других случаях - байт) контролируемого массива информации с 
		прибавлением бита переноса за пределы слова (байта). Что такое, в свою очередь, 
		перенос, станет ясно в дальнейшем (правда, ещё не так скоро, но не будем 
		забегать вперёд). Контрольная сумма позволяет убедиться в идентичности массивов, 
		не сравнивая их с эталоном, так как вероятность её случайного совпадения 
		в общем случае не превышает <span class="nmbr">1</span>/<span class="nmbr">65536</span> 
		(около <span class="nmbr">0</span>.<span class="nmbr">0015</span>%), т.е. 
		практически нулевая. Но есть частные случаи, когда контрольная сумма теряет 
		своё ключевое значение. Достаточно привести такой пример: контрольная сумма 
		любого пустого (состоящего из одних нулей) массива всегда равна нулю независимо 
		от его длины. (Иногда по некоторым причинам при чтении файлов с магнитофона 
		БК воспринимает все считываемые биты как нулевые, включая и записанное вместе 
		с файлом значение его контрольной суммы. В этом случае, хотя ошибка чтения 
		очевидна, компьютер считает, что операция выполнена правильно. - <em>Прим. 
		ред.</em>) Разумеется, используемый в МСД способ вычисления контрольных 
		сумм не единственно возможный и не самый лучший.</li>
		<li>(...)<span class="var">П</span> - переслать по адресу (...) массив, 
		записанный, начиная с адреса <span class="var">А</span> до
		<span class="var">А</span>+<span class="var">Д</span>. Отметим, что &laquo;<i>переслать</i>&raquo; 
		- не совсем удачный термин, так как исходный массив тоже сохраняется в памяти. 
		Правильнее было бы сказать - &laquo;<i>скопировать</i>&raquo;. Попробуем 
		переслать содержимое какого-либо ПЗУ в экранную область памяти, это выглядит 
		довольно эффектно. Набираем: <span class="nmbr">100000</span><span class="var">А</span><span class="nmbr">20000</span><span class="var">Д</span><span class="nmbr">40000</span><span class="var">П</span>. 
		Содержимое ПЗУ почти мгновенно появляется на экране, что также даёт некоторое 
		представление об &laquo;<i>истинном</i>&raquo;, т.е. не &laquo;<i>связанном</i>&raquo; 
		языками высокого уровня, быстродействии ЭВМ - ведь ей пришлось при этом 
		переместить в памяти более <span class="nmbr">4000</span><sub>д</sub> чисел 
		и проделать ещё кое-какие операции! Пересылка возможна и с &laquo;<i>пересечением</i>&raquo; 
		зон адресов пересылаемых массивов, например: <span class="nmbr">2000</span><span class="var">А</span><span class="nmbr">10000</span><span class="var">Д</span><span class="nmbr">1000</span><span class="var">П</span>. 
		Но пересылка &laquo;<i>в обратную сторону</i>&raquo; (<span class="nmbr">1000</span><span class="var">А</span><span class="nmbr">10000</span><span class="var">Д</span><span class="nmbr">2000</span><span class="var">П</span>) 
		не даст ожидаемого результата - оба массива будут испорчены! Если вы вспомните, 
		что пересылка производится по словам, начиная с первого байта массива, то 
		легко догадаетесь, почему так происходит.</li>
		<li>(...)<span class="var">С</span> - сравнить в памяти два массива: эталонный, 
		расположенный с адреса <span class="var">А</span> до адреса
		<span class="var">А</span>+<span class="var">Д</span>, и контролируемый, 
		с адреса (...). Сравнение производится по словам.</li>
	</ul>
	<p>В процессе проверки все расхождения информации в массивах выдаются на экран 
	в следующем виде:</p>
	<table id="cntr" class="border2">
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td colspan="2">
			<p>(эталонный массив)</p>
			</td>
			<td colspan="2">
			<p>(контролируемый массив)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>(1)</p>
			</td>
			<td width="80">
			<p>адрес:</p>
			</td>
			<td width="80">
			<p>данные</p>
			</td>
			<td width="80">
			<p>адрес:</p>
			</td>
			<td width="80">
			<p>данные</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>(2)</p>
			</td>
			<td>
			<p>адрес:</p>
			</td>
			<td>
			<p>данные</p>
			</td>
			<td>
			<p>адрес:</p>
			</td>
			<td>
			<p>данные</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>.......</p>
			</td>
			<td>
			<p>......</p>
			</td>
			<td>
			<p>.......</p>
			</td>
			<td>
			<p>......</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>(N)</p>
			</td>
			<td>
			<p>адрес:</p>
			</td>
			<td>
			<p>данные</p>
			</td>
			<td>
			<p>адрес:</p>
			</td>
			<td>
			<p>данные</p>
			</td>
		</tr>
	</table>
	<p>Если массивы полностью совпадают, на экран ничего не выдаётся. Например, 
	попробуем переслать в память и сравнить с исходным содержимое одного и того 
	же ПЗУ. <span class="nmbr">100000</span><span class="var">А</span><span class="nmbr">20000</span><span class="var">Д</span><span class="nmbr">1000</span><span class="var">П</span> 
	- мы выполнили пересылку по адресу <span class="nmbr">1000</span>. Теперь намеренно &laquo;<i>испортим</i>&raquo; 
	массив в ОЗУ уже известной нам директивой: <span class="nmbr">2000</span><span class="var">А</span><span class="nmbr">10</span><span class="var">Д</span><span class="nmbr">0</span><span class="var">Р</span> 
	- мы записали в массив <span class="nmbr">8</span> байт (т.е.
	<span class="nmbr">4</span> слова) нулей. Теперь введём: <span class="nmbr">
	100000</span><span class="var">А</span><span class="nmbr">20000</span><span class="var">Д</span><span class="nmbr">1000</span><span class="var">С</span>. 
	На экран будет выдано четыре строки указанного выше вида - специально &laquo;<i>сделанная</i>&raquo; 
	нами ошибка в составе контролируемого массива выявлена!</p>
	<ul>
		<li>(...)<span class="var">Л</span> - листать (выдать на экран) массив, 
		начиная с адреса <span class="var">А</span>, длиной (...) байт. После этого
		<span class="var">А</span> принимает новое значение, равное
		<span class="var">А</span>+(...). Массив выдаётся на экран в виде машинных 
		слов (а не байт). Например, выполним: <span class="nmbr">100000</span><span class="var">А</span><span class="nmbr">10</span><span class="var">Л</span> 
		- на экран будет выдано содержимое первых четырёх слов ПЗУ, после чего если 
		мы дадим директиву <span class="var">А</span>, то получим:
		<span class="var">А</span>=<span class="nmbr">100010</span>.</li>
		<li><span class="var">И </span>- индикация содержимого слова по текущему 
		адресу.</li>
		<li>(...)<span class="var">И</span> - запись числа (...) в слово по текущему 
		адресу.</li>
		<li><span class="var">Б</span> - индикация содержимого байта по текущему 
		адресу.</li>
		<li>(...)<span class="var">Б</span> - запись числа (...) в байт по текущему 
		адресу.</li>
	</ul>
	<p>Необходимо отметить, что как слово, так и байт выдаются в виде шести цифр. 
	При выдаче байта, конечно, три старшие цифры всегда нули. При вводе байта с 
	клавиатуры может быть набрано любое количество цифр, но запись производится 
	только по модулю <span class="nmbr">256</span><sub>д</sub> (т.е. остатка от 
	целочисленного деления на <span class="nmbr">256</span>) шести цифр, набранных 
	последними. При байтовых операциях параметр А может быть и нечётным, при этом 
	он определяет старший байт слова с чётным адресом, меньшим на единицу.</p>
	<ul>
		<li><span class="var">Ц</span> - циклическое (т.е. непрерывное) чтение слова 
		по адресу <span class="var">А</span>. Команда может быть полезна для исследования 
		ячеек памяти с изменяющейся во времени информацией. Выход из цикла - клавиша &laquo;<i>СТОП</i>&raquo;. 
		Например, дайте директиву: <span class="nmbr">177662</span><span class="var">АЦ</span>, 
		затем нажимайте различные клавиши и наблюдайте за результатами циклического 
		чтения данной ячейки на экране.</li>
		<li><span class="var">Щ</span> - снять защиту системной области. Мы уже 
		отмечали, что область адресов <span class="nmbr">0</span>...<span class="nmbr">777</span> 
		называется <b>системной</b> и используется преимущественно для собственных 
		нужд ЭВМ. Запись туда случайной информации может грозить неприятностями, 
		вплоть до полного отказа ЭВМ в работе (конечно, временного, до отключения 
		питания или перезапуска ЭВМ, но информация, хранящаяся в ОЗУ, при этом будет 
		утрачена). Чтобы избежать неприятностей, системная область защищена в МСД 
		от случайной записи, и при попытке сделать это выдаётся сообщение &laquo;<span class="strn">ЗЩ</span>&raquo; 
		- <b>защита</b>. После подачи директивы &laquo;<span class="var">Щ</span>&raquo; 
		защита снимается и возможна запись в системную область. Восстановление защиты 
		- клавиша &laquo;<i>СТОП</i>&raquo;.</li>
		<li><span class="var">,</span> (запятая) - чтение слова с инкрементом (<b>инкремент</b> 
		- увеличение). По данной директиве текущий адрес <span class="var">А</span> 
		увеличивается на <span class="nmbr">2</span>, а затем содержимое ячейки 
		по этому адресу выводится на экран.</li>
		<li>(...)<span class="var">,</span> - запись слова по текущему адресу с 
		инкрементом: по текущему адресу записывается слово (...), а затем адрес 
		увеличивается на <span class="nmbr">2</span> и выводится слово по этому 
		адресу. Эти директивы используются преимущественно для чтения или записи 
		последовательно расположенных ячеек памяти.</li>
		<li><span class="var">-</span> (минус) - чтение слова по текущему адресу 
		с декрементом.</li>
		<li>(...)<span class="var">-</span> - запись слова (...) по текущему адресу 
		с декрементом (<b>декремент</b> - уменьшение). Данная директива аналогична 
		предыдущей, с той лишь разницей, что значение текущего адреса
		<span class="var">А</span> не увеличивается, а уменьшается на
		<span class="var">2</span>.</li>
		<li><span class="var">.</span> (точка) - чтение байта с инкрементом.</li>
		<li>(...)<span class="var">.</span> - запись байта с инкрементом.</li>
		<li><span class="var">:</span> (двоеточие) - чтение байта с декрементом.</li>
		<li>(...)<span class="var">:</span> - запись байта с декрементом.</li>
	</ul>
	<p>Пара последних директив полностью аналогична двум предыдущим, только работают 
	они не со словом, а с байтом, и увеличение или, соответственно, уменьшение текущего 
	адреса при их исполнении происходит не на <span class="nmbr">2</span>, а на
	<span class="nmbr">1</span>. Для этих команд действительны и нечётные адреса.</p>
	<ul>
		<li><span class="var">МП</span> - пуск мотора магнитофона при наличии дистанционного 
		управления (ДУ) от БК-0010. Останов мотора - любая символьная клавиша или &laquo;<i>СТОП</i>&raquo;. 
		Отметим, что описанная в &laquo;Руководстве системного программиста БК-0010&raquo; 
		директива &laquo;<span class="var">МС</span>&raquo; (останов магнитофона) 
		бессмысленна, так как по нажатию первой же клавиши (М) магнитофон остановится 
		и нажимать вторую уже как-то ни к чему, разве что для порядка.</li>
		<li><span class="var">МФ</span> - фиктивное чтение файлов с магнитной ленты. 
		На запрос &laquo;<span class="strn">ИМЯ=</span>&raquo; нужно ввести имя 
		того файла, <b>после</b> которого магнитофон должен быть остановлен. Загрузка 
		файла в ОЗУ и проверка контрольной суммы по данной директиве не производится, 
		а имена, не совпадающие с заданным, выводятся на экран. (Обычно эта директива 
		используется для просмотра содержимого кассеты при поиске нужного файла. 
		- <em>Прим. ред.</em>)</li>
		<li><span class="var">МЧ</span> - загрузка файла с МЛ. На запрос &laquo;<span class="strn">АДРЕС=</span>&raquo; 
		необходимо ввести адрес в ОЗУ, начиная с которого должен быть загружен файл, 
		а на &laquo;<span class="strn">ИМЯ=</span>&raquo; - имя загружаемого файла. 
		После набора очередных цифровых данных или имени файла необходимо нажимать 
		клавишу &laquo;<i>ВВОД</i>&raquo;, исправлять ошибки можно клавишей &laquo;<i>ЗАБОЙ</i>&raquo;. 
		Если вместо адреса задать число &laquo;<span class="nmbr">0</span>&raquo;, 
		то файл будет загружен по адресу, указанному в его <b>оглавлении</b>, т.е. 
		в специальном блоке, записанном на МЛ в начале файла. Фактически файл при 
		этом будет загружен в ту область памяти, из которой он был записан на МЛ, 
		а чаще всего именно это и требуется.</li>
		<li><span class="var">МЗ</span> - запись хранящегося в ОЗУ или ПЗУ массива 
		данных в виде файла на МЛ. На запрос &laquo;<span class="strn">АДРЕС=</span>&raquo; 
		вводится адрес начала массива, &laquo;<span class="strn">ДЛИНА=</span>&raquo; 
		- его длина в байтах. &laquo;<span class="strn">ИМЯ=</span>&raquo; - имя 
		файла, под которым он должен быть записан (имя файла в МСД может состоять 
		не более чем из <span class="nmbr">16</span><sub>д</sub> <b>любых</b> символов; 
		если его длина меньше, оно автоматически дополняется пробелами). Все указанные 
		параметры заносятся в оглавление файла при его записи на МЛ.</li>
	</ul>
	<p>Заметим, что при исполнении трёх, последних директив магнитофон с помощью 
	ДУ автоматически включается, а по окончании чтения или записи (или при нажатии 
	клавиши &laquo;<i>СТОП</i>&raquo;) - отключается. Нужно сказать, что ДУ магнитофона 
	при работе с БК - громадное удобство, оценить которое могут лишь те, кто с ним 
	работал. К сожалению, немногие бытовые магнитофоны имеют вход ДУ, совместимый 
	с БК-0010, поэтому большинство пользователей никогда не работали с ним и даже 
	не знают, чего они лишены! (Многие пользователи, имея в своём магнитофоне дистанционное 
	управление, и не подозревают об этом! Так, в некоторых модификациях магнитофона &laquo;<i>Электроника-<span class="nmbr">302</span></i>&raquo; 
	ДУ &laquo;<i>встроено</i>&raquo; в цепь внешнего микрофона и может быть использовано 
	при работе БК, если включить в гнездо микрофонного входа штекер стандартного 
	магнитофонного кабеля БК. - <em>Прим. ред.</em>)</p>
	<ul>
		<li><span class="var">К</span> - выход из МСД. При этом управление передаётся 
		Фокалу, т.е. по адресу <span class="nmbr">120000</span>. Содержимое ОЗУ 
		пользователя стирается (кроме зоны адресов <span class="nmbr">1000</span>...<span class="nmbr">1377</span>).</li>
		<li><span class="var">ТК</span> - выход в тесты. После выполнения данной 
		директивы появляется приглашение тест-системы: &laquo;<span class="symb">+</span>&raquo;. 
		Если не проводить тесты <span class="nmbr">1</span> и <span class="nmbr">
		5</span>, то содержимое ОЗУ сохраняется. Можно вернуться в МСД. как обычно:
		<span class="symb">РУС</span>, <span class="symb">Т</span>,
		<span class="symb">С</span>.</li>
		<li><span class="var">ТД</span> - переход к тестам внешней диагностики. 
		Применяется при наличии дополнительной диагностической аппаратуры, подключаемой 
		к разъёму системной магистрали (разъем МПИ) БК-0010.</li>
		<li><span class="var">Т0</span>, <span class="var">Т1</span>, ...,
		<span class="var">Т5</span> - запуск тестов МСД. Набор из этих шести тестов 
		несколько отличается от тестов <span class="nmbr">1</span>...<span class="nmbr">5</span> 
		тест-системы, но в целом они аналогичны. Отметим, что весьма полезным является 
		тест <span class="nmbr">2</span> МСД, а тест <span class="nmbr">0</span> 
		может выполняться только при работе ЭВМ в составе локальной сети (в классе 
		КУВТ).</li>
		<li>(...)<span class="var">G</span> - запуск программы по адресу (...). 
		Это единственное исключение, когда директива МСД подаётся в регистре ЛАТ-ЗАГЛ.</li>
	</ul>
	<p>Теперь, когда мы ознакомились с директивами МСД, ответим на вопрос, для чего 
	может быть полезна система отладки. Ясно, что в МСД можно как просматривать 
	память ЭВМ, так и изменять её содержимое, т.е. заносить в ячейки памяти информацию. 
	Зная язык <b>машинных кодов</b> (или <b>команд</b>), в МСД можно писать программы 
	в кодах, вводить массивы данных, записывать их в виде файлов на МЛ, запускать, 
	отлаживать.</p>
	<p>Хотя язык машинных кодов не так сложен, как принято обычно считать, программировать 
	непосредственно в кодах неудобно, это требует большого напряжения и отличной 
	памяти (имеется в виду, конечно, память программиста, а не БК). Поэтому разработан 
	специальный вспомогательный <b>язык ассемблера</b>, он позволяет достичь тех 
	же самых результатов гораздо меньшей ценой. Зато, имея уже готовую распечатку 
	программы в кодах, можно относительно легко ввести её в память, пользуясь директивами 
	МСД. Это позволяет публиковать тексты сравнительно небольших программ в печатных 
	изданиях, избавляя от необходимости тиражировать их непосредственно на МЛ. Если 
	вам требуется ввести такую программу, то, чтобы избежать ошибок, рекомендуется 
	сделать это дважды по разным адресам, а затем провести сверку этих массивов 
	- маловероятно, что в обоих случаях вы сделаете одинаковые ошибки. Попробуйте 
	ввести в память и запустить простейшую программу в кодах, для чего выполните 
	команды:</p>
	<pre><span class="nmbr">1000</span><span class="var">А</span>
<span class="nmbr">12700</span>, <span class="nmbr">14</span>, <span class="nmbr">104016</span>, <span class="nmbr">12700</span>, <span class="nmbr">101</span>, <span class="nmbr">104016</span>, <span class="nmbr">0</span>,
<span class="nmbr">1000</span><span class="var">G</span></pre>
	<p>На выводимые по директиве &laquo;<i>запятая</i>&raquo; числа не обращайте 
	внимания и набирайте новые. После запуска эта программа выполняет сброс экрана 
	и выводит символ &laquo;<span class="strn">А</span>&raquo;. Как видите, программирование 
	в кодах - не такая уж сложная штука! (Если перед входом в режим МСД из тест-системы 
	выполнить тест <span class="nmbr">1</span> (ОЗУ, ПЗУ), то при последующем вводе 
	программы в кодах после нажатия на клавишу &laquo;<i>запятая</i>&raquo; будет 
	каждый раз выводиться адрес очередной ячейки памяти. - <em>Прим. ред.</em>)</p>
	<p>Директивы МСД для работы с магнитофоном, как легко догадаться, позволяют 
	не только загружать программы с МЛ, но и копировать их, если после загрузки 
	записать на МЛ загруженный массив, причём безразлично, на каком языке написана 
	эта программа, нужно лишь знать её адрес и длину. (Кроме некоторых программ 
	с автозапуском или загружаемых в ОЗУ экрана. - <em>Прим. ред.</em>)</p>
	<p>В заключение приведём некоторые полезные сведения, которыми можно воспользоваться 
	при работе в МСД.</p>
	<ul>
		<li>Определить параметры успешно загруженного файла можно, если знать, что 
		в ячейке <span class="nmbr">264</span> хранится адрес его загрузки, а в 
		ячейке <span class="nmbr">266</span> - длина (достаточно дать директиву
		<span class="nmbr">264</span><span class="var">А</span><span class="nmbr">4</span><span class="var">Л</span>). 
		Контрольная сумма файла хранится в ячейке <span class="nmbr">312</span> 
		и выводится директивой <span class="nmbr">312</span><span class="var">АИ</span>. 
		Но можно определить параметры файла (кроме контрольной суммы) и не загружая 
		его, для чего необходимо в режиме фиктивного чтения (<span class="var">МФ</span>) 
		прочитать его имя (независимо от того, совпадает ли оно с заданным), после 
		чего адрес файла содержится в ячейке <span class="nmbr">346</span>, а длина 
		- в ячейке <span class="nmbr">350</span>, причём адрес при этом будет &laquo;<i>истинный</i>&raquo;, 
		т.е. указанный в оглавлении на МЛ, а не заданный в процессе загрузки, как 
		это имеет место при чтении ячейки <span class="nmbr">264</span>. Ячейки
		<span class="nmbr">346</span> и <span class="nmbr">350</span> могут быть 
		прочитаны и после загрузки файла с тем же результатом. Отметим, что контрольная 
		сумма в ячейке <span class="nmbr">312</span> вычисляется не так, как описанная 
		выше, и поэтому обычно не совпадает с контрольной суммой массива, полученной 
		в МСД по директиве &laquo;<span class="var">X</span>&raquo;.</li>
		<li>По директиве <span class="nmbr">100274</span><span class="var">G</span> 
		происходит переход в <b>пусковой монитор</b> (ПМ, символ диалога - &laquo;<span class="symb">?</span>&raquo;) 
		без стирания ОЗУ (ПМ мы не описывали, так как он практически всем хорошо 
		известен и значительно уступает МСД по набору директив и своим возможностям). 
		Перейти же из ПМ в МСД можно через тесты, нажав клавиши:
		<span class="symb">Т</span>, <span class="symb">ВВОД</span>,
		<span class="symb">РУС</span>, <span class="symb">Т</span>,
		<span class="symb">С</span> (также без стирания ОЗУ). Перейти в ПМ без стирания 
		экрана и выхода из режима РП (если он установлен) можно, выполнив директивы:
		<span class="nmbr">4</span><span class="var">АЩ</span><span class="nmbr">100442</span><span class="var">И</span> 
		после чего нужно нажать клавишу &laquo;<i>СТОП</i>&raquo;. Смысл того, что 
		при этом делается, вы поймёте в дальнейшем.</li>
		<li>Перейти из МСД в Фокал без стирания ОЗУ можно, выполнив последовательность 
		директив:
		<pre><span class="var">Щ</span>
<span class="nmbr">120020</span><span class="var">А</span><span class="nmbr">26</span><span class="var">Д</span><span class="nmbr">0</span><span class="var">П</span>
<span class="nmbr">262</span><span class="var">А</span><span class="nmbr">177777</span><span class="var">И</span>
«СТОП»</pre>
		<p class="contn">После этого на экране появляется сообщение Фокала &laquo;<span class="strn">ОСТАНОВ 
		ПО КЛАВИШЕ СТОП</span>&raquo;. Чтобы такой переход был успешным, выход из 
		Фокала перед этим должен быть произведён непосредственно в МСД, а не через 
		ПМ, и в МСД не должны загружаться (а тем более запускаться!) программы в 
		кодах. При соблюдении этих условий после выхода в Фокал содержимое ОЗУ полностью 
		сохраняется. Ранее загруженные в Фокале программы могут даже запускаться 
		для дальнейшей работы, возможен просмотр их листинга и т.п. Переход Фокал-МСД-Фокал 
		может делаться таким способом неоднократно, например, с целью модификации 
		в МСД Фокал-программ или для изучения их формата. К сожалению, более подробно 
		останавливаться на этом вопросе нет возможности.</p>
		</li>
		<li>Выйти из пускового монитора в Бейсик без стирания ОЗУ (с сохранением 
		ранее загруженной Бейсик-программы) можно командой <span class="var">С</span><span class="nmbr">120234</span> 
		ВВОД. Правда, ключи клавиатуры (клавиши <span class="nmbr">1</span>-<span class="nmbr">9</span> 
		и <span class="nmbr">0</span> по регистру АР2) при этом не сохраняются.</li>
	</ul>
	<h3><a name="toc_11"></a>Диагностические сообщения МСД</h3>
	<p>В процессе работы в МСД система ведёт развёрнутый диалог с пользователем, 
	выдавая различные указания и сообщая результаты исполнения директив. Обычно 
	сообщения МСД выдаются в достаточно понятной форме и не требуют особых комментариев, 
	особенно если вы хорошо знаете директивы. Но есть несколько специальных <b>диагностических 
	сообщений</b>, которые весьма кратки и нуждаются в пояснении. С одним из них 
	мы уже познакомились:</p>
	<ul>
		<li><span class="strn">ЗЩ</span> - защита системной области. Выдача этого 
		сообщения означает, что произведена попытка выполнить с помощью одной из 
		директив МСД запись в область адресов <span class="nmbr">0</span>...<span class="nmbr">777</span>. 
		Напомним, что на запись в системную область наложен запрет (до снятия защиты) 
		исключительно для директив МСД, но не для машинных команд, поэтому от программы 
		пользователя системная область никак не защищена, это забота программиста.</li>
	</ul>
	<p>Ещё два сообщения МСД нам пока не встречались, и их следует рассмотреть более 
	подробно.</p>
	<ul>
		<li><span class="strn">3В</span>(...) - зависание по адресу (...).
		<p>Это сообщение выдаётся в двух основных случаях: при попытке записи по 
		адресу ПЗУ и попытке чтения или записи по несуществующему адресу.</p>
		<p>Относительно записи информации в область адресов, занимаемую ПЗУ. всё 
		ясно - запись по адресам <span class="nmbr">100000</span>...<span class="nmbr">177577</span> 
		запрещена аппаратно и невозможна по техническим причинам. А что такое несуществующий 
		адрес? Это адрес, где нет реального аппаратного устройства, которое могло 
		бы ответить на вызов процессора. При выполнении подобных некорректных операций 
		процессор, не получив ответа от устройства (например, ОЗУ), выполняет так 
		называемое <b>прерывание по зависанию</b> и производит переход по <b>вектору
		<span class="nmbr">4</span></b> (что это такое, станет ясно в дальнейшем), 
		результатом чего и является выдача сообщения &laquo;<span class="strn">ЗВ</span>&raquo; 
		- <b>зависание</b> и значения текущего адреса <span class="var">А</span>. 
		Понятно, что если зависание возникло в результате исполнения директивы МСД 
		(например, <span class="nmbr">100000</span><span class="var">А</span><span class="nmbr">377</span><span class="var">И</span>), 
		то выданное значение обычно и есть тот адрес, по которому произошло зависание. 
		Но в прочих случаях, например, при исполнении программы, выданное значение 
		и адрес, по которому произведено некорректное обращение, как правило, не 
		имеют ничего общего. В этом случае информацию несёт только само сообщение &laquo;<span class="strn">ЗВ</span>&raquo;.</p>
		</li>
		<li><span class="strn">НК</span> - неправильная команда. В набор команд 
		процессора входит строго фиксированный перечень кодов. В случае, если код 
		очередной команды, встретившейся в программе, не входит в этот перечень, 
		процессор выполняет <b>прерывание по резервному коду</b> и производит переход 
		по <b>вектору <span class="nmbr">10</span></b> (что также будет в дальнейшем 
		разъяснено). В результате и выдаётся сообщение &laquo;<span class="strn">НК</span>&raquo;. 
		Следует особо отметить, что далеко не весь набор команд процессора К1801ВМ1 
		использован в БК-0010 (или, как говорят, реализован аппаратно). Вследствие 
		этого есть такие коды (не перечисленные, в частности, в &laquo;<i>Руководстве 
		системного программиста</i>&raquo;, прилагаемом к БК), которые вместо ожидаемого 
		сообщения &laquo;<span class="strn">НК</span>&raquo; вызывают сообщение &laquo;<span class="strn">ЗВ</span>&raquo;. 
		Примером является код <span class="nmbr">12</span>. По нему процессор должен 
		был бы произвести запись некоторой информации в область системных регистров. 
		Но нужных регистров в адресном пространстве БК-0010 просто нет, поэтому 
		и происходит прерывание по зависанию. Примером же действительно несуществующей 
		команды является код <span class="nmbr">30,</span> вызывающий, как и положено, 
		сообщение &laquo;<span class="strn">НК</span>&raquo;. Знание этих особенностей 
		поведения процессора позволяет иногда разобраться в загадочных, казалось 
		бы, сообщениях при отладке программы.</li>
	</ul>
	<p>Необходимо отметить, что описанные сообщения выдаются только в том случае, 
	если выполняются программы пользователя, загруженные и запущенные в МСД (либо 
	при выполнении директив самой МСД). Если же загрузка и запуск программ производятся 
	из ПМ либо программа пользователя изменяет значение <b>векторов прерывания</b>
	<span class="nmbr">4</span> и <span class="nmbr">10</span>. диагностические 
	сообщения МСД, разумеется, выдаваться не будут.</p>
	<p>Итак, мы вкратце познакомились с мониторной системой диагностики БК-0010, 
	хотя нам и пришлось ради этого надолго прервать описание архитектуры ЭВМ. Но 
	затраченное время в дальнейшем окупится - теперь вы сможете не просто знакомиться 
	с материалом, предлагаемым вашему вниманию, но во многих случаях активно проверять 
	его на своём БК, экспериментировать. Никогда не упускайте случая потренироваться 
	в работе с МСД, а заодно и проверить автора - он ведь тоже может ошибаться!</p>
	<h3><a name="toc_12"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Для чего служит МСД?
		<ul id="ctrla">
			<li>
			<p>Для просмотра и изменения содержимого ОЗУ, записи и чтения файлов, 
			написания и отладки программ в кодах.</p>
			</li>
		</ul>
		</li>
		<li>Как называют знак диалога МСД?
		<ul id="ctrla">
			<li>
			<p>Знак денежной единицы, &laquo;<i>колесо</i>&raquo;.</p>
			</li>
		</ul>
		</li>
		<li>В каком регистре (РУС, ЛАТ, СТР, ЗАГЛ) подаются буквенные директивы 
		МСД? Какое исключение из этого правила?
		<ul id="ctrla">
			<li>
			<p>В регистре РУС-ЗАГЛ, за исключением директивы <span class="var">G</span>.</p>
			</li>
		</ul>
		</li>
		<li>Выполните следующее задание:
		<ul class="seln">
			<li>запишите на МЛ содержимое монитор-драйверной системы БК-0010 (вы 
			помните адрес и длину этого массива?);</li>
			<li>загрузите записанный файл в экранное ОЗУ (с адреса
			<span class="nmbr">40000</span>);</li>
			<li>вызовите из ячеек <span class="nmbr">264</span>,
			<span class="nmbr">266</span>, <span class="nmbr">312</span>,
			<span class="nmbr">346</span>, <span class="nmbr">350</span> его параметры 
			и поясните, &laquo;<i>что есть что</i>&raquo;.</li>
		</ul>
		<ul id="ctrla">
			<li>
			<p>Порядок действий (сообщения МСД частично опущены):</p>
			<ul>
				<li><span class="var">М3</span>; <span class="strn">АДРЕС=</span><span class="nmbr">100000</span>;
				<span class="strn">ДЛИНА=</span><span class="nmbr">20000</span>;
				<span class="strn">ИМЯ=</span>МДС;</li>
				<li><span class="var">МЧ</span>; <span class="strn">АДРЕС=</span><span class="nmbr">40000</span>;
				<span class="strn">ИМЯ=</span>МДС;</li>
				<li><span class="nmbr">264</span><span class="var">А</span><span class="nmbr">4</span><span class="var">Л</span>; 
				ответ: <span class="nmbr">040000</span> <span class="nmbr">020000</span> 
				- адрес загрузки и длина файла МДС;</li>
				<li><span class="nmbr">346<span class="var">А</span>4<span class="var">Л</span></span>; 
				ответ: <span class="nmbr">100000</span> <span class="nmbr">020000</span> 
				- &laquo;<i>истинные</i>&raquo; адрес и длина файла МДС;</li>
				<li><span class="nmbr">312</span><span class="var">АИ</span>; ответ:
				<span class="nmbr">017341</span> - контрольная сумма файла МДС (не 
				совпадающая, как видите, с контрольной суммой в МСД, равной
				<span class="nmbr">177777</span>).</li>
			</ul>
			</li>
		</ul>
		</li>
		<li>Как перейти из МСД в ПМ без стирания экранного ОЗУ?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">4</span><span class="var">АЩ</span><span class="nmbr">100442</span> &laquo;<i>СТОП</i>&raquo;.</p>
			</li>
		</ul>
		</li>
		<li>Предположим, вы загрузили и запустили из режима МСД некоторую программу, 
		например, ассемблер-систему. При работе с ней (или при запуске написанной 
		в ней программы) получено сообщение: <span class="strn">3B</span><span class="nmbr">003474</span>. 
		О чём это сообщение говорит и почему вы так думаете?
		<ul id="ctrla">
			<li>
			<p>Сообщение говорит только о том, что произошло зависание; число
			<span class="nmbr">003474</span> не несёт никакой информации, так как 
			работала программа пользователя, а не директивы МСД.</p>
			</li>
		</ul>
		</li>
		<li>Постарайтесь выучить директивы МСД и порядок работы с ними наизусть 
		- вам часто придётся ими пользоваться.</li>
	</ol>
	<h2><a name="toc_13"></a>Системные регистры</h2>
	<p>Совершая путешествие по нашему &laquo;<i>городу</i>&raquo; БК-0010, мы отметили, 
	что &laquo;<i>район</i>&raquo; ПЗУ тянется почти до конца адресного пространства 
	- до адреса <span class="nmbr">177577</span>. А что же дальше? С адреса
	<span class="nmbr">177600</span> и до конца &laquo;<i>улицы</i>&raquo; (по адрес
	<span class="nmbr">177777</span>) располагается так называемая <b>область системных 
	регистров</b>.</p>
	<p>Системные регистры микро-ЭВМ служат для связи с внешними устройствами, а 
	также для некоторых других целей. Каждый регистр занимает в адресном пространстве 
	одно слово, следовательно, имеет <span class="nmbr">16</span><sub>д</sub> разрядов, 
	с нулевого по пятнадцатый. Простой арифметический подсчёт показывает, что в 
	области адресов <span class="nmbr">177600</span>...<span class="nmbr">177776</span> 
	содержится <span class="nmbr">100</span> слов, а значит, там можно разместить
	<span class="nmbr">100</span> (<span class="nmbr">64</span><sub>д</sub>) регистров. 
	Но далеко не все адреса этой области использованы в нашем компьютере. Рассмотрим 
	имеющиеся в БК-0010 системные регистры в порядке возрастания их адресов. При 
	этом нужно учитывать, что и в имеющихся регистрах далеко не все разряды (биты) 
	используются. Некоторые разряды хранят только определённую, строго фиксированную 
	информацию, которую нельзя изменить, подобно данным, хранимым в ПЗУ. В других 
	информацию меняет только сама ЭВМ, а программист может лишь читать её и использовать 
	результаты (говорят, что такие разряды <b>доступны по чтению</b>). В некоторые 
	разряды регистров можно, наоборот, только записать информацию, но прочитать 
	то, что записано, нельзя (разряды, <b>доступные по записи</b>). Наконец, есть 
	разряды, в которые можно как записывать информацию, так и читать, - они <b>доступны 
	по записи и чтению</b>.</p>
	<p>Чем системные регистры (например, доступные по записи и чтению) отличаются 
	от ячеек ОЗУ? Отличие существенное - информацию в ячейках памяти может записывать, 
	читать и использовать только ЦП, он же выводит её на экран по вашей команде. 
	А разряды системных регистров могут быть связаны непосредственно с внешними 
	устройствами - с клавиатурой, магнитофоном, телеграфной линией, - словом, с 
	внешним миром; могут принимать оттуда сигналы или. наоборот, передавать. Есть, 
	правда, регистры, казалось бы, ни с чем не связанные, например таймер (о котором 
	речь пойдёт позже). Но это не более чем заблуждение; таймер тоже связан с внешним 
	миром - через физическое время!</p>
	<p>А что же отсутствующие регистры? Это просто резерв для расширения нашей микро-ЭВМ 
	в будущем, так сказать, пустые пока &laquo;<i>участки под застройку</i>&raquo; 
	(в машинах серии ДВК, а также в БК-0010Ш, работающих в составе комплекса учебной 
	вычислительной техники КУВТ-86, часть из них уже используется).</p>
	<p>Итак, приступим к прогулке по последнему &laquo;<i>переулку</i>&raquo; адресного 
	пространства. Вы готовы? Тогда - в путь!</p>
	<p>Напомним, что каждый регистр имеет <span class="nmbr">16</span> разрядов, 
	нумеруемых справа налево, причём нумерация начинается с нуля. Номера разрядов 
	- десятичные. По ходу их перечисления будем также указывать, для чего можно 
	использовать тот или иной разряд при программировании (как их использует ЭВМ 
	- другой вопрос).</p>
	<ol>
		<li><b>Регистр состояния клавиатуры</b> (адрес <span class="nmbr">177660</span>). 
		Используются только два разряда:
		<ul>
			<li><b>Разряд <span class="nmbr">06</span></b> - маска прерываний от 
			клавиатуры. Если бит равен <span class="nmbr">0</span> - прерывание 
			разрешено. <span class="nmbr">1</span> - запрещено. Доступен по записи 
			и чтению. Можно использовать, чтобы программно &laquo;<i>отключить</i>&raquo; 
			клавиатуру ЭВМ.</li>
			<li><b>Разряд <span class="nmbr">07</span></b> - флаг состояния клавиатуры. 
			Устанавливается в <span class="nmbr">1</span> при поступлении новых 
			данных в <b>регистр данных клавиатуры</b> (см. ниже), например, при 
			нажатии очередной клавиши, и сбрасывается в <span class="nmbr">0</span> 
			при чтении. Доступен только по чтению. Если запретить автоматические 
			чтение из регистра данных, этот разряд может использоваться, чтобы определить, 
			была ли нажата клавиша за истекший промежуток времени. В обычных условиях, 
			когда данные читаются сразу после нажатия клавиши, состояние разряда 
			всегда <span class="nmbr">0</span>, так как системные драйверы БК реагируют 
			на нажатие клавиши быстрее, чем пользовательская программа.</li>
		</ul>
		</li>
		<li><b>Регистр данных клавиатуры</b> (адрес <span class="nmbr">177662</span>). 
		Используются семь младших разрядов:
		<ul>
			<li><b>Разряды <span class="nmbr">00</span>...<span class="nmbr">06</span></b> 
			- буфер кода нажатой клавиши. При нажатии клавиши в него заносится
			<span class="nmbr">7</span>-разрядный код, на который не влияют клавиши &laquo;<i>НР</i>&raquo; 
			(&laquo;<i>АР2</i>&raquo; для БК-0010.01) и &laquo;<i>РУС</i>&raquo;. 
			Полные коды клавиатуры получаются в БК-0010 программным путём. Разряды 
			доступны только по чтению и широко используются для чтения кода клавиатуры 
			независимо от регистра РУС-ЛАТ, для ввода команд без прерывания работы 
			программы (в том числе и на языках высокого уровня) и т.п.</li>
		</ul>
		</li>
		<li><b>Регистр смещения</b> (адрес <span class="nmbr">177664</span>). Используются
		<span class="nmbr">9</span> разрядов:
		<ul>
			<li><b>Разряды <span class="nmbr">00</span>...<span class="nmbr">07</span></b> 
			отображают адрес начала экранного ОЗУ, которое организовано по типу 
			рулона, причём их значение указывает количество телевизионных строк 
			дисплея (каждая строка - <span class="nmbr">100</span> (<span class="nmbr">64</span><sub>д</sub>) 
			байт экранного ОЗУ). В исходном состоянии, когда началу экрана соответствует 
			адрес <span class="nmbr">40000</span>, содержимое этих разрядов равно
			<span class="nmbr">330</span>. По мере сдвига экрана содержимое меняется 
			причём, так как одна строка текста в БК-0010 содержит
			<span class="nmbr">12</span> (<span class="nmbr">10</span><sub>д</sub>) 
			телевизионных строк, содержимое регистра также меняется каждый раз на
			<span class="nmbr">12</span>. Вверху экрана, как известно, имеется служебная 
			строка, занимающая в экранном ОЗУ <span class="nmbr">2000</span> байт 
			(каждая строка обычного текста - <span class="nmbr">1200</span> байт). 
			Эти тонкости приводят к тому, что число сдвигов, необходимое, чтобы 
			начало экрана получило снова адрес <span class="nmbr">40000</span>, 
			не кратно числу строк текста (<span class="nmbr">24</span><sub>д</sub>) 
			и содержимое младших разрядов данного регистра практически всё время 
			разное. Разряды доступны по записи и чтению и могут использоваться для 
			плавного сдвига изображения на экране по вертикали. Служебная строка 
			при этом тоже смещается, поэтому данный способ требует специальных приёмов 
			получения изображения.</li>
		</ul>
		<p>Нужно отметить, что в режиме &laquo;<i>РП</i>&raquo; экран организован 
		совсем иначе, чем описано выше, служебная строка (начало экрана) всегда 
		имеет адрес <span class="nmbr">70000</span>, рулонное смещение не используется, 
		а регистр всегда содержит константу <span class="nmbr">230</span>.</p>
		<ul>
			<li><b>Разряд <span class="nmbr">09</span></b> - задание режима расширенной 
			памяти, что соответствует нулю в данном бите. Единица - обычный режим 
			(в &laquo;<i>Руководстве системного программиста</i>&raquo; ошибочно 
			указано наоборот). Разряд доступен по записи и чтению, может использоваться 
			для обнаружения режима &laquo;<i>РП</i>&raquo;, но включить расширенную 
			память, просто записав туда <span class="nmbr">0</span>, нельзя (вернее, 
			этого недостаточно)</li>
		</ul>
		</li>
		<li><b>Регистры системного таймера</b> (адреса <span class="nmbr">177706</span>,
		<span class="nmbr">177710</span>, <span class="nmbr">177712</span>). Эти 
		три регистра не описаны ни в одном руководстве по БК-0010, поэтому заслуживают 
		подробного рассмотрения.
		<p>Прежде всего, что такое системный таймер? Это специальный счётчик, работающий 
		независимо от ЦП. Если запустить такой счётчик, а потом в какие-либо фиксированные 
		моменты времени читать его показания, то по их разности можно определить 
		прошедший отрезок времени.</p>
		<p>Итак, наш таймер имеет три регистра. Первый из них - <b>регистр предустановки</b> 
		таймера (адрес <span class="nmbr">177706</span>) - доступен по записи и 
		чтению, используются все <span class="nmbr">16</span> разрядов. Второй -
		<b>счётчик</b> (<span class="nmbr">177710</span>) - собственно таймер, доступен 
		только по чтению, используются все <span class="nmbr">16</span> разрядов. 
		Третий - <b>регистр управления</b> (<span class="nmbr">177712</span>) - 
		доступен по записи и чтению, используется младший байт (разряды
		<span class="nmbr">00</span>-<span class="nmbr">07</span>).</p>
		<p>Попробуем разобраться, как работает таймер. Если мы подадим определённую 
		команду (запишем в регистр <span class="nmbr">177712</span> некоторое число), 
		то в регистр счётчика <span class="nmbr">177710</span> будет занесена константа, 
		всегда равная содержимому регистра предустановки, и начнётся отсчёт времени 
		- из константы будет вычитаться по единице до получения в счётчике нуля. 
		Дальнейшее поведение таймера зависит от занесённой в регистр управления 
		команды, а именно от того, какие разряды младшего байта регистра управления 
		установлены в <span class="nmbr">0</span> или <span class="nmbr">1</span>. 
		Рассмотрим далее их назначение.</p>
		<ul>
			<li>Разряд <span class="nmbr">00</span> при установке в
			<span class="nmbr">1</span> запрещает счёт и переписывает в регистр 
			счётчика константу из регистра предустановки (<b>режим предустановки</b>).</li>
			<li>Разряд <span class="nmbr">01</span> при установке в
			<span class="nmbr">1</span> запрещает фиксацию перехода счётчика через
			<span class="nmbr">0</span> (<b>режим непрерывного счета</b>): досчитав 
			до нуля, таймер продолжает вычитание, в счётчике появляется число
			<span class="nmbr">177777</span>, затем <span class="nmbr">177776</span> 
			и т.д. Действие разрядов <span class="nmbr">02</span> и
			<span class="nmbr">03</span> (см. ниже) при этом, естественно, отменяется, 
			как и повторная перезапись константы из регистра предустановки.</li>
			<li>Разряд <span class="nmbr">02</span> при установке в
			<span class="nmbr">1</span> включает индикацию: при очередном переходе 
			таймера через <span class="nmbr">0</span> устанавливается в
			<span class="nmbr">1</span> разряд <span class="nmbr">07</span> регистра 
			управления, если ранее он был сброшен (<b>режим индикации</b>). Нужно 
			учитывать, что при первом (после включения ЭВМ или &laquo;<i>системного 
			сброса</i>&raquo;) запуске таймера в данном режиме индикация срабатывает 
			только после <b>второго</b> перехода счётчика через
			<span class="nmbr">0</span>. Причём независимо от того, работал ли таймер 
			до этого в других режимах.</li>
			<li>Разряд <span class="nmbr">03</span> при установке в
			<span class="nmbr">1</span> запрещает повторный счёт: после первого 
			досчёта до <span class="nmbr">0</span> устанавливается в
			<span class="nmbr">0</span> разряд <span class="nmbr">04</span> (<b>режим 
			однократного счета</b>). Установка данного режима не отменяет режим 
			индикации (при установке в <span class="nmbr">1</span> разряда
			<span class="nmbr">02</span>).</li>
			<li>Разряд <span class="nmbr">04</span> при установке в
			<span class="nmbr">1</span> разрешает счёт (<b>режим счета</b>). В этом 
			режиме при досчёте до <span class="nmbr">0</span> в счётчик заново заносится 
			константа из регистра предустановки, следовательно, счёт всегда ведётся 
			от константы до <span class="nmbr">0</span> (если только не запрещена 
			фиксация перехода через <span class="nmbr">0</span> разрядом
			<span class="nmbr">01</span>). При сбросе разряда <span class="nmbr">
			04</span> в <span class="nmbr">0</span> в счётчик переписывается константа 
			предустановки.</li>
			<li>Разряд <span class="nmbr">05</span> при установке в
			<span class="nmbr">1</span> снижает скорость счета в
			<span class="nmbr">4</span> раза (<b>режим умножения времени на
			<span class="nmbr">4</span></b>).</li>
			<li>Разряд <span class="nmbr">06</span> при установке в
			<span class="nmbr">1</span> снижает скорость счета в
			<span class="nmbr">16</span><sub>д</sub> раз (<b>режим умножения времени 
			на <span class="nmbr">16</span></b>). При одновременной установке в
			<span class="nmbr">1</span> обоих разрядов - <span class="nmbr">05</span> 
			и <span class="nmbr">06</span> - скорость счета снижается в
			<span class="nmbr">64</span><sub>д</sub> раза.</li>
			<li>Разряд <span class="nmbr">07</span> используется для индикации перехода 
			счётчика таймера через <span class="nmbr">0</span> (при установленном 
			режиме индикации, см. разряд <span class="nmbr">02</span>).</li>
		</ul>
		<p>Таким образом, возможно множество различных команд таймера и, соответственно, 
		вариантов его использования. Рассмотрим некоторые из них.</p>
		<p>Пусть в регистр управления записано число. устанавливающее в
		<span class="nmbr">1</span> разряд <span class="nmbr">04</span> (разрешён 
		счёт), а разряды <span class="nmbr">00</span>...<span class="nmbr">04</span> 
		установлены в <span class="nmbr">0</span>. В регистре предустановки имеется 
		некоторая константа. После занесения команды в регистр управления число 
		из регистра предустановки перепишется в счётчик и там начнётся вычитание 
		из него по единице в определённом темпе - обратный счёт времени. Как только 
		содержимое счётчика <span class="nmbr">177710</span> станет равно нулю, 
		в него снова будет переписано число из <span class="nmbr">177706</span>, 
		снова начнётся вычитание и т.д. Задавая в <span class="nmbr">177706</span> 
		различные числа, можно изменять <b>время цикла</b> таймера - это &laquo;<i>тонкая 
		регулировка</i>&raquo; хода наших часов. Но есть и грубая - в зависимости 
		от записанного в <span class="nmbr">177712</span> кода команды можно замедлять 
		его &laquo;<i>ход</i>&raquo; в <span class="nmbr">4</span>,
		<span class="nmbr">16</span> и <span class="nmbr">64</span> раза, для чего 
		достаточно задать равными <span class="nmbr">1</span> один или оба разряда 
		- <span class="nmbr">05</span> и <span class="nmbr">06</span> - &laquo;<i>множители 
		времени</i>&raquo;. Если разряд <span class="nmbr">03</span> равен
		<span class="nmbr">1</span>, то таймер выполнит только один цикл счета, 
		а если задать равным <span class="nmbr">1</span> разряд
		<span class="nmbr">02</span> и сбросить в <span class="nmbr">0</span> разряд
		<span class="nmbr">07</span>, то после перехода счётчика через
		<span class="nmbr">0</span> окончание цикла таймера будет отмечено единицей, 
		появившейся в разряде <span class="nmbr">07</span>. Если же установить в
		<span class="nmbr">1</span> разряд <span class="nmbr">01</span>, то, выполнив 
		один цикл счета от константы предустановки до <span class="nmbr">0</span>, 
		счётчик продолжит счёт &laquo;<i>вкруговую</i>&raquo; уже без учёта константы 
		предустановки.</p>
		<p>При работе таймера отсчитанный промежуток времени определяется умножением 
		разности показаний счётчика за истекшее время на те множители, в разряды 
		которых записаны единицы, и на <b>единичный период времени</b>. Этот период, 
		измеренный для нескольких БК-0010, в среднем равен <span class="nmbr">42</span>.<span class="nmbr">9</span>&nbsp;мкс 
		и может для разных экземпляров БК варьировать в пределах долей процента 
		(реже - нескольких процентов).</p>
		<p>Приведём пример. Пусть мы, запуская таймер, записали в регистр
		<span class="nmbr">177712</span> код <span class="nmbr">160</span> (единицы 
		в разрядах <span class="nmbr">04</span>, <span class="nmbr">05</span> и
		<span class="nmbr">06</span>) и получили разность показаний таймера за отсчитанный 
		промежуток времени, равную <span class="nmbr">154432</span> (<span class="nmbr">55578</span><sub>д</sub>). 
		Вычислим: <span class="nmbr">55578</span> * <span class="nmbr">4</span> 
		* <span class="nmbr">16</span> * <span class="nmbr">42</span>.<span class="nmbr">9</span> 
		= <span class="nmbr">152594956</span>.<span class="nmbr">8</span>&nbsp;мкс, 
		или примерно <span class="nmbr">152</span>.<span class="nmbr">6</span> с. 
		Естественно, чтобы отсчитать такую разность, необходимо иметь в регистре
		<span class="nmbr">177706</span> число, большее <span class="nmbr">154432</span>. 
		Приведём таблицу, которая позволит установить максимальное время, отсчитываемое 
		таймером в пределах одного цикла (см. табл. 1).</p>
		<p>Как можно понять из вышеизложенного, максимальный цикл задаётся числом
		<span class="nmbr">177777</span>, занесённым в регистр
		<span class="nmbr">177706</span> (вместо этого можно просто обнулить регистр
		<span class="nmbr">177706</span>, тогда после первого же вычитания произойдёт 
		заем в старшем разряде, и число станет равно <span class="nmbr">177777</span>).</p>
		<table id="mcmd" class="border3">
			<caption class="right">Таблица <span class="nmbr">1</span> </caption>
			<tr>
				<th>
				<p>Код</p>
				</th>
				<th>
				<p>Множитель</p>
				</th>
				<th>
				<p>Макс. время цикла, с</p>
				</th>
			</tr>
			<tr>
				<td>
				<p><span class="nmbr">20</span></p>
				</td>
				<td>
				<p>х <span class="nmbr">1</span><sub>д</sub></p>
				</td>
				<td>
				<p><span class="nmbr">2</span>,<span class="nmbr">812</span></p>
				</td>
			</tr>
			<tr>
				<td>
				<p><span class="nmbr">120</span></p>
				</td>
				<td>
				<p>х <span class="nmbr">4</span><sub>д</sub></p>
				</td>
				<td>
				<p><span class="nmbr">11</span>,<span class="nmbr">25</span></p>
				</td>
			</tr>
			<tr>
				<td>
				<p><span class="nmbr">60</span></p>
				</td>
				<td>
				<p>х <span class="nmbr">16</span><sub>д</sub></p>
				</td>
				<td>
				<p><span class="nmbr">45</span>,<span class="nmbr">00</span></p>
				</td>
			</tr>
			<tr>
				<td>
				<p><span class="nmbr">160</span></p>
				</td>
				<td>
				<p>х <span class="nmbr">64</span><sub>д</sub></p>
				</td>
				<td>
				<p><span class="nmbr">180</span>,<span class="nmbr">0</span></p>
				</td>
			</tr>
		</table>
		<p>Таким образом, таймер позволяет отсчитывать промежутки времени до
		<span class="nmbr">3</span> мин. А если надо больше? Тогда придётся написать 
		программу, которая могла бы фиксировать моменты перехода счётчика таймера 
		через ноль и подсчитывать число таких переходов. Цикл таймера при этом целесообразно 
		задать кратным какой-либо целой единице времени. Попробуем задать время 
		цикла равным <span class="nmbr">1</span> мин.</p>
		<p>Выберем константу предустановки. Ясно, что подходит лишь код
		<span class="nmbr">160</span> - все другие дают время цикла менее
		<span class="nmbr">1</span> мин. Подсчитаем константу. Известно, что
		<span class="nmbr">1</span> мин = <span class="nmbr">60</span> миллионов&nbsp;мкс. 
		Вычислим: (<span class="nmbr">60000000</span>/<span class="nmbr">64</span>)/<span class="nmbr">42</span>.<span class="nmbr">9</span> 
		= <span class="nmbr">21853</span> (округлённо). Переведём в восьмеричную 
		систему: <span class="nmbr">21853</span><sub>д</sub> =
		<span class="nmbr">52535</span>. Остаётся записать полученное число в
		<span class="nmbr">177706</span>, а код <span class="nmbr">160</span> - 
		в <span class="nmbr">177712</span>, и счётчик таймера будет выполнять цикл 
		длительностью ровно в <span class="nmbr">1</span> мин. Эксперименты с таймером 
		удобно проводить в МСД, используя для непрерывного чтения регистра
		<span class="nmbr">177710</span> команду &laquo;<span class="var">Ц</span>&raquo;.</p>
		<p>Для фиксации количества циклов таймера (моментов перехода счётчика через
		<span class="nmbr">0</span>) можно предложить разнообразные приёмы, например, 
		периодически опрашивать регистр <span class="nmbr">177710</span> (не менее 
		двух раз в течение цикла), использовать разряд индикации регистра
		<span class="nmbr">177712</span> или повторно запускать таймер в режим однократного 
		счета.</p>
		<p>Для чего ещё может понадобиться таймер, кроме отсчета времени? Это идеальный 
		генератор случайных чисел, если только обращения к нему производятся не 
		программой, а человеком (например, по нажатии клавиши). Такой генератор 
		будет давать не псевдослучайные, а истинно случайные числа, так как момент 
		нажатия оператором клавиши зависит от очень многих факторов, и угадать показание 
		таймера в этот момент невозможно. Если же к таймеру обращается программа, 
		последовательность будет далека от случайной, так как и таймер, и процессор 
		используют одну и ту же <b>тактовую частоту</b>, и поэтому процессы в них 
		коррелируют. (Генерация случайных чисел с помощью таймера использована в 
		известной игре для БК STREAP SHOW. - <em>Прим. ред.</em>)</p>
		<p>В заключение несколько замечаний. Системный таймер, будучи запущенным, 
		работает автономно от процессора, поэтому его счётчик отсчитывает время 
		независимо от того, стоит процессор или работает, есть в БК работающая программа 
		или нет. Таймер одинаково успешно работает в Бейсике и Фокале, с программами 
		в кодах, запущенными из МСД и монитора, и даже в тот момент, когда БК-0010 
		работает с магнитофоном. Но опрос регистра <span class="nmbr">177710</span> 
		(если для подсчёта числа циклов таймера используется этот способ) необходимо 
		проводить не реже, чем два раза за цикл таймера, иначе можно пропустить 
		переход через <span class="nmbr">0</span> и показания &laquo;<i>часов</i>&raquo; 
		исказятся. Таймер, в свою очередь. &laquo;<i>стоит</i>&raquo; ли он или &laquo;<i>идёт</i>&raquo;, 
		никак не влияет на работу программы пользователя, в том числе и на скорость 
		её исполнения. И наконец, одно не совсем приятное замечание. Поскольку таймер 
		по техническим условиям в состав БК-0010 не входит, то на некоторых экземплярах 
		его регистры могут быть неисправны, что не служит основанием для предъявления 
		претензий заводу-изготовителю. К счастью, эта неисправность, довольно распространённая 
		на БК-0010 <span class="nmbr">3</span>-<span class="nmbr">5</span> лет назад, 
		сейчас встречается всё реже, так что можно смело использовать таймер в своих 
		программных разработках.</p>
		<p>При выходе в Бейсик или Фокал таймер останавливается, поэтому запускать 
		его нужно в той среде, в которой он будет работать.</p>
		<p>(Ещё одной сферой применения таймера является организация на БК-0010 
		многопрограммного режима работы. Подробно о выполнении на БК нескольких 
		программ одновременно говорится в журнале &laquo;<i>Информатика и образование</i>&raquo;, 
		№<span class="nmbr">2</span> за <span class="nmbr">1992</span> г. - <em>
		Прим. ред.</em>)</p>
		</li>
		<li><b>Регистр порта ввода</b>-<b>вывода</b> (адрес <span class="nmbr">177714</span>). 
		Используются все <span class="nmbr">16</span> разрядов, доступные по записи 
		и чтению. Но этот регистр особенный, он как бы составлен из двух отдельных 
		регистров для ввода и вывода. Данные записываемые по адресу
		<span class="nmbr">177714</span>, передаются в регистр вывода, а читаются 
		из регистра ввода. Прочитать данные, записанные в регистр вывода, невозможно, 
		поэтому, если необходимо сохранить к ним доступ, нужно записать их не только 
		в порт, но и в специально зарезервированную для этого ячейку памяти (адрес
		<span class="nmbr">256</span>). Необходимо заметить, что порт вывода инвертирует 
		подаваемый на него код, т.е. при записи в него нулей на выходе будут единицы 
		и наоборот. То же самое можно сказать и о порте ввода: при подаче на него 
		от внешних устройств логических единиц программно читаются нули при подаче 
		нулей - единицы. При &laquo;<i>привязке</i>&raquo; к порту внешних устройств 
		нужно это учитывать.</li>
		<li><b>Регистр системных внешних устройств</b> (адрес <span class="nmbr">
		177716</span>). Используются все <span class="nmbr">16</span> разрядов, 
		но для разных целей, и поэтому они неравнозначны.
		<ul>
			<li><b>Разряды <span class="nmbr">0</span>...<span class="nmbr">3</span></b> 
			предназначены для внутренних нужд ЭВМ, служат для задания режима работы 
			процессора, доступны только по чтению.</li>
			<li><b>Разряды <span class="nmbr">4</span>...<span class="nmbr">7</span></b> 
			предназначены для управления системными внешними устройствами ЭВМ (магнитофоном, 
			телеграфным (ТЛГ) каналом, клавиатурой, встроенным динамиком), и на 
			них мы остановимся подробнее. Эти четыре разряда представляют собой 
			внутренний порт ввода-вывода и организованы совершенно так же, как только 
			что описанный внешний порт. Это как бы два отдельных регистра ввода 
			и вывода, поэтому запись и чтение информации по этим разрядам имеют 
			разное значение.</li>
		</ul>
		<p>Разряды регистра <b>ввода</b>:</p>
		<ul>
			<li><b>Разряд <span class="nmbr">04</span></b> служит для чтения информационного 
			сигнала с ТЛГ-линии.</li>
			<li><b>Разряд <span class="nmbr">05</span></b> - для чтения информации 
			с магнитофона.</li>
			<li><b>Разряд <span class="nmbr">06</span></b> - индикатор нажатия клавиши: 
			если нажата любая клавиша (кроме &laquo;<i>СТОП</i>&raquo; и регистровых &laquo;<i>НР</i>&raquo;, &laquo;<i>ПР</i>», &laquo;<i>СУ</i>&raquo;, &laquo;<i>СТР</i>&raquo;, &laquo;ЗАГЛ&raquo;), 
			то в этом разряде <span class="nmbr">0</span>, если ни одна из клавиш 
			не нажата - <span class="nmbr">1</span>. Широко используется в программах 
			как в кодах, так и на языках высокого уровня для индикации нажатия клавиш, 
			ввода информации &laquo;<i>на ходу</i>&raquo; (без останова программы), 
			организации циклов автоповтора и т.п. В самой ЭВМ используется для организации 
			режима &laquo;<i>повтор</i>&raquo;.</li>
			<li><b>Разряд <span class="nmbr">07</span></b> служит для чтения сигнала 
			готовности с ТЛГ-линии. Этот разряд, как и <span class="nmbr">04</span>, 
			может использоваться как по прямому назначению, так и для других целей, 
			это дополнительный канал связи ЭВМ с внешними устройствами. Для задействования 
			ТЛГ-ввода/вывода на плате ЭВМ необходимо установить перемычки (на БК-0010. 
			выпускаемых некоторыми предприятиями, перемычки установлены, а на других 
			- нет, так что этот вопрос нужно решать применительно к конкретному 
			компьютеру).</li>
		</ul>
		<p>Разряды регистра <b>вывода</b>:</p>
		<ul>
			<li><b>Разряд <span class="nmbr">04</span></b> служит для передачи информации 
			на ТЛГ-линию, его исходное состояние - <span class="nmbr">1</span>.</li>
			<li><b>Разряд <span class="nmbr">05</span></b> - для передачи сигнала 
			на магнитофон (при записи) или сигнала готовности на ТЛГ-линию. поэтому 
			одновременный обмен информацией с магнитофоном и ТЛГ- линией невозможен. 
			Исходное состояние - <span class="nmbr">0</span>.</li>
			<li><b>Разряд <span class="nmbr">06</span></b> - для передачи информации 
			на магнитофон (при записи) и сигнала на пьезодинамик ЭВМ (при записи 
			на МЛ и нажатии клавиши). Очень широко используется в программах в кодах 
			и на Бейсике для создания звуковых эффектов если с определённой периодичностью 
			записывать в этот разряд чередующиеся <span class="nmbr">0</span> и
			<span class="nmbr">1</span>. мы услышим звук, воспроизводимый как встроенным 
			пьезодинамиком, так и подключённым к выходу БК &laquo;МАГНИТОФОН&raquo; 
			любым усилителем низкой частоты. Исходное состояние -
			<span class="nmbr">0</span>.</li>
		</ul>
		<p>Здесь необходимо одно пояснение: почему для выдачи информации на магнитофон 
		используются два разряда - <span class="nmbr">05</span> и
		<span class="nmbr">06</span>. Дело в том, что в БК-0010 для записи на магнитофон 
		был принят двухуровневый сигнал. При записи &laquo;<i>нуля</i>&raquo; сигнал 
		идёт с обоих разрядов и имеет большую амплитуду, а при записи &laquo;<i>единицы</i>&raquo; 
		- только с разряда <span class="nmbr">06</span> и амплитуда его меньше. 
		Это сделано для коррекции частотной характеристики тракта записи магнитофона 
		и получения более качественной записи информации. Но в БК-0010 поздних выпусков 
		от этого отказались, сигнал на магнитофон с разряда <span class="nmbr">05</span> 
		уже не передаётся, в схему компьютера внесены соответствующие изменения, 
		но программа обслуживания выхода на магнитофон осталась той же и по-прежнему 
		обслуживает оба разряда. Эти изменения могут отсутствовать и в БК-0010, 
		выпускаемых некоторыми из предприятий.</p>
		<ul>
			<li><b>Разряд <span class="nmbr">07</span></b> служит для дистанционного 
			управления двигателем магнитофона: при записи в него нуля двигатель 
			включается, а единицы - отключается. Управление двигателем производится 
			через установленное на плате БК электромагнитное реле.</li>
			<li><b>Разряды <span class="nmbr">08</span>...<span class="nmbr">15</span></b> 
			предназначены для задания адреса запуска системы и доступны только по 
			чтению. Адрес запуска в БК-0010 принят равным <span class="nmbr">100000</span>, 
			он и задан в старшем байте регистра <span class="nmbr">177716</span>, 
			причём его младший байт принимается равным <span class="nmbr">0</span>.</li>
		</ul>
		</li>
	</ol>
	<h3><a name="toc_14"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Как известными вам способами проследить за изменениями в регистре
		<span class="nmbr">177662</span> при нажатии разных клавиш? Проверьте это 
		экспериментально.
		<ul id="ctrla">
			<li>
			<p>Дайте в МСД директиву <span class="nmbr">177662</span><span class="var">АЦ</span>, 
			затем нажимайте различные клавиши и наблюдайте на экране их коды.</p>
			</li>
		</ul>
		</li>
		<li>Записывая в регистр <span class="nmbr">177664</span> различные числа, 
		проследите за изменениями положения изображения на экране. Желательно предварительно 
		заполнить экран каким-нибудь текстом, чтобы иметь ориентиры помимо служебной 
		строки.</li>
		<li>Придумайте и осуществите на своём БК проверку работоспособности системного 
		таймера.
		<ul id="ctrla">
			<li>
			<p>Дайте в МСД директивы: <span class="nmbr">177706</span><span class="var">А</span><span class="nmbr">0</span><span class="var">,,</span><span class="nmbr">160</span><span class="var">-Ц</span> 
			- при этом будет циклически читаться регистр счётчика таймера. Отметьте 
			по секундомеру время между двумя моментами перехода таймера через ноль, 
			этот интервал должен быть с точностью до нескольких секунд равен
			<span class="nmbr">3</span> мин, в противном случае таймер на вашем 
			БК неисправен. Приостановить вывод информации на экран в МСД можно командой 
			СУ/@, повторный пуск - любая клавиша или ещё раз СУ/@. Обратите внимание 
			на то, что при прерывании вывода на экран таймер продолжает работать, 
			после возобновления вывода его показания уже другие.</p>
			</li>
		</ul>
		</li>
		<li>Можно ли прочитать информацию, занесённую в МСД по адресу
		<span class="nmbr">177714</span>? Придумайте, как всё-таки это сделать. 
		Всё необходимое имеется в комплекте, прилагаемом к БК-0010.
		<ul id="ctrla">
			<li>
			<p>Программно прочитать регистр вывода <span class="nmbr">177714</span> 
			нельзя, но можно подать информацию с него на регистр ввода, для чего 
			служит входящий в комплект ЭВМ &laquo;<i>блок нагрузок</i>&raquo;. Подключив 
			этот блок к порту ввода-вывода, можно читать из регистра
			<span class="nmbr">177714</span> информацию, записываемую по тому же 
			адресу.</p>
			</li>
		</ul>
		</li>
		<li>Как проверить, не разбирая компьютер, подключён ли на вашей ЭВМ разряд
		<span class="nmbr">05</span> регистра <span class="nmbr">177716</span> к 
		выходу на магнитофон?
		<ul id="ctrla">
			<li>
			<p>Если имеется электронно-лучевой осциллограф, можно посмотреть форму 
			импульсов на выходе &laquo;<i>МГ</i>&raquo; БК при записи информации 
			на магнитофон. Если разряд задействован, импульсы будут двух разных 
			амплитуд, если нет - только одной.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_15"></a>Как работает ЭВМ</h2>
	<p>Не пугайтесь, автор не собирается рассказывать вам о триггерах, логических 
	элементах, регистрах сдвига, счётчиках, источниках питания и прочей электронике, 
	это не входит в его задачу. Речь пойдёт о том, как компьютер работает с точки 
	зрения программиста, для понимания дальнейшего изложения это необходимо.</p>
	<p>Как уже было сказано, в памяти ЭВМ хранится программа - последовательность 
	двоичных кодов. При её запуске процессор запоминает адрес начала программы в 
	специальном регистре, называемом <b>счётчиком команд</b>, и читает первое слово 
	по этому адресу, причём счётчик команд сразу же увеличивает своё содержимое 
	на <span class="nmbr">2</span>. В зависимости от того, какая команда прочитана, 
	процессор может или сразу выполнить её (если в ней заключены все необходимые 
	данные), или заняться &laquo;<i>добыванием</i>&raquo; указанных в команде данных. 
	Последние либо могут располагаться где-то в памяти (как уже говорилось, для 
	программы и данных используется одно и то же ОЗУ), либо входят в состав самой 
	команды, но не в первое её слово. Команды процессора БК-0010 могут иметь длину 
	от одного до трёх слов, причём первое из них всегда код самой команды, а два 
	последующих, если они есть, - данные (это могут быть как сами числа для выполнения 
	над ними каких-то операций, так и указания на адреса, по которым они расположены). 
	Если команда состоит более чем из одного слова, содержимое счётчика команд в 
	процессе её выполнения увеличивается не на <span class="nmbr">2</span>, а на
	<span class="nmbr">4</span> или на <span class="nmbr">6</span>. Таким образом, 
	счётчик команд всегда содержит адрес следующей команды программы.</p>
	<p>После окончания исполнения очередной команды процессор опять читает слово 
	по адресу, указанному в счётчике команд, выполняет следующую команду и т.д. 
	Ясно, что таким образом может исполняться так называемая <b>линейная последовательность</b>, 
	когда команды следуют строго одна за другой. Но из теории программирования известно, 
	что линейная последовательность не является достаточной для решения любых задач, 
	необходимы ещё по крайней мере две структуры - <b>условие</b> и <b>цикл</b>. 
	Тот, кто занимался программированием хотя бы на одном из языков, знает, что 
	исполнение этих структур связано с изменением естественной последовательности 
	команд. В ЭВМ это решается очень просто - достаточно прибавить к счётчику команд 
	какое-либо число (положительное или отрицательное), и процессор послушно начнёт 
	выполнять команды уже в другом месте программы, в соответствии с адресом, указанным 
	счётчиком.</p>
	<p>Как же &laquo;<i>устроена</i>&raquo; любая машинная команда? Не вникая в 
	подробности, можно сказать, что в её <span class="nmbr">16</span> разрядах (если 
	команда состоит из одного слова) есть код самой команды и указание на так называемые
	<b>операнды</b>, т.е. числа, с которыми нужно иметь дело. Если эти числа входят 
	в состав команды, то, как уже говорилось, они содержатся в её втором или третьем 
	слове. Кроме того, команда содержит ещё и указание на то, нужно ли оперировать 
	со словом или с байтом. Все эти сведения располагаются в специально отведённых 
	для этого разрядах первого слова команды, так называемых <b>полях</b>. Этим 
	кратким описанием мы пока и ограничимся.</p>
	<p>А что представляют собой числа, с которыми оперирует ЭВМ?</p>
	<h3><a name="toc_16"></a>Дополнительный код</h3>
	<p>ЭВМ, как легко догадаться, оперирует с двоичными числами. Положительные двоично-восьмеричные 
	числа от <span class="nmbr">0</span> до <span class="nmbr">7</span> мы уже рассматривали. 
	Но это ещё не всё. Для полноценной арифметики нужны и отрицательные числа, а 
	они изображаются в ЭВМ не совсем обычным образом. Чтобы понять, как это делается, 
	произведём несколько действий с двоичными <span class="nmbr">4</span>-разрядными 
	числами. Сначала сложение:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">0001</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">0011</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">3</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">0100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
		</tr>
	</table>
	<p>А теперь - вычитание:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">0001</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>- <span class="nmbr">0011</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>- <span class="nmbr">3</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1110</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>- <span class="nmbr">2</span></p>
			</td>
		</tr>
	</table>
	<p>Вам что-нибудь понятно? Почему у нас получилось <span class="nmbr">1110</span>, 
	и почему это -<span class="nmbr">2</span>? При вычитании нам потребовалось сделать &laquo;<i>заём</i>&raquo; 
	в старших разрядах уменьшаемого, а поскольку &laquo;<i>цена</i>&raquo; каждого 
	разряда двоичного числа равна двойке, то у нас и получилось то, что получилось. 
	При этом мы считали, что число у нас как бы &laquo;<i>неограниченной</i>&raquo; 
	разрядности, и мы &laquo;<i>заняли</i>&raquo; единицу в следующем, пятом разряде, 
	который не изображён.</p>
	<p>Теперь - внимание! Старший разряд двоичного числа со знаком (в данном случае 
	- четвёртый) называется <b>знаковым</b>. Если число положительное, он равен
	<span class="nmbr">0</span>. а если отрицательное - <span class="nmbr">1</span>. 
	Значит, раз у нас число <span class="nmbr">1110</span> и старший разряд
	<span class="nmbr">1</span>, то число это - отрицательное. А как понимать остальные
	<span class="nmbr">3</span> разряда - <span class="nmbr">110</span>? Почему 
	это <span class="nmbr">2</span>? Вот это и есть <b>дополнительный код</b>. Какой 
	в нём смысл? Попробуем выполнить ещё два действия:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">1110</span></p>
			</td>
			<td width="40">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p>-<span class="nmbr">2</span></p>
			</td>
			<td width="40">
			<p>&nbsp;</p>
			</td>
			<td width="60">
			<p><span class="nmbr">0101</span></p>
			</td>
			<td width="40">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">5</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">1110</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ -<span class="nmbr">2</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">1110</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ -<span class="nmbr">2</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>-<span class="nmbr">4</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">0011</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
		</tr>
	</table>
	<p>А правда ли, что мы получили в первом случае -<span class="nmbr">4</span>? 
	Проверим:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">0000</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>- <span class="nmbr">0100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>- <span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>-<span class="nmbr">4</span></p>
			</td>
		</tr>
	</table>
	<p>Результат очевиден - <span class="nmbr">1100</span> это действительно -
	<span class="nmbr">4</span>. Так вот в чём смысл дополнительного кода: мы можем 
	не задумываться о знаках при операциях с положительными или отрицательными числами, 
	они получаются автоматически! Очевидно, что во втором сложении результат тоже 
	верен, <span class="nmbr">0011</span> - это <span class="nmbr">3</span>. Теперь 
	вам ясно, как получается дополнительный код? Чтобы получить отрицательное число 
	в дополнительном коде, нужно вычесть соответствующее по абсолютной величине 
	положительное число из нуля. Потому код и называется дополнительным, что отрицательное 
	и положительное числа, равные по абсолютной величине, <b>дополняют</b> друг 
	друга до нуля, или, как говорят, <b>до переноса</b> в разряд за пределы числа. 
	Есть простое правило получения отрицательного числа, которое позволяет делать 
	перевод в дополнительный код в уме. Если вам нужно получить отрицательное число, 
	возьмите положительное, равное ему по абсолютной величине, замените в нём все 
	единицы нулями, а нули - единицами и прибавьте единицу. Попробуем. Берём
	<span class="nmbr">4</span>: <span class="nmbr">0100</span>. Заменяем:
	<span class="nmbr">1011</span>. Прибавляем единицу: <span class="nmbr">1011</span>+<span class="nmbr">0001</span>=<span class="nmbr">1100</span>. 
	Получилось -<span class="nmbr">4</span> - правило работает. Теперь очень легко 
	получить любое отрицательное число в дополнительном коде. Например, возьмём 
	число <span class="nmbr">01101100</span> (<span class="nmbr">154</span>). Заменим 
	нули и единицы (это называется <b>поразрядным инвертированием</b>):</p>
	<p><span class="nmbr">10010011</span>. Прибавим единицу: <span class="nmbr">
	10010100</span>. Это минус <span class="nmbr">154</span>. Можете проверить:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="80">
			<p><span class="nmbr">00000000</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">000</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>- <span class="nmbr">01101100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>- <span class="nmbr">154</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">10010100</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>-<span class="nmbr">154</span></p>
			</td>
		</tr>
	</table>
	<p>Если же нам нужно перевести число из дополнительного кода обратно, делаем &laquo;<i>всё 
	наоборот</i>&raquo;: вычитаем единицу и поразрядно инвертируем полученное двоичное 
	число. Проверьте сами, и получите абсолютную величину отрицательного числа. 
	И так - для чисел любой разрядности. А теперь попробуем выполнить ещё одно действие:</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">0110</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">6</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>+<span class="nmbr"> 0011</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">3</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1001</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>-<span class="nmbr">7</span></p>
			</td>
		</tr>
	</table>
	<p>Вот это фокус! Дополнительный код почему-то &laquo;<i>отказал</i>&raquo;! 
	А дело в том, что произошло так называемое <b>переполнение</b>, перенос единицы 
	в знаковый разряд. То есть просто-напросто заданная разрядность оказалась мала 
	для сложения двух предложенных чисел. Всё станет на место, если мы добавим ещё 
	один разряд слева (и будем теперь его считать знаковым):</p>
	<table id="rigt" class="border2">
		<tr>
			<td width="60">
			<p><span class="nmbr">00110</span></p>
			</td>
			<td width="60">
			<p>&nbsp;</p>
			</td>
			<td width="40">
			<p><span class="nmbr">6</span></p>
			</td>
		</tr>
		<tr>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">00011</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td class="cs__b_s">
			<p>+ <span class="nmbr">3</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">01001</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p><span class="nmbr">9</span></p>
			</td>
		</tr>
	</table>
	<p>Но наша ЭВМ оперирует не любыми числами, а только <span class="nmbr">8</span>- 
	и <span class="nmbr">16</span>-разрядными, т.е. байтами и словами. Поэтому и 
	знаковый разряд здесь фиксирован - это бит <span class="nmbr">07</span> для 
	байта и <span class="nmbr">15</span> для слова. Как же быть при сложении на 
	ЭВМ, если у нас фиксированный формат числа и добавить разряд мы не можем? Это 
	предусмотрено - компьютер отмечает переполнение и даёт о нём знать специальным &laquo;<i>флагом</i>&raquo; 
	результата, о котором мы поговорим чуть позже. Обнаружив, что этот &laquo;<i>флаг</i>&raquo; 
	установлен, мы видим, что результат в дополнительном коде неверен и нуждается 
	в коррекции.</p>
	<p>Есть в ЭВМ и ещё один формат чисел - так называемые <b>числа без знака</b>. 
	При этом мы включаем знаковый разряд в состав самого числа, которое в этом случае 
	может быть только положительным. Ясно, что при этом число <span class="nmbr">
	1001</span> - это <span class="nmbr">9</span>. Зачем ещё и такое представление 
	чисел? Очень просто - число при этом может быть больше на один разряд. Если 
	для выражения числа <span class="nmbr">9</span> в дополнительном коде нам потребовалось
	<span class="nmbr">5</span> разрядов, то для числа без знака - только
	<span class="nmbr">4</span>. Если в один байт можно записать числа в дополнительном 
	коде от -<span class="nmbr">128 </span>до +<span class="nmbr">127</span>, то 
	без знака - от <span class="nmbr">0</span> до +<span class="nmbr">255</span>. 
	А нередко знак числа нас вовсе не интересует, поэтому не нужен и дополнительный 
	код. Например, если надо сравнить коды символов, то при чём тут знак?</p>
	<p>Иное дело - арифметика. Тут ради знака приходится жертвовать разрядностью 
	числе. Но самое главное, что обычный двоичный код и код дополнительный - это, 
	по сути, одно и то же, и мы в принципе можем оперировать числами независимо 
	от того, в дополнительном коде они или нет. А если нам вдруг нужен знак числа, 
	посмотрим на его старший разряд - и всё.</p>
	<p>Попробуйте поупражняться в сложении и вычитании двоичных чисел со знаком 
	и без него, и вы поймёте, что правила всё время одни и те же. И ещё вы заметите 
	такую деталь: вместо того чтобы вычесть число из другого, можно прибавить к 
	первому числу второе в дополнительном коде, ведь это есть отрицательное число! 
	Вот оно, главное преимущество дополнительного кода, вот зачем он введён на ЭВМ: 
	мы можем не иметь отдельного устройства - &laquo;<i>вычитателя</i>&raquo;, достаточно 
	только сумматора и перевода вычитаемого в дополнительный код. Это намного упрощает 
	устройство процессора и увеличивает скорость вычислений.</p>
	<p>А может ли ЭВМ так же просто умножать и делить? Да. Попробуем &laquo;<i>сдвинуть</i>&raquo; 
	какое- либо число влево:</p>
	<p><span class="nmbr">00010</span> сдвигаем влево: <span class="nmbr">00100</span>; 
	ещё раз: <span class="nmbr">01000</span></p>
	<p>У нас было число <span class="nmbr">2</span>. получили число
	<span class="nmbr">4</span>, а затем <span class="nmbr">8</span>. Но ведь это 
	умножение на <span class="nmbr">2</span>! Да, так называемый <b>арифметический 
	сдвиг влево</b> есть умножение на <span class="nmbr">2</span>. При этом мы считаем, 
	что на место младших разрядов числа пишется <span class="nmbr">0</span>. Совершенно 
	очевидно, что, сдвигая такое число вправо, по тому же правилу мы получим деление 
	на <span class="nmbr">2</span>. А если число со знаком минус? Попробуем его 
	умножить на <span class="nmbr">2</span> тем же способом:</p>
	<p><span class="nmbr">10011</span> (-<span class="nmbr">13</span><sub>д</sub>) 
	сдвинем влево: <span class="nmbr">00110</span></p>
	<p>Получили... +<span class="nmbr">6</span>! Разве это правильно? Мы опять столкнулись 
	с тем же явлением - не хватает разрядности. Но на этот раз произошло не переполнение, 
	а <b>перенос</b>, т.е. выход за пределы числа. В ЭВМ на этот случай тоже есть &laquo;<i>флаг</i>&raquo;, 
	который отметит, что результат ошибочный и нуждается в коррекции. Ну а как с 
	делением чисел со знаком на <span class="nmbr">2</span>? Тут всё в порядке, 
	но... правило сдвига вправо было пока неполным: сдвигая число вправо, мы должны 
	не вписывать слева нули, а <b>расширять знаковый разряд</b>, т.е. переписывать 
	его значение в соседний справа бит: </p>
	<p><span class="nmbr">10011</span> (-<span class="nmbr">13</span><sub>д</sub>) 
	сдвинем вправо: <span class="nmbr">11001</span> (-<span class="nmbr">7</span>)</p>
	<p>Всё верно, ведь результат округлённый! Причём заметим, что округление происходит 
	из-за отбрасывания младшего разряда. Но что, если нам нельзя округлять число? 
	Ничего страшного, ведь у нас снова произошёл перенос за пределы слова и &laquo;<i>флаг</i>&raquo; 
	переноса отметит, что результат нуждается в коррекции.</p>
	<p>Итак, мы в общих чертах разобрались, как ЭВМ выполняет арифметические действия. 
	Нетрудно теперь придумать, как можно умножить или разделить на число, не кратное 
	двум (вспомните, что умножение - это не что иное, как многократное сложение, 
	деление же - многократное вычитание, а также вспомните, как умножают &laquo;<i>в 
	столбик</i>&raquo; и делят &laquo;<i>уголком</i>&raquo;). Не будем разбирать 
	соответствующие примеры, так как это заняло бы слишком много места, а пойдём 
	дальше в изучении архитектуры нашей ЭВМ.</p>
	<h3><a name="toc_17"></a>Контрольные вопросы и задания:</h3>
	<ol id="ctrlq">
		<li>Как умножить двоичное число на <span class="nmbr">128</span>?
		<ul id="ctrla">
			<li>
			<p>Нужно выполнить <span class="nmbr">7</span> арифметических сдвигов 
			влево.</p>
			</li>
		</ul>
		</li>
		<li>Придумайте правило, которое позволило бы умножать двоичные числа на
		<span class="nmbr">3</span>, и сформулируйте его словами.
		<ul id="ctrla">
			<li>
			<p>Чтобы умножить двоичное число на <span class="nmbr">3</span>, нужно 
			выполнить арифметический сдвиг влево и прибавить исходное число.</p>
			</li>
		</ul>
		</li>
		<li>Пусть нам нужно сделать вычисления по формуле: <span class="var">A</span>/<span class="nmbr">8</span>+<span class="var">B</span>/<span class="nmbr">4</span>+<span class="var">C</span>/<span class="nmbr">2</span>=<span class="var">D</span>. 
		При предварительном делении во всех числах может получиться округление за 
		счёт потери младших разрядов и точность результата снизится. Как можно свести 
		потери точности к минимуму?
		<ul id="ctrla">
			<li>
			<p>Надо привести все дроби к общему знаменателю, получим: (<span class="var">A</span>+<span class="nmbr">2</span>*<span class="var">B</span>+<span class="nmbr">4</span>*<span class="var">C</span>)/<span class="nmbr">8</span>=<span class="var">D</span>. 
			При таком порядке вычислений деление будет выполняться только один раз 
			и возможная потеря точности от округления будет минимальной. Но в конкретной 
			программе необходимо, конечно, учитывать возможность переполнения при 
			последовательных умножениях.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_18"></a>Центральный процессор</h2>
	<p>Теперь пришло время более подробно рассмотреть главную часть ЭВМ - центральный 
	процессор (ЦП). Как уже говорилось, ЦП - это универсальное логическое устройство 
	для операций с числами. Но это не всё. Процессор имеет свою собственную память, 
	так называемые <b>регистры общего назначения</b> (РОН). Этих регистров
	<span class="nmbr">8</span>, и они, как и ячейки памяти и системные регистры, 
	имеют по <span class="nmbr">16</span> разрядов. В них также могут быть записаны 
	или оттуда прочитаны числа. Но в остальном регистры ЦП существенно отличаются 
	от ячеек памяти. Прежде всего, они не входят в общее адресное пространство ЭВМ 
	и обращения к ним особые, с применением специальных команд. Затем операции с 
	числами в регистрах ЦП выполняются намного быстрее, чем в памяти. И наконец, 
	целый ряд команд ЭВМ может быть выполнен только с использованием регистров, 
	и никак иначе. Таким образом, это как бы отдельная специфическая память ЭВМ 
	- &laquo;<i>сверхоперативная память</i>&raquo;, имеющая большие преимущества 
	перед ОЗУ. Жаль только, что этих регистров так мало.</p>
	<p>Название &laquo;<i>регистры общего назначения</i>&raquo; не совсем точно. 
	Действительно, шесть из них совершенно равноправны и вполне могут быть так названы. 
	Они применяются для любых целей, их &laquo;<i>имена</i>&raquo; -
	<span class="regn">R0</span>, <span class="regn">R1</span>,
	<span class="regn">R2</span>, <span class="regn">R3</span>,
	<span class="regn">R4</span>, <span class="regn">R5</span>. Но два других регистра 
	- специальные, их использование наравне с остальными крайне ограничено или исключено 
	вовсе. Что это за регистры?</p>
	<p><span class="regn">R6</span>, или (как его обозначают на языке ассемблера)
	<span class="regn">SP</span> - Stack Pointer, <b>указатель стека</b>. Мы уже 
	говорили, что <b>стек</b> - это специально выделенная область памяти.
	<span class="regn">R6</span>, или <span class="regn">SP</span>, всегда содержит 
	адрес её начала, или. как говорят, <b>вершины стека</b>. Пользуясь этим регистром, 
	удобно записывать в стек или извлекать из него информацию, причём адрес вершины 
	при этом автоматически может меняться, всё время указывая на ту ячейку памяти, 
	с которой в данный момент мы работаем. Но главное назначение стека - не столько 
	обслуживать нужды программиста, хотя и это немаловажно, сколько временно сохранять 
	данные, необходимые самой ЭВМ, например, при переходе к подпрограмме или при 
	обработке <b>прерывания</b>.</p>
	<p><span class="regn">R7</span>, или (на языке ассемблера)
	<span class="regn">PC</span> - Program Counter, <b>программный счётчик</b>, 
	или счётчик команд. Мы уже говорили, что он всегда указывает адрес <b>очередной 
	команды</b> и тем самым позволяет процессору исполнять программу в правильной 
	последовательности, а меняя его содержимое, можно изменять естественный порядок 
	исполнения команд программы. По сути, смысл его тот же, что и у
	<span class="regn">SP</span>, - он указывает определённый адрес памяти, но в 
	отличие от стека это не память данных, а память программ.</p>
	<p>Есть в нашей ЭВМ и ещё один регистр, уже совсем специфический, он носит сокращённое 
	название <span class="regn">PS</span>, от слов Processor Status (или
	<span class="regn">PSW</span>, PS Word). Иногда его называют также <b>словом 
	состояния процессора</b> (ССП). Важность этого регистра трудно переоценить - 
	только с его помощью ЭВМ может выполнять, например, такие необходимые действия, 
	как проверка условий и условные переходы, а также делать многое другое, влияющее 
	на вычислительный процесс. Поэтому рассмотрим его подробнее.</p>
	<p>В БК-0010 используется только младший байт <span class="regn">PS</span>. 
	Все его разряды доступны по записи и чтению, хотя запись в некоторые из них 
	возможна только с помощью специальных команд или приёмов, а чтение может происходить 
	вовсе не обязательно в том виде, к которому мы привыкли: ЦП сам, с помощью специальных 
	команд читает эти разряды и использует их.</p>
	<p>Что же это за разряды? Вначале идут четыре &laquo;<i>флага</i>&raquo;, или 
	разряда <b>условий</b>. Они принимают то или иное значение в зависимости от 
	результата исполнения процессором очередной команды. Исходное состояние этих 
	разрядов, если указанные ниже условия <b>не выполняются</b>, - нули:</p>
	<ul>
		<li><span class="nmbr">00</span> (разряд <span class="symb">С</span>) -
		<b>перенос</b>. Устанавливается в <span class="nmbr">1</span>, если в результате 
		исполнения команды возник перенос за пределы слова или байта. Тут. очевидно, 
		надо оговориться, что возможен перенос только единицы ноль на результат 
		не влияет. Правильнее было бы сказать, что С-разряд <b>принимает значение 
		разряда переноса</b>;</li>
		<li><span class="nmbr">01</span> (разряд <span class="symb">V</span>) -
		<b>переполнение</b>. Устанавливается в <span class="nmbr">1</span>. если 
		в результате исполнения команды имело место переполнение, т.е. перенос в 
		знаковый разряд слова или байта;</li>
		<li><span class="nmbr">02</span> (разряд <span class="symb">Z</span>) -
		<b>ноль</b>. Устанавливается в <span class="nmbr">1</span>, если результатом 
		исполнения команды является нулевое содержимое слова или байта;</li>
		<li><span class="nmbr">03</span> (разряд <span class="symb">N</span>) -
		<b>отрицательность</b>. Устанавливается в <span class="nmbr">1</span>. если 
		результатом исполнения команды является отрицательное число в слове или 
		в байте.</li>
	</ul>
	<p>Используя содержимое этих разрядов, можно организовать так называемое <b>
	ветвление</b> программы, т.е. переходы по условию, или что то же самое, по результатам 
	исполнения команды. Помимо того, что эти разряды устанавливаются в
	<span class="nmbr">0</span> или <span class="nmbr">1</span> автоматически по 
	результатам исполнения каждой команды, существуют и специальные операторы для 
	их &laquo;<i>ручной</i>&raquo; установки.</p>
	<p>Следующий разряд - <span class="nmbr">04</span>, или <b>
	<span class="symb">T</span>-разряд</b>. Он имеет особое назначение. Если содержимое
	<span class="symb">T</span>-разряда равно <span class="nmbr">1</span>, то программа 
	приостанавливается каждый раз после выполнения очередной команды (происходит 
	так называемое <b>прерывание по <span class="symb">T</span>-разряду</b>). Этот 
	режим процессора широко используется в специальных программах-отладчиках, позволяющих 
	исполнять программы по одной команде с целью их отладки (выполнять <b>трассировку</b>). 
	Просто так записать в <span class="symb">T</span>-разряд единицу нельзя, для 
	этого существует специальный приём, с которым мы познакомимся позже.</p>
	<p>И наконец, последние три разряда (<span class="nmbr">05</span>,
	<span class="nmbr">06</span>, <span class="nmbr">07</span>) - это так называемые 
	разряды <b>приоритета процессора</b>. Что это такое? В процессе работы ЭВМ ЦП 
	постоянно обрабатывает информацию, или, проще говоря, решает задачи. Но ЭВМ 
	работает и с внешними устройствами, например с клавиатурой. Можно организовать 
	работу с клавиатурой двояко. По первому способу ЦП после выполнения определённого 
	числа команд прерывает решение задачи и обращается к клавиатуре, опрашивая её. 
	Если ни одна клавиша не нажата, вычисления будут продолжены, затем снова следует 
	опрос клавиатуры и т.д. Этот способ довольно нерационален - независимо от того, 
	нажата ли клавиша. ЦП вынужден всё время &laquo;<i>отвлекаться</i>&raquo; и 
	тратить время на опрос клавиатуры. А если учесть, что на нажатие клавиши ЭВМ 
	должна реагировать мгновенно (чтобы не создавать неудобств в работе), то понятно, 
	что все клавиши должны опрашиваться никак не реже, чем <span class="nmbr">100</span> 
	или даже <span class="nmbr">1000</span> раз в секунду.</p>
	<p>Второй способ куда лучше - пусть ЦП решает задачу, а если будет нажата клавиша, 
	то он получит так называемый <b>запрос на прерывание</b>. Это специальный сигнал, 
	сообщающий процессору, что с какого-то из внешних устройств поступила порция 
	информации и оно ждёт, чтобы ЦП отреагировал. ЦП прервёт решение задачи, <b>
	обработает прерывание</b> и продолжит вычисления.</p>
	<p>Но постойте! Есть ведь такие задачи, когда ЦП никак не может &laquo;<i>отвлечься</i>&raquo;, 
	например работа с магнитофоном. Лента ведь не будет стоять и ждать, пока ЦП 
	обработает прерывание... Вот для этого и служит приоритет. Если приоритет, установленный 
	на данный момент для ЦП (как говорят, <b>приоритет текущей задачи</b>), ниже, 
	чем установленный <b>приоритет запроса на прерывание</b>, то ЦП прервёт работу 
	и обработает прерывание. Если же приоритет текущей задачи равен или выше приоритета 
	запроса, то ЦП сначала закончит вычисления, а уже потом обработает прерывание. 
	Сразу поясним, что приоритет запросов на прерывание от внешних устройств (у 
	БК-0010 их, по сути, может быть всего два - клавиатура и внешний таймер) установлен 
	для данной конфигурации ЭВМ раз и навсегда А вот приоритет ЦП может меняться 
	и определяется содержимым указанных трёх разрядов <span class="regn">PS</span>.</p>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">2</span> </caption>
		<tr>
			<th>
			<p>Источник прерывания</p>
			</th>
			<th>
			<p>Приоритет</p>
			</th>
			<th>
			<p>Адрес вектора</p>
			</th>
			<th>
			<p>Использование источника</p>
			</th>
		</tr>
		<tr>
			<td>
			<p>Зависание</p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Ошибочный машинный код</p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="symb">Т</span>-бит</p>
			</td>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
			<td>
			<p><span class="nmbr">14</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Сбой питания</p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">24</span></p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Радиальное стат. (клавиша &laquo;<i>СТОП</i>&raquo;)</p>
			</td>
			<td>
			<p><span class="nmbr">5</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
			<td>
			<p>Прерывание программы пользователя с пульта оператора</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Радиальное дин.</p>
			</td>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p><span class="nmbr">100</span></p>
			</td>
			<td>
			<p>Прерывание по требованию устройства</p>
			</td>
		</tr>
	</table>
	<p><b>На самом деле, в колонке приоритет тут и в ремонтной документации БК приведены 
	порядковые номера прерываний, а каков приоритет на самом деле, остаётся загадкой 
	до сих пор.</b></p>
	<p>Сколько может быть задано различных уровней приоритета процессора? Очевидно, 
	восемь, ведь в три двоичных разряда можно записать восемь различных комбинаций. 
	Минимальный приоритет, когда прервать работу процессора может любое устройство, 
	- <span class="nmbr">000</span>, максимальный, когда работа процессора непрерываема 
	ничем, кроме клавиши &laquo;<i>СТОП</i>&raquo; (это - &laquo;<i>внеприоритетное</i>&raquo; 
	внешнее устройство), - <span class="nmbr">111</span>.</p>
	<p>Для справки приведём таблицу, содержащую сведения о прерываниях, их приоритетах 
	и использовании. Эта таблица взята из внутризаводской &laquo;<i>ремонтной документации</i>&raquo; 
	по БК-0010 - см. табл. <span class="nmbr">2</span>.</p>
	<p>Не удивляйтесь, что прерывания по зависанию и по клавише &laquo;<i>СТОП</i>&raquo; 
	имеют один и тот же вектор, но разные приоритеты. &laquo;<i>Ремонтная документация</i>&raquo; 
	объясняет, в чём дело. При нажатии на клавишу &laquo;<i>СТОП</i>&raquo; возникает 
	радиальное прерывание IRQ1. Микропрограммная обработка этого прерывания содержит 
	обращение по записи к регистру с адресом @#<span class="nmbr">177676</span>. 
	Однако в данной модификации микро-ЭВМ ячейка с таким адресом отсутствует, поэтому 
	происходит обработка прерывания по зависанию процессора. Попутно отметим, что 
	кроме зависания и клавиши &laquo;<i>СТОП</i>&raquo; прерывание по вектору
	<span class="nmbr">4</span> обслуживает также и отработку команды процессора
	<span class="cmds">HALT</span>.</p>
	<p>Кстати говоря, хотя вектор прерывания по &laquo;<i>СТОП</i>&raquo; и по зависанию 
	один и тот же, существует простой способ программного определения причины прерывания. 
	Для этого служит разряд <span class="nmbr">02</span> регистра @#<span class="nmbr">177716</span>, 
	выставляемый в <span class="nmbr">1</span> при нажатии на клавишу &laquo;<i>СТОП</i>&raquo; 
	(или при отработке <span class="cmds">HALT</span>):</p>
	<pre><span class="labl">PRST</span>:   ...                         <span class="cmmnt">; п/пр обработки прерывания</span>
        ...                         <span class="cmmnt">; по вектору @#4</span>
        <span class="cmds">BIT</span>     #<span class="nmbr">4</span>,@#<span class="nmbr">177716</span>
                                    <span class="cmmnt">; проверка разряда 02</span>
        <span class="cmds">BEQ</span>     <span class="labl">ZAVIS</span>
                                    <span class="cmmnt">; на обработку зависания</span>
        ...                         <span class="cmmnt">; обработка нажатия</span>
        ...                         <span class="cmmnt">; на клавишу &laquo;СТОП&raquo;</span></pre>
	<p>Этот способ не описан нигде, кроме всё той же &laquo;<i>ремонтной документации</i>&raquo;. 
	- <em>Прим. ред.</em></p>
	<h2><a name="toc_19"></a>Векторы прерываний</h2>
	<p>Мы уже не раз упоминали термин &laquo;<i>прерывание</i>&raquo;. Пора, наконец, 
	разобраться, что же это такое. Для начала попробуем дать общее определение.
	<b>прерывание</b> - <b>это приостановка выполнения процессором решения текущей 
	задачи и переход к обслуживанию внешних устройств или программных запросов</b>. 
	Как происходит так называемая <b>обработка прерывания</b>? Вначале рассмотрим 
	обработку <b>прерываний от внешних устройств</b>.</p>
	<p>Допустим, ЦП выполняет операции по решению текущей задачи, а в это время 
	поступает <b>запрос на прерывание</b> от внешнего устройства. Этот запрос обычно 
	подаётся по одной из отдельных электрических цепей ЦП, следовательно, он не 
	является командой в обычном понимании. Если приоритет ЦП, установленный для 
	текущей задачи, меньше, чем приоритет внешнего устройства, от которого пришёл 
	запрос, происходит <b>прерывание</b>. При этом процессор завершает выполнение 
	очередной команды и прекращает ввод следующих команд, после чего он записывает 
	в стек текущее ССП (содержимое <span class="regn">PS</span>). а затем содержимое
	<span class="regn">PC</span>, т.е. не что иное, как адрес следующей команды. 
	Эти данные необходимо сохранить, ведь после окончания обработки прерывания процессор 
	должен продолжить решение текущей задачи начиная со следующей команды и с тем 
	же самым приоритетом. Часто требуется сохранить не только содержимое
	<span class="regn">PC</span> и <span class="regn">PS</span>, но и другие данные, 
	тогда об этом должен позаботиться уже программист. Записав ССП и
	<span class="regn">PC</span> в стек. ЦП выполняет так называемый <b>переход 
	по вектору прерывания</b>.</p>
	<p><b>Вектор прерывания</b> - это просто два машинных слова, записанных одно 
	за другим в специально выделенной зоне ОЗУ - <b>системной области</b>. Первое 
	из этих слов представляет собой <b>адрес</b> начала программы обработки данного 
	прерывания, второе - ССП, установленное для него. Из этого описания совершенно 
	ясно, что каждое прерывание должно иметь свой собственный вектор.</p>
	<p>Итак, процессор, выполняя переход по вектору прерывания, переписывает его 
	первое слово в <span class="regn">PC</span>, а второе - в <span class="regn">
	PS</span>. После чего, естественно, следующей выполняется команда, записанная 
	в памяти по адресу, указанному в <span class="regn">PC</span>, т.е. начинается 
	выполнение программы обработки прерывания. Приоритет ЦП при этом будет установлен 
	согласно новому содержимому <span class="regn">PS</span>, которое, как мы помним, 
	переписано из второго слова вектора. Если этот приоритет достаточно низкий, 
	т.е. допускает на фоне обрабатываемого новое прерывание, то оно может быть также 
	обработано и т.д. Те, кто занимался практическим программированием, не могут 
	не заметить в этом процессе некоей аналогии с обращением к подпрограмме. Правда, 
	обработка прерывания несколько осложняется изменениями ССП, а следовательно, 
	приоритета и битов (&laquo;<i>флагов</i>&raquo;) условий. Но раз уж мы усмотрели 
	эту аналогию, то вспомним, что из любой подпрограммы должен быть возврат к выполнению 
	основной программы. Точно так же существует и <b>возврат из прерывания</b>, 
	для чего в конце программы его обработки должна быть записана специальная команда. 
	Обнаружив её, ЦП выполняет действия, обратные только что описанным, - восстанавливает 
	из стека содержимое <span class="regn">PC</span> и <span class="regn">PS</span> 
	и, естественно, продолжает выполнение прерванной программы, ведь теперь в
	<span class="regn">PC</span> - адрес её следующей команды. Отметим ещё раз, 
	что при этом приоритет процессора (а что ещё важнее, &laquo;<i>флаги</i>&raquo; 
	условий <span class="symb">CVZN</span> и, конечно, <span class="symb">T</span>-разряд) 
	также восстанавливается.</p>
	<p>Помимо прерываний от внешних устройств существуют и так называемые <b>командные 
	прерывания</b>, или программные запросы. Их обработка отличается от только что 
	описанного процесса лишь тем. что прерывание вызывается особой командой, встретившейся 
	по ходу программы. Ясно, что программный запрос на прерывание удовлетворяется 
	всегда и не зависит от приоритета - не может же процессор игнорировать команду, 
	которую сам прочитал! Командное прерывание, таким образом, ещё больше похоже 
	на переход к подпрограмме.</p>
	<p>Векторы прерывания располагаются, как было указано выше, в специально отведённой 
	зоне ОЗУ. В БК-0010 эта зона занимает адреса <span class="nmbr">0</span>...<span class="nmbr">276</span>. 
	Вычисления показывают, что в данной зоне можно разместить до
	<span class="nmbr">48</span> векторов прерывания. Но, разумеется, такого количества 
	векторов в БК нет, а свободные ячейки памяти используются для других целей.</p>
	<p>Откуда же берутся в системной области ОЗУ векторы прерывания? Очень просто: 
	они переписываются туда из ПЗУ при запуске системы. А ЦП уже &laquo;<i>знает</i>&raquo;, 
	по какому адресу записан каждый вектор, эти сведения заложены в него аппаратно, 
	и при поступлении соответствующего запроса он ими пользуется.</p>
	<p>Перечислим кратко имеющиеся в БК-0010 векторы прерывания. Вектор прерывания 
	обычно получает &laquo;<i>имя</i>&raquo; от того адреса, по которому записано 
	его первое слово. Эти адреса строго фиксированы для данного типа процессора 
	и поэтому точно определяют вектор.</p>
	<ul>
		<li><b>Вектор <span class="nmbr">4</span> - прерывание по зависанию</b>. 
		Переход по этому вектору выполняется как по запросу внешних устройств, так 
		и программно. &laquo;<i>Внешним устройством</i>&raquo; здесь является клавиша &laquo;<i>СТОП</i>&raquo;, 
		а программный переход по вектору <span class="nmbr">4</span> вызывает команда
		<span class="cmds">HALT</span> - &laquo;<i>останов</i>&raquo; (код этой 
		команды - <span class="nmbr">0</span>). Кроме того, прерывание по этому 
		вектору может вызвать и сам ЦП при зависании (что это такое, уже описано 
		выше), откуда и следует его название. Клавиша &laquo;<i>СТОП</i>&raquo;, 
		в отличие от других внешних устройств, вызывает прерывание всегда (понятие 
		приоритета на неё не распространяется).</li>
		<li><b>Вектор <span class="nmbr">10</span> - прерывание по резервному коду</b>. 
		Как уже было сказано, не все возможные коды использованы в наборе команд 
		ЦП. Если в процессе выполнения программы встретится &laquo;<i>неизвестный</i>&raquo; 
		код, происходит прерывание по вектору <span class="nmbr">10</span>.</li>
		<li><b>Вектор <span class="nmbr">14</span> - прерывание по
		<span class="symb">T</span>-разряду</b>. Прерывание по данному вектору происходит 
		после выполнения очередной команды, если <span class="symb">T</span>-разряд 
		ССП установлен равным <span class="nmbr">1</span></li>.
		<li><b>Вектор <span class="nmbr">20</span> - прерывание по команде</b>
		<span class="cmds">IOT</span>. Иногда используется в операционных системах.</li>
		<li><b>Вектор <span class="nmbr">24</span> - прерывание по аварии сетевого 
		питания</b>. В БК данный вектор не используется, хотя программа обработки 
		в ПЗУ имеется. Вектор просто не задействован аппаратно - соответствующий 
		вход процессора (ACLO) не подключён к устройству, вызывающему прерывание 
		при снижении напряжения питания. Это устройство в составе БК попросту отсутствует.</li>
		<li><b>Вектор <span class="nmbr">30</span> - командное прерывание</b>
		<span class="cmds">EMT</span>. Этот очень широко используемый вид прерывания, 
		как и следующий (по вектору <span class="nmbr">34</span>), будет подробно 
		описан в дальнейшем.</li>
		<li><b>Вектор <span class="nmbr">34</span> - командное прерывание</b>
		<span class="cmds">TRAP</span>.</li>
		<li><b>Вектор <span class="nmbr">60</span> - прерывание от клавиатуры</b>. 
		Запрос на прерывание по этому вектору поступает при нажатии любой клавиши 
		(кроме &laquo;<i>СТОП</i>&raquo; и регистровых). Запрос удовлетворяется, 
		если приоритет процессора менее <span class="nmbr">4</span>. Если приоритет 
		равен или больше <span class="nmbr">4</span>, запрос на прерывание &laquo;<i>зависает</i>&raquo; 
		до окончания обработки процессором текущей задачи или до снижения приоритета, 
		в этом случае говорят, что прерывание от клавиатуры запрещено.</li>
		<li><b>Вектор <span class="nmbr">100</span> - прерывание по таймеру</b>. 
		Помимо внутреннего (системного) таймера, описанного выше, к БК-0010 можно 
		подключить и внешний, или <b>таймер по прерываниям</b>. Его преимущество 
		в том, что ЭВМ, работая с ним, не должна обязательно периодически опрашивать 
		регистр счётчика, а таймер сам, например один раз в секунду, вызывает прерывание. 
		Приоритет таймера такой же, как у клавиатуры, и прерывание по вектору
		<span class="nmbr">100</span> разрешено, если приоритет процессора ниже
		<span class="nmbr">4</span>. Программа обработки данного прерывания предусмотрена 
		в Фокале, содержимое счётчика таймера вызывается функцией
		<span class="cmdf">FCLK</span>(), которая, кстати, не описана в руководстве 
		по Фокалу.</li>
	</ul>
	<p>(Другое название этого прерывания - &laquo;<i>Прерывание пользователя</i>&raquo;, 
	так как фактически оно может быть вызвано любым пользовательским внешним устройством, 
	подающим сигнал на контакт В1 разъёма порта УВВ (справа) или А5 разъёма системной 
	шины (слева). Таким образом, при описанном выше использовании прерывания таймер 
	является примером внешнего устройства. Простейший способ вызова прерывания по 
	вектору <span class="nmbr">100</span> - подача на контакт В1 порта УВВ сигнала &laquo;<i>земля</i>&raquo; 
	(или &laquo;<i>общий</i>&raquo;) с контактов А11, В11. А18, В18, А19 или В19 
	(так как порт УВВ работает с инверсными сигналами). Наиболее часто данное прерывание 
	используется для печати копии экрана на принтер при нажатии замыкающей указанные 
	контакты кнопки, как. например, в программе GRAFIX фирмы ALTEC или резидентном 
	драйвере SCREW ANIRAM-MIRIADA. - <em>Прим. ред.</em>)</p>
	<ul>
		<li><b>Вектор <span class="nmbr">274</span> - прерывание от клавиатуры по 
		нижнему регистру</b>. Как уже было сказано, в регистре данных клавиатуры 
		(адрес <span class="nmbr">177662</span>) при нажатии клавиши формируется
		<span class="nmbr">7</span>-разрядный код. Его преобразование в код нижнего 
		регистра осуществляется благодаря тому, что для обработки нажатия таких 
		клавиш предусмотрен отдельный вектор прерывания. В остальном вектор
		<span class="nmbr">274</span> не имеет отличий от вектора
		<span class="nmbr">60</span>, его приоритет тот же самый.</li>
	</ul>
	<p>Остальные ячейки в области векторов прерывания БК-0010 используются для других 
	целей. Но нам вполне достаточно и имеющихся векторов. Позже мы рассмотрим подробнее, 
	что и как можно сделать с их помощью, а сейчас перейдём ко второй теме нашего 
	разговора - к языку ассемблера.</p>
	<h3><a name="toc_20"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Сколько регистров имеется в составе ЦП? Каковы их названия?
		<ul id="ctrla">
			<li>
			<p>Восемь регистров общего назначения: <span class="regn">R0</span>,
			<span class="regn">R1</span>, <span class="regn">R2</span>,
			<span class="regn">R3</span>, <span class="regn">R4</span>,
			<span class="regn">R5</span>, <span class="regn">R6</span> (или
			<span class="regn">SP</span>) и <span class="regn">R7</span> (или
			<span class="regn">PC</span>), а также специальный регистр
			<span class="regn">PS</span>.</p>
			</li>
		</ul>
		</li>
		<li>Какие &laquo;<i>флаги</i>&raquo; состояния вы знаете, их буквенные обозначения 
		и краткие наименования?
		<ul id="ctrla">
			<li>
			<p><span class="symb">С</span> - перенос, <span class="symb">V</span> 
			- переполнение, <span class="symb">Z</span> - ноль,
			<span class="symb">N</span> - отрицательность.</p>
			</li>
		</ul>
		</li>
		<li>Если в результате выполнения какой-либо команды произошло переполнение 
		и число стало отрицательным, то какое значение примут разряды условий?
		<ul id="ctrla">
			<li>
			<p><span class="symb">С</span>=<span class="nmbr">0</span>;
			<span class="symb">V</span>=<span class="nmbr">l</span>;
			<span class="symb">Z</span>=<span class="nmbr">0</span>;
			<span class="symb">N</span>=<span class="nmbr">1</span>.</p>
			</li>
		</ul>
		</li>
		<li>Что обеспечивает <span class="symb">T</span>-разряд ССП при его установке 
		в единицу? Зачем это нужно?
		<ul id="ctrla">
			<li>
			<p>Прерывание программы после выполнения каждой команды, это нужно для 
			обеспечения отладочного режима (трассировки).</p>
			</li>
		</ul>
		</li>
		<li>Что хранится в первом слове вектора прерывания? А во втором?
		<ul id="ctrla">
			<li>
			<p>Адрес программы обработки прерывания. ССП для данного прерывания.</p>
			</li>
		</ul>
		</li>
		<li>Чем отличаются командные прерывания от прерываний, вызываемых внешними 
		устройствами?
		<ul id="ctrla">
			<li>
			<p>Командное прерывание вызывается особой командой программы, понятие 
			приоритета на него не распространяется.</p>
			</li>
		</ul>
		</li>
		<li>Учитывая, что разряды приоритета в ССП имеют номера
		<span class="nmbr">05</span>, <span class="nmbr">06</span> и
		<span class="nmbr">07</span>, напишите, какое машинное слово надо записать 
		в регистр <span class="regn">PS</span>, чтобы получить приоритет
		<span class="nmbr">0</span>, приоритет <span class="nmbr">4</span>, максимальный 
		приоритет. Считайте при этом, что остальные разряды <span class="regn">PS</span> 
		равны нулю. Для облегчения задачи &laquo;<i>нарисуйте</i>&raquo; и пронумеруйте 
		разряды <span class="regn">PS</span>, а получившееся потом число переведите 
		в восьмеричное.
		<ul id="ctrla">
			<li>
			<p>Приоритет <span class="nmbr">0</span> - <span class="nmbr">000000</span>, 
			приоритет <span class="nmbr">4</span> - <span class="nmbr">000200</span>, 
			максимальный приоритет (<span class="nmbr">7</span>) -
			<span class="nmbr">000340</span>.</p>
			</li>
		</ul>
		</li>
		<li>Какой приоритет имеет клавиша &laquo;<i>СТОП</i>&raquo; БК-0010?
		<ul id="ctrla">
			<li>
			<p>Это внеприоритетное внешнее устройство.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_21"></a>Языки программирования.</h2>
	<h3><a name="toc_22"></a>Что такое ассемблер</h3>
	<p>Вы, конечно, знакомы с имеющимися на БК-0010 так называемыми <b>языками высокого 
	уровня</b>. Это Фокал и Бейсик-MSX, которые находятся в ПЗУ (такое программное 
	обеспечение, зашитое в ПЗУ, называется <b>резидентным</b>). В составе ПО БК-0010 
	имеются и другие <b>языки программирования</b>, но, в отличие от резидентных, 
	они загружаются в ОЗУ. Все эти языки (вильнюсские <em>Бейсик-</em><i>85</i> 
	и <i>Бейсик-87</i>, <i>Т-язык</i>, <i>Форт-83</i> и т.п.) имеют общую черту 
	- это языки-<b>интерпретаторы</b>. Что это значит?</p>
	<p>Программа на языке интерпретирующего типа пишется в виде текста (<b>листинга</b>), 
	в котором с помощью условных символов, цифр и слов указывается последовательность 
	действий ЭВМ. (Отметим, что под термином &laquo;<i>листинг</i>&raquo; понимается 
	иногда вообще произвольный список или просто распечатка любых данных. Мы же 
	будем для краткости при менять этот термин в смысле &laquo;<i>текст программы 
	в условных обозначениях языка программирования</i>&raquo;). Но нам известно, 
	что единственный язык, доступный ЭВМ, - это язык машинных команд, двоично-восьмеричный 
	код. Написанная на языке высокого уровня программа может быть исполнена не непосредственно, 
	а лишь с помощью программы-интерпретатора (входящей в состав языка), причём 
	листинг построчно переводится интерпретатором в последовательность машинных 
	команд, которую и исполняет ЭВМ. Программа хранится в памяти ЭВМ практически 
	в том виде, в котором написана (небольшая модификация листинга, происходящая 
	при этом, принципиального значения не имеет).</p>
	<p>Если нужно ещё раз исполнить программу, интерпретатор снова переводит её 
	в машинные команды, причём не всю сразу, а по частям (обычно по одному оператору). 
	Преимущества интерпретатора - простота языка и удобство программирования (программу 
	можно просмотреть в той же форме, в которой она написана, исправить, дополнить 
	и т.п.), а также компактность представления программ в ОЗУ в виде листинга. 
	Недостатки - низкая скорость исполнения программ (ведь интерпретатор выполняет 
	перевод в машинные коды каждый раз заново) и то, что программа-интерпретатор 
	всегда должна присутствовать в памяти. (Прошитый в ПЗУ БК-0010.01 вильнюсский 
	Бейсик-MSX является своего рода промежуточным звеном между интерпретаторами 
	и компиляторами. Как и последние. он непосредственно перед выполнением программы 
	транслирует её в последовательность &laquo;<i>машинных псевдокоманд</i>&raquo; 
	(шитых кодов). Однако, как и в интерпретаторе, отсутствует возможность получения 
	автономной машинной программы и при исполнении в памяти одновременно должен 
	присутствовать листинг, сгенерированный шитый код и сам транслятор Бейсика (в 
	ПЗУ). Следует тем не менее заметить, что с помощью определённых хитростей всё 
	же удаётся получать &laquo;<i>автономные</i>&raquo; программы, не содержащие 
	листинга, но для их работы всё равно необходимо наличие ПЗУ с Бейсиком. -
	<em>Прим. ред.</em>)</p>
	<p>Помимо языков интерпретирующего типа есть и так называемые <b>транслирующие</b> 
	языки, или языки-компиляторы (термины &laquo;<i>компиляция</i>&raquo; и &laquo;<i>трансляция</i>&raquo; 
	в данном случае означают одно и то же). Обычно это серьёзные языки программирования 
	для мощных компьютеров - <i>Фортран</i>, <i>Паскаль</i>, <i>Кобол</i>, <i>Си</i>,
	<i>ПЛ/1</i>, <i>Ада</i> и др. Программа на таком языке пишется также в виде 
	листинга, а затем <b>транслируется</b>, т.е. переводится в машинные команды, 
	но при этом не исполняется. При таком переводе, например, на Фортране вместо 
	одного оператора могут быть <b>сгенерированы</b> десятки и даже сотни машинных 
	команд. В результате трансляции образуется программа в машинных кодах (так называемый
	<b>загрузочный модуль</b>). Поскольку это уже не листинг, а готовый машинный 
	код, программа исполняется несравненно быстрее, чем на языке-интерпретаторе, 
	а дальнейшее присутствие транслятора в памяти становится излишним. К недостаткам 
	языков этого типа относится прежде всего то, что программа-транслятор, входящая 
	в состав языка, при переводе листинга на язык машинных команд строит загрузочный 
	модуль не всегда оптимально. В зависимости от конкретного типа транслятора. 
	вида языка и реализуемого алгоритма эта &laquo;<i>неоптимальность</i>&raquo; 
	может приводить к увеличению длины программ в <span class="nmbr">1</span>.<span class="nmbr">5</span> 
	- <span class="nmbr">3</span> раза и соответствующему снижению возможного быстродействия 
	ЭВМ. Происходит это потому, что язык высокого уровня по структуре весьма сложен, 
	и при трансляции листинга всегда присутствует некоторая неоднозначность, когда 
	можно сделать перевод &laquo;и так, и эдак&raquo;</p>
	<p>(Более серьёзной причиной резкого увеличения объёма сгенерированной программы 
	является то, что к ней пристыковывается так называемый библиотечный модуль, 
	содержащий <b>все</b> подпрограммы реализации процедур и функций, относящихся 
	к какому-либо классу (например, все операции ввода-вывода). Подобное &laquo;<i>техническое 
	решение</i>&raquo; обеспечивает унификацию и упрощает работу компилятора, но 
	реально большая часть пристыкованных в составе данного модуля подпрограмм в 
	конкретной программе не используется и является своего рода &laquo;<i>балластом</i>&raquo;. 
	В интерпретаторе же все подпрограммы реализации, как правило, зашиты в самом 
	интерпретирующем модуле, что, в свою очередь, порождает другие недостатки, например 
	невозможность расширения перечня используемых функций, тогда как в компиляторе 
	это можно сделать простым включением новых подпрограмм в состав старого библиотечного 
	модуля. - <em>Прим. ред.</em>)</p>
	<p>Кроме того, обратный перевод с машинных кодов на язык высокого уровня практически 
	невозможен. Очень сильно на оптимальность трансляции влияет и то, что программы 
	на языках высокого уровня должны быть <b>переносимы на уровне листингов</b>, 
	т.е. должны исполняться по возможности одинаково на машинах разных систем. Получается, 
	что стандарт языка единый, а под него должны &laquo;<i>приспосабливаться</i>&raquo; 
	разные машины. ЭВМ же, как правило, свойственны жёсткая архитектура и система 
	команд, не всегда соответствующие средствам языка. Как разрешить это противоречие 
	и как, с одной стороны, использовать все ресурсы ЭВМ, а с другой, сделать программу 
	оптимальной, а средства её написания - удобными для программиста?</p>
	<p>На заре компьютерной техники программы составлялись непосредственно в виде 
	последовательности машинных команд (в &laquo;<i>машинном коде</i>&raquo;), при 
	этом они, естественно, полностью соответствовали архитектуре ЭВМ и были оптимальны 
	как по длине, так и по быстродействию (конечно, при известной квалификации программиста). 
	Но программирование в машинных кодах - каторжный труд, превращающий человека 
	в придаток машины, большая часть ресурсов человеческого мозга при этом уходит 
	не на собственно программирование, а на запоминание, вычисление и прочие операции, 
	связанные с кодами. Вскоре программисты сообразили, что эти функции можно передать 
	ЭВМ, освободившись тем самым от рутинного труда, а мощность машин стала достаточной, 
	чтобы помочь в этом программисту. Так из машинного языка родился <b>язык ассемблера</b>. 
	Как и язык высокого уровня, он позволяет пользоваться системой обозначений, 
	удобной и (по сравнению с машинными кодами) легко запоминающейся, но, в отличие 
	от других языков, это <b>язык низкого уровня</b>, или <b>машинно</b>-<b>ориентированный</b> 
	язык. Язык ассемблера всегда приспособлен для машин определённого типа, рассчитан 
	на определённую систему команд. Поэтому он позволяет использовать все, без исключения, 
	ресурсы машины, достигать максимально возможной компактности и быстродействия 
	программ. Каждой команде на языке ассемблера соответствует своя команда в машинных 
	кодах, поэтому возможен и нетруден как прямой (с ассемблера в коды), так и обратный 
	перевод. Структура языка проста, и программа-транслятор получается достаточно 
	компактной. Все эти преимущества обусловили чрезвычайно широкое распространение 
	языков ассемблера (на каждой ЭВМ он свой) и их высокую популярность. Тем более 
	велика роль ассемблера на таких ЭВМ, как БК-0010 с её далеко не безграничными 
	возможностями как по быстродействию, так и, что особенно важно, по ресурсам 
	памяти.</p>
	<p>Итак, что же такое <b>ассемблер</b>? Мы уже знаем, что это машинно-ориентированный 
	язык, система условных обозначений для программирования в машинных кодах. Кроме 
	того, словом &laquo;<i>ассемблер</i>&raquo; обозначают и специальную программу, 
	обеспечивающую программирование на языке ассемблера, иногда при этом добавляя: &laquo;<i>ассемблер-система</i>&raquo;. 
	И ещё одно значение придают этому термину, когда говорят &laquo;<i>программа 
	на ассемблере</i>&raquo;, - под этим обычно понимается программа в машинных 
	кодах, написанная на языке ассемблера и оттранслированная в коды.</p>
	<p>А что же машинные коды, их уже знать не требуется? В общем, да. Ассемблер-система 
	обеспечивает перевод листинга программы в машинный код, а другая специальная 
	программа, называемая <b>дизассемблером</b>, может легко выполнить обратный 
	перевод машинных кодов на язык ассемблера, причём, оба преобразования делаются 
	быстро и без ошибок. (На самом деле программы-дизассемблеры не всегда работают 
	без ошибок. Многие из этих программ, реализованных на БК, не распознают входящие 
	в &laquo;<i>тело</i>&raquo; кодового модуля массивы чисел и символов, пытаясь 
	и их интерпретировать как команды ассемблера. Это может сделать полученный листинг 
	трудночитаемым, особенно для начинающих программистов. - <em>Прим. ред.</em>) 
	И тем не менее бывают случаи, когда знание машинных кодов может оказаться весьма 
	полезным, избавляя от необходимости применять специальные программные средства 
	и позволяя экономить время. Но это случается относительно редко, поэтому изучение 
	машинных команд не входит в нашу задачу, а желающие всегда могут ознакомиться 
	с ними по имеющейся литературе. В частности, список машинных команд в кодах 
	и их соответствий на языке ассемблера (так называемый <b>мнемокод</b>) приведён 
	в &laquo;<i>Руководстве системного программиста</i>&raquo;, прилагаемом к БК-0010. 
	(Более подробные сведения можно найти в кн. <em>Осетинский Л.Г., Осетинский 
	М.Г., Писаревский А.Н.</em> Фокал для микро- и мини-компьютеров. Л.: Машиностроение,
	<span class="nmbr">1988</span>. - <em>Прим. ред.</em>) Мы же по ходу изложения 
	будем обращаться к машинным кодам только в редких случаях, по возможности ограничиваясь 
	языком ассемблера.</p>
	<h3><a name="toc_23"></a>Ассемблер-системы</h3>
	<p>Для БК-0010 создано множество ассемблер-систем. Не останавливаясь на ранних, 
	уже устаревших программах, отметим, что все современные ассемблер-системы имеют 
	ряд общих черт. Все они состоят из четырёх основных частей, объединённых в одном 
	модуле: <b>монитор</b>, <b>редактор</b>, <b>транслятор</b> и <b>компоновщик</b>.</p>
	<p><b>Монитор</b> включается при запуске ассемблер-системы и обеспечивает с 
	помощью ряда директив диалог с пользователем, позволяя считывать тексты программ 
	и записывать их на МЛ, транслировать и компоновать программы, а также (в наиболее 
	совершенных системах) запускать готовый загрузочный модуль.</p>
	<p>По особой директиве можно перейти в <b>редактор текста</b> ассемблер-системы. 
	Это, по-видимому, самая важная её часть, от совершенства которой в большой степени 
	зависит удобство работы в ассемблере. Редактор позволяет вводить с клавиатуры 
	и редактировать тексты (листинги) программ. Мощный редактор многократно ускоряет 
	и облегчает работу в ассемблере, и недооценивать его значение может только тот, 
	кто по-настоящему не работал в ассемблер системе.</p>
	<p><b>Транслятор</b> запускается директивами монитора. Он транслирует (переводит 
	в машинные команды) текст программы, подготовленный в редакторе или загруженный 
	с МЛ, резервирует ячейки памяти под переменные. константы и массивы, вычисляет 
	адреса строк (операторов) программы и адреса переходов, а также выявляет некоторые 
	ошибки, допущенные программистом.</p>
	<p><b>Компоновщик</b>, также работающий под управлением монитора, позволяет 
	так обработать текст уже оттранслированной программы, что она становится приспособленной 
	для работы в заданных конкретных адресах ОЗУ. Он также может состыковать несколько 
	модулей, загруженных с магнитной ленты, между собой для их совместной работы 
	как единого целого.</p>
	<p>Какие же в настоящее время разработаны ассемблер-системы для БК-0010? Первыми 
	системами, имеющими все вышеперечисленные признаки, были трансляторы <i>МИКРО.С</i> 
	(авторы <em>А.М.&nbsp;Сомов</em> и <em>С.В.&nbsp;Шмытов</em>, Москва). Начиная 
	с <i>МИКРО.<span class="nmbr">3</span>С</i> и кончая <i>МИКРО.<span class="nmbr">1103</span></i> 
	и <i>МИКРО.<span class="nmbr">1104</span></i> (<span class="nmbr">1989</span>-<span class="nmbr">1990</span> 
	гг.), эти ассемблер-системы непрерывно совершенствовались, расширялась их система 
	команд, улучшался сервис. Однако основной их недостаток - довольно слабый и 
	примитивный редактор текста - сохранился до самой последней версии.</p>
	<p>Заметный шаг вперёд в области создания ассемблер-систем для БК-0010 был сделан, 
	когда к работе подключился С.А. Кумандин (г.Коломна). Начав с усовершенствования 
	существовавшей в тот момент версии (<i>МИКРО.<span class="nmbr">8</span>С</i>) 
	и снабдив её значительно более мощным редактором, что привело к появлению <i>
	МИКРО.<span class="nmbr">8</span>К</i>, он продолжал в дальнейшем работу над 
	ассемблер-системой, всё дальше уходя от исходной версии. Результатом этого явилось 
	создание в <span class="nmbr">1988</span>-<span class="nmbr">1989</span> гг. 
	версий <i>МИКРО.<span class="nmbr">10</span>К</i> и <i>МИКРО.<span class="nmbr">11</span>К</i>, 
	которые можно считать уже вполне самостоятельными ассемблер-системами, так далеко 
	они ушли от <i>МИКРО.<span class="nmbr">8</span>С</i>. Если версия <i>МИКРО.<span class="nmbr">8</span>К</i> 
	содержала ряд ошибок, то <i>МИКРО.<span class="nmbr">10</span>К</i> является 
	совершенной и тщательно отлаженной программой, имеет расширенную систему команд, 
	удобные дополнительные форматы записи псевдокоманд, а самое главное - редактор 
	текста, который не уступает, а во многом и превосходит знаменитый редактор
	<i>EDASP</i>. Не останавливаясь подробно на достоинствах этого редактора, можно 
	только сказать, что, по мнению автора, сегодня это вообще лучший экранный редактор 
	текста, созданный когда-либо для БК-0010, включая и специальные редакторы, - 
	он имеет всё необходимое, в том числе механизм макроопераций, неограниченный 
	буфер текста и т.п.</p>
	<p>На базе <i>МИКРО.<span class="nmbr">10</span>К</i> создано ещё несколько 
	версий ассемблера - <i>МИКРО.<span class="nmbr">11</span>К</i>, рассчитанный 
	специально на прошивку в ПЗУ и имеющий ещё более совершенный редактор, <i>МИКРО.<span class="nmbr">10</span>К-РП</i>, 
	редактор которого может работать как с обычным экраном, так и в режиме &laquo;<i>РП</i>&raquo;, 
	что позволяет при необходимости иметь дело с текстами длиной до
	<span class="nmbr">50000</span> символов, <i>МИКРО.<span class="nmbr">1</span>0-<span class="nmbr">01</span>К</i>, 
	специально рассчитанный на работу с клавиатурой БК-0010.01 и также имеющий режим &laquo;<i>РП</i>&raquo;. 
	Следует отметить, что все версии <i>МИКРО.<span class="nmbr">10</span>К</i> 
	(даже те, редактор в которых на работу в &laquo;<i>РП</i>&raquo; не рассчитан) 
	позволяют в режиме &laquo;<i>РП</i>&raquo; компоновать в памяти тексты программ 
	большой длины (до <span class="nmbr">50000</span>), что в основном позволяет 
	обойтись без промежуточных записей на МЛ объектных модулей при компоновке и 
	значительно повышает оперативность и удобство работы.</p>
	<p>К редактору ассемблер-системы <i>МИКРО.<span class="nmbr">10</span>К</i> 
	в настоящее время изготовлен, прежде всего автором этой публикации, целый ряд &laquo;<i>приставок</i>&raquo;-утилит, 
	ещё более расширяющих его возможности. Эти утилиты позволяют форматировать тексты 
	и печатать их на принтерах, выполнять произвольную перекодировку, сортировку 
	по алфавиту и т.п. Причём всё это делается непосредственно при работе в редакторе, 
	без промежуточной записи текста на МЛ. Все ассемблер-системы <i>МИКРО.К</i>, 
	в отличие от прочих, являются перемещаемыми, могут с равным успехом работать 
	в ОЗУ и ПЗУ, а параметры их буферов (текста и загрузочного модуля) могут быть 
	легко и произвольно изменены пользователем, например с целью использования всей 
	памяти при работе системы в ПЗУ.</p>
	<p>В последнее время появился ряд новых, достаточно удобных и мощных разработок 
	ассемблер-систем - <i>MIKRO-SW</i> (<em>В.С. Коренков</em>), пакет MSW (<em>В.В. 
	Савин</em>) и другие, но все они, имея перед версией <i>МИКРО.<span class="nmbr">10</span>К-РП</i> 
	некоторые (не слишком существенные) преимущества, лишены ряда её достоинств, 
	и прежде всего присущей ей простоты и &laquo;<i>открытости</i>&raquo;, т.е. 
	хоть чем-нибудь да связывают программиста. Поэтому начинать с них знакомство 
	с ассемблером всё же не рекомендуется. (Кроме вышеперечисленных сейчас существует 
	и ряд других, не менее удобных ассемблер-систем:</p>
	<p><i>M18</i> (автор <em>А.Г. Прудковский</em>) и её новая версия <i>M19</i>, 
	ассемблер <i>Турбо2</i> (<em>А.М. Надежин</em>), имеющий в своём составе модуль 
	плавающей арифметики, и наиболее мощный на сегодня ассемблер-отладчик-дизассемблер
	<i>PARADISE</i> <em>С.В. Клименкова</em>. - <em>Прим. ред.</em>)</p>
	<p>В дальнейшем мы будем при описании ассемблера ориентироваться в основном 
	на версию <i>МИКРО.<span class="nmbr">10</span>К-РП</i>, но при необходимости 
	отмечать и особенности других версий. Подробно описывать какую-либо, а тем более 
	все версии ассемблер-систем, созданных для БК-0010, не представляется возможным. 
	Устанавливая конкретную программу (рекомендуется приобрести её официально, а 
	не украсть с помощью &laquo;<i>свободного обмена</i>&raquo;, ведь это ваш основной 
	рабочий инструмент!), пользователь обычно получает и краткое описание с перечислением 
	команд ассемблера, директив редактора и монитора, а также формата записи операторов 
	и может освоить её самостоятельно. Мы же будем рассматривать общие вопросы программирования 
	на ассемблере, относящиеся практически ко всем версиям.</p>
	<h3><a name="toc_24"></a>Работа с ассемблером. Формат команды</h3>
	<p>Итак, загрузив и запустив ассемблер-систему <i>МИКРО.<span class="nmbr">10</span>К</i> 
	с адреса <span class="nmbr">1000</span>, войдём в редактор по команде &laquo;<i>EN</i>&raquo;. 
	Эта команда обеспечивает переход в начало текста, а если нам нужно вернуться 
	на ту страницу, на которой мы были в момент выхода из редактора, подаётся команда &laquo;<i>ED</i>&raquo;. 
	Теперь мы можем писать текст программы, состоящий из <b>команд ассемблера</b>.</p>
	<p>В каждой строке текста программы записывается одна команда (исключением являются
	<b>псевдокоманды</b>, которых в каждой строке может быть несколько, но об этом 
	позже). <b>Командная строка</b> текста программы условно разделена на четыре
	<b>поля</b>, расположенных слева направо: <b>метка</b>, <b>оператор</b>, <b>
	операнды</b> и <b>комментарий</b>. Поля в редакторе <i>МИКРО.<span class="nmbr">10</span>К</i> 
	отделяются друг от друга любым числом пробелов (код <span class="nmbr">40</span>) 
	или символов &laquo;<i>ГТ</i>&raquo; (код <span class="nmbr">11</span>). Удобнее 
	всего разделять поля нажатием клавиши &laquo;<span class="symb">ГТ</span>&raquo; 
	(её эквивалент для клавиатуры БК-0010.01 в редакторе <i>МИКРО.<span class="nmbr">10</span>К</i> 
	- СУ/Т или клавиша &laquo;<i>СБР</i>&raquo;), при этом одноименные поля размещаются 
	друг под другом, программа имеет аккуратный вид и легко читается. Оканчивается 
	каждая строка символом &laquo;<i>ВВОД</i>&raquo; (&laquo;<span class="symb">ВК</span>&raquo;, 
	код <span class="nmbr">12</span>). Рассмотрим каждое из полей командной строки.</p>
	<p>Первое - поле <b>метки</b>. Метка - это условное символьное имя, присваиваемое 
	данной строке. После трансляции каждая строка текста превращается в последовательность 
	кодов, размещаемую начиная с определённого (текущего) адреса. Метке, стоящей 
	в начале строки, присваивается этот адрес, который заносится в формируемую транслятором
	<b>таблицу меток</b>. Зачем нужны метки? Как вы помните, в Бейсике или Фокале 
	каждой строке присваивается номер, пользуясь которым можно обратиться к данной 
	строке (передать ей управление) из любой точки программы. Точно так же в ассемблере 
	можно обратиться к данной строке (оператору), передав ему управление по имени 
	метки. Но есть и отличия метки от номера строки.</p>
	<p>Во-первых, поле метки не является обязательным, т.е. помечаются не все строки, 
	а только те, к которым нам придётся обращаться по ходу исполнения программы. 
	Во-вторых, метками могут помечаться не только исполняемые строки программы (содержащие 
	операторы), а вообще любые адреса (ячейки памяти). Таким образом, по метке можно 
	не только передать управление, но и просто обратиться к любому заданному адресу, 
	например записать в помеченную ячейку памяти какое-либо значение или прочитать 
	из неё число. Следовательно, метка - это ещё и имя переменной или константы. 
	С другой стороны, как передать управление, так и обратиться к ячейке памяти 
	можно и по <b>адресу</b>. Метки же в общем случае служат для присваивания отдельным 
	адресам имён, что значительно облегчает процесс программирования на ассемблере.</p>
	<p>Метка может состоять из латинских заглавных букв и цифр, причём допустимое 
	количество символов в имени метки не более трёх (в некоторых других версиях 
	ассемблеров - до шести). Если метка начинается с буквы, она называется <b>обычной</b> 
	и обращение к ней возможно из любого места программы с помощью любого оператора, 
	имеющего поле операндов или передающего управление (заметим, что в серьёзных 
	ассемблер-системах на больших ЭВМ такие метки носят название <b>глобальных</b>, 
	но автор считает &laquo;<i>механический</i>&raquo; перенос терминологии на БК-0010 
	неправильным). Если же метка начинается с цифры, она называется <b>локальной</b> 
	и обращение к ней возможно с помощью лишь некоторых операторов, а действительна 
	она только до ближайшей обычной метки (вперёд или назад). Имя обычной метки, 
	как правило, должно быть для данной программы уникальным, т.е. его повторение 
	не практикуется (при повторении имеет смысл только последняя из одноименных 
	меток). Имена локальных меток могут по ходу программы повторяться многократно, 
	лишь бы одноимённые локальные метки были разделены обычными (в ранних версиях 
	ассемблеров допускалось употребление только обычных меток) Для отличия имён 
	меток от прочих идентификаторов ассемблера после них ставится символ &laquo;:&raquo;. 
	Имена меток и операторов могут совпадать, это не приводит к ошибкам. Если в 
	строке имеется несколько меток, то всем им присваивается один и тот же адрес. 
	Приведём примеры.</p>
	<p>Обычные метки:</p>
	<p><span class="labl">А</span>: <span class="labl">&nbsp;&nbsp;&nbsp;АВ</span>:
	<span class="labl">&nbsp;&nbsp;&nbsp;MET</span>: <span class="labl">&nbsp;&nbsp;&nbsp;N9</span>:
	<span class="labl">&nbsp;&nbsp;&nbsp;Т75</span>: <span class="labl">&nbsp;&nbsp;&nbsp;TR4</span>:</p>
	<p>Локальные метки:</p>
	<p><span class="locl">2</span>: <span class="locl">&nbsp;&nbsp;&nbsp;94</span>:
	<span class="locl">&nbsp;&nbsp;&nbsp;545</span>: <span class="locl">&nbsp;&nbsp;&nbsp;7N</span>:
	<span class="locl">&nbsp;&nbsp;&nbsp;4А7</span>: <span class="locl">&nbsp;&nbsp;&nbsp;8AR</span>:</p>
	<p>Запись нескольких меток в одной строке:</p>
	<p><span class="labl">LD</span>:<span class="labl">M1</span>:
	<span class="locl">&nbsp;&nbsp;&nbsp;1</span>:<span class="locl">12</span>:
	<span class="labl">&nbsp;&nbsp;&nbsp;А</span>:<span class="locl">17</span>:<span class="locl">14</span>:</p>
	<p>Второе поле командной строки - поле <b>оператора</b>. Оно является обязательным, 
	без него строка лишена смысла. Оператором называется собственно машинная команда, 
	записанная на языке ассемблера. Набор операторов в ассемблере строго соответствует 
	набору машинных команд ЭВМ. Таким образом, оператор сообщает процессору, <b>
	что надо сделать</b>. Подробно каждый из операторов будет рассмотрен в дальнейшем, 
	пока же мы опишем только два из них, которые будем использовать в приводимых 
	примерах:</p>
	<ul>
		<li><span class="cmds">CLR</span> - <b>очистка</b> (обнуление) операнда 
		(заданной тем или иным способом ячейки памяти или регистра);</li>
		<li><span class="cmds">MOV</span> - <b>пересылка</b> содержимого первого 
		операнда во второй (т.е. перезапись содержимого одной ячейки памяти во вторую). 
		При этой операции содержимое первой ячейки не меняется, поэтому название &laquo;<i>пересылка</i>&raquo; 
		следует признать не совсем удачным, правильнее было бы говорить &laquo;<i>копирование</i>&raquo;.</li>
	</ul>
	<p>В состав оператора входит также указание, работает ли он со словом или с 
	байтом. Если имя оператора обычное, то это указывает на работу со словом. Для 
	работы с байтом к имени оператора прибавляется буква &laquo;<span class="cmds">В</span>&raquo;, 
	например: <span class="cmds">CLR</span> - <span class="cmds">CLRB</span>,
	<span class="cmds">MOV</span> - <span class="cmds">MOVB</span>. Имена операторов 
	в ассемблере записываются латинскими заглавными символами и, в отличие от некоторых 
	команд Бейсика, не допускают никаких вариаций и сокращений.</p>
	<p>Третье поле командной строки - поле <b>операндов</b>. В зависимости от стоящего 
	в строке оператора операндов может быть два, один или ни одного (т.е. поле операндов 
	не является обязательным). Если оператор указывает процессору, <b>что</b> ему 
	надо сделать, то операнды - указание на то, <b>с чем это надо сделать</b>, т.е. 
	операнды играют роль переменных или констант. Если поле операндов отсутствует, 
	это значит, что выполняются строго фиксированные для данного оператора действия 
	(например, команда останова процессора). Способы указания операндов весьма разнообразны, 
	они носят название <b>способов адресации</b> и будут подробно рассмотрены далее.</p>
	<p>Последнее поле командной строки - поле <b>комментария</b>. Как известно, 
	комментариями называются пояснения к программе, применяющиеся с целью сделать 
	её текст более понятным для чтения. Транслятор игнорирует комментарии, они сохраняются 
	только в листинге программы и в загрузочный модуль (программу в кодах), разумеется, 
	не включаются, поэтому в состав комментариев могут входить любые символы. Комментарии 
	могут следовать после оператора или операндов без всяких разделителей, транслятор 
	распознает их просто по месту расположения в строке. Если же комментарии записаны 
	в пустой строке или сразу после метки (это тоже возможно, тогда данная метка 
	считается относящейся к первой последующей строке с оператором), они должны 
	начинаться с символа &laquo;<span class="symb">;</span>&raquo;. В некоторых 
	других версиях ассемблеров отделение комментариев символом &laquo;<span class="symb">;</span>&raquo; 
	обязательно во всех случаях. Приведём пример записи полных командных строк ассемблера 
	и комментариев:</p>
	<pre><span class="cmmnt">; Программа начальной очистки счётчиков</span>
<span class="labl">BEG</span>:    <span class="cmds">CLR</span>     <span class="labl">M1</span>                  <span class="cmmnt">; Очистка счётчика единиц</span>
        <span class="cmds">CLR</span>     <span class="labl">М2</span>                  <span class="cmmnt">; Очистка счётчика десятков</span>
        <span class="cmds">CLR</span>     <span class="labl">М3</span>                  <span class="cmmnt">; Очистка счётчика сотен</span>
<span class="labl">OST</span>:    <span class="cmds">MOVB</span>    #<span class="nmbr">1</span>,<span class="labl">PRO</span>              <span class="cmmnt">; Записать признак останова</span>
                                    <span class="cmmnt">; в ячейку признака</span>
<span class="labl">CON</span>:    ...                         <span class="cmmnt">; Продолжение программы</span>
        <span class="cmds">MOV</span>     <span class="labl">М1</span>,<span class="labl">М4</span>               <span class="cmmnt">; Запись единиц</span>
<span class="cmmnt">; и т.д., дальнейший текст</span> <span class="cmmnt">программы</span></pre>
	<p>Разумеется, не всё ещё в этой записи вам понятно, но это станет ясно в дальнейшем. 
	Пока же обратите внимание на расположение полей меток, операторов и операндов 
	и на правила записи комментариев.</p>
	<p class="centr">★ ★ ★</p>
	<p>Теперь вы в общих чертах знаете, как писать текст программы. А что с ним 
	делать потом? Разумеется, в своё время об этом будет рассказано подробно. Но 
	по ходу изложения мы будем приводить примеры, которые многие читатели захотят 
	проверить, а может быть, изменить и посмотреть, что получится. Такие эксперименты 
	можно только приветствовать, для освоения ассемблера (как и любого другого языка 
	программирования) нужна практика. Но те, кто столкнулся с ассемблером впервые, 
	наверняка встретят трудности при решении вопроса, что делать с написанным текстом 
	программы. Придётся нам, забегая вперёд, дать самые общие и схематические рекомендации, 
	не объясняя пока, &laquo;<i>что для чего и зачем</i>&raquo; Эти рекомендации 
	строго конкретны и относятся только к ассемблер-системе <i>МИКРО.<span class="nmbr">10</span>К</i> 
	и её модификациям. Если же у вас другая ассемблер-система, самостоятельно найдите 
	в её описании эквивалентные директивы.</p>
	<p class="centr">★ ★ ★</p>
	<p>Итак, текст программы готов. В конце, в отдельной строке, поставьте псевдооператор
	<span class="pscm">END</span>. Всё, что следует за ним, транслятор игнорирует. 
	Теперь нужно выйти из редактора, нажав клавишу &laquo;<i>КТ</i>&raquo; (или 
	СУ/Е для <i>МИКРО.<span class="nmbr">10</span>-<span class="nmbr">01</span>К</i>). 
	Вы в мониторе. Если хотите, запишите текст программы на МЛ директивой &laquo;<i>ST</i>&raquo;. 
	Оттранслируйте листинг директивой &laquo;<i>СО</i>&raquo;, по окончании трансляции 
	будет выдана длина загрузочного модуля в байтах. Если транслятор обнаружит ошибку, 
	то на запрос &laquo;Е/С?&raquo; нажмите клавишу &laquo;<i>Е</i>&raquo;, транслятор 
	передаст управление в редактор, и курсор покажет ошибку (&laquo;<i>ткнёт в неё 
	носом</i>&raquo;). Частая ошибка, которую на первый взгляд трудно распознать 
	начинающему, - случайное употребление русского символа вместо одинакового по 
	начертанию латинского.</p>
	<p>Но вот текст оттранслирован. Определим, нужна ли компоновка. Если все метки 
	(имена и адреса) транслятор выдал в обычной форме, компоновка не требуется. 
	Если же есть метки, выданные инверсно, то она нужна. Для компоновки дайте директиву &laquo;<i>LS</i>&raquo;. 
	последует запрос &laquo;<span class="strn">Addr=</span>&raquo;. Введите число
	<span class="nmbr">13000</span> и нажмите &laquo;<i>ВВОД</i>&raquo;. Во вторично 
	выданной таблице инверсных меток быть не должно. Если они есть, значит, в программе 
	имеются ошибки (мы пока даём указания, касающиеся только приводимых далее примеров, 
	при реальном программировании всё несколько сложнее). Если всё в порядке, программу 
	в кодах (загрузочный модуль) можно записать на МЛ директивой &laquo;<i>SA</i>&raquo; 
	и запустить директивой &laquo;<i>RU</i>&raquo;. Посмотрев, как работает программа, 
	остановите её клавишей &laquo;<i>СТОП</i>&raquo;, ЭВМ выйдет в монитор или МСД. 
	Теперь вы можете с помощью директив МСД просмотреть полученную программу в кодах, 
	она расположена начиная с адреса <span class="nmbr">13000</span>. При желании 
	можно ещё раз запустить программу с этого адреса. Если вы захотите внести в 
	листинг изменения, войдите в ассемблер по адресу &laquo;<i>повторного входа</i>&raquo; 
	(<span class="nmbr">1002</span><span class="var">G</span>). выйдите в редактор 
	(&laquo;<i>ED</i>&raquo; или &laquo;<i>EN</i>&raquo;) и модифицируйте текст, 
	а если его нужно уничтожить и начать всё сначала, то либо запустите ассемблер 
	с адреса <span class="nmbr">1000</span>, либо в мониторе ассемблер-системы дайте 
	директиву &laquo;<i>RS</i>&raquo;. Текст с МЛ загружается директивой &laquo;<i>LO</i>&raquo;, 
	а если вы хотите подгрузить его к прежнему тексту в памяти, дайте директиву &laquo;<i>LF</i>&raquo;. 
	Остальные директивы монитора ещё долго вам не понадобятся (а если вы не освоите 
	ассемблер всерьёз, то вообще никогда).</p>
	<p>Вот и всё. Как вы считаете, всё это настолько сложнее Фокала или Бейсика, 
	чтобы стоило об этом говорить? А куда как часто автору приходилось встречать 
	людей, которые заявляли, что на ассемблере <b>очень</b> трудно работать, что 
	он <b>ужасно</b> сложен и что освоить его может разве лишь гений... Скромность, 
	конечно, хороша, но не тогда, когда она мешает прогрессу.</p>
	<p>Несколько слов о редакторе текста. Если вам приходилось работать с редактором
	<i>EDASP</i>, то осваивать в редакторе <i>МИКРО.<span class="nmbr">10</span>К</i> 
	почти ничего не придется, они очень похожи. А когда вы полностью освоите <i>
	МИКРО.<span class="nmbr">10</span>К</i>, у вас будут основания забыть о всех 
	других редакторах текста.</p>
	<h3><a name="toc_25"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Каково основное отличие языка ассемблера от языков Фокал и Бейсик БК-0010?
		<ul id="ctrla">
			<li>
			<p>Фокал и Бейсик - языки интерпретирующего типа, а ассемблер - компилирующего.</p>
			</li>
		</ul>
		</li>
		<li>Какая ассемблер-система самая лучшая?
		<ul id="ctrla">
			<li>
			<p><i>МИКРО.<span class="nmbr">10</span>К-РП</i> или <i>МИКРО.<span class="nmbr">1</span>0-<span class="nmbr">01</span>К</i>. 
			Это. конечно, шутка. Лучшая ассемблер-система - это та, которая вам 
			нравится, или даже просто та, которая у вас есть. Некоторые же утверждают, 
			что лучшая программа - это та, которая ещё не написана.</p>
			</li>
		</ul>
		</li>
		<li>Из скольких символов может состоять метка?
		<ul id="ctrla">
			<li>
			<p>Не более чем из трёх в <i>МИКРО.<span class="nmbr">10</span>К</i> 
			и из шести - в некоторых других системах.</p>
			</li>
		</ul>
		</li>
		<li>Локальная метка может начинаться с буквы?
		<ul id="ctrla">
			<li>
			<p>Нет, только с цифры.</p>
			</li>
		</ul>
		</li>
		<li>Какие операторы ассемблера вы уже знаете?
		<ul id="ctrla">
			<li>
			<p><span class="cmds">CLR</span>, <span class="cmds">CLRB</span>,
			<span class="cmds">MOV</span>, <span class="cmds">MOVB</span>,
			<span class="pscm">END</span>.</p>
			</li>
		</ul>
		</li>
		<li>Обязательно ли комментарии должны начинаться с символа &laquo;<span class="symb">;</span>&raquo;?
		<ul id="ctrla">
			<li>
			<p>В <i>МИКРО.<span class="nmbr">10</span>К</i> - не обязательно, если 
			они следуют за оператором или операндами.</p>
			</li>
		</ul>
		</li>
		<li>Наберите в ассемблер-системе программу, приведённую в качестве примера 
		в этом разделе (комментарии можно не переписывать), и попробуйте её оттранслировать 
		и скомпоновать (запускать не надо). Что обращает на себя внимание после 
		компоновки?
		<ul id="ctrla">
			<li>
			<p>Метки <span class="labl">M1</span>, <span class="labl">М2</span>,
			<span class="labl">М3</span>, <span class="labl">М4</span>,
			<span class="labl">PRO</span> после компоновки остались инверсными, 
			так как они <b>не определены</b> - отсутствуют в исходном тексте.</p>
			</li>
		</ul>
		</li>
		<li>Является ли программирование на ассемблере сложной процедурой?
		<ul id="ctrla">
			<li>
			<p>Автор утверждает, что нет, и в ваших интересах не пытаться его опровергнуть.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_26"></a>Способы адресации</h2>
	<p>Этот раздел, видимо, самый сложный. Но он важнейший в изучении ассемблера, 
	ибо знание его необходимо для правильного использования операторов; потому на 
	его изучение не следует жалеть сил и времени.</p>
	<p>Ранее мы установили, что в команде ассемблера <b>оператор</b> указывает,
	<b>что надо сделать</b>, а операнд - <b>с чем это надо сделать</b>. Как уже 
	было сказано, поле операндов не обязательно (оно имеется не во всех командах). 
	Но если их нет, это означает только то, что данный оператор в операндах не нуждается 
	- они подразумеваются по умолчанию или производится обращение не к памяти ЭВМ, 
	а к другим её устройствам. В большинстве случаев операнды все же присутствуют 
	в составе команды, и разговор пойдет именно о них.</p>
	<p><b>Способы</b> (или <b>методы</b>) адресации - это не что иное, как указание 
	на ячейки памяти, с которыми должен манипулировать оператор. Таких методов в 
	системе команд процессора БК вполне достаточно, чтобы обеспечить высокую гибкость 
	в построении программы Многие способы адресации, кроме указания на адреса памяти, 
	ещё и модифицируют их, т.е., по сути, выполняют функции дополнительных команд, 
	а следовательно, значительно экономят память и повышают скорость исполнения 
	программы. В большинстве случаев способы адресации одинаковы для всех команд, 
	содержащих операнды. Есть некоторые ограничения, относящиеся к отдельным операторам, 
	но их мы будем оговаривать особо, когда дойдём до описания этих операторов.</p>
	<p>Прежде чем перейти к изложению конкретных способов адресации, кратко напомним, 
	какие в нашей ЭВМ вообще возможны операнды. Прежде всего, это ячейки памяти, 
	лежащие в пределах адресного пространства ЭВМ (с адресами <span class="nmbr">
	0</span> - <span class="nmbr">177777</span>). Адрес можно указывать с точностью 
	до слова или до байта, но это уже скорее относится к формату записи оператора, 
	а не операндов. Далее, это регистры общего назначения процессора (РОН):
	<span class="regn">R0</span>, <span class="regn">R1</span>,
	<span class="regn">R2</span>, <span class="regn">R3</span>,
	<span class="regn">R4</span>, <span class="regn">R5</span>,
	<span class="regn">R6</span> и <span class="regn">R7</span> (на языке ассемблера 
	регистр <span class="regn">R6</span> принято именовать <span class="regn">SP</span>, 
	а <span class="regn">R7</span> - <span class="regn">PC</span>). Напомним, что
	<span class="regn">SP</span> - это указатель вершины стека, а
	<span class="regn">PC</span> - счётчик команд (указатель адреса следующей команды). 
	Подробно эти моменты рассматривались в разделах, посвящённых архитектуре ЭВМ, 
	сейчас же важно, что все регистры, в принципе, также представляют собой ячейки 
	памяти.</p>
	<p>Теперь можно перейти к описанию собственно способов адресации. Приводя примеры, 
	будем стараться использовать только те два оператора (<span class="cmds">CLR</span> 
	и <span class="cmds">MOV</span>), которые нам уже знакомы. Регистр общего назначения 
	в общем виде будем обозначать <span class="regn">RN</span> (это может быть любой 
	из РОН, однако использование в качестве операндов <span class="regn">SP</span> 
	и <span class="regn">PC</span> может иметь некоторые особенности).</p>
	<ol>
		<li><b>Регистровая</b> адресация (иногда её называют ещё <b>регистровой 
		прямой</b>, в отличие от косвенной). Операндом является один из РОН. Пример:
		<pre>        <span class="cmds">MOV</span>     <span class="regn">R2</span>,<span class="regn">R4</span>                <span class="cmmnt">;Переслать (скопировать)</span>
                                     <span class="cmmnt">; содержимое R2 в R4</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                   <span class="cmmnt">; Очистить (обнулить) R2</span>
        <span class="cmds">MOV</span>     <span class="regn">R4</span>,<span class="regn">SP</span>                <span class="cmmnt">; Переслать содержимое R4 в SP</span></pre>
		<p>Это самый простой способ адресации и, очевидно, в дальнейших пояснениях 
		он не нуждается.</p>
		</li>
		<li><b>Регистровая косвенная</b> адресация. В РОН содержится не само число, 
		с которым нужно работать, а <b>его адрес</b>, т.е. номер ячейки памяти, 
		в которой оно находится. Обозначение: @<span class="regn">RN</span> или 
		(<span class="regn">RN</span>). Значок &laquo;@&raquo; - это так называемое &laquo;<i>коммерческое 
		ЭТ</i>&raquo;, название длинное и труднопроизносимое, поэтому в программистском 
		жаргоне его заменяет не слишком благозвучное, но зато удобное наименование &laquo;<i>собачка</i>&raquo;. 
		Обозначения @<span class="regn">RN</span> и (<span class="regn">RN</span>) 
		абсолютно равнозначны, но лучше всё же писать @<span class="regn">RN</span>, 
		чтобы не путать его с адресацией с инкрементом или декрементом, о которых 
		речь пойдёт ниже. Примеры:
		<ol>
			<li>пусть в регистре <span class="regn">R2</span> записано число
			<span class="nmbr">1000</span>, тогда команда <span class="cmds">CLR</span> 
			@<span class="regn">R2</span> обнулит ячейку <span class="nmbr">1000</span> 
			(ту, адрес которой указан в <span class="regn">R2</span>);</li>
			<li>пусть в <span class="regn">R2</span> записано число
			<span class="nmbr">1000</span>, а по адресу <span class="nmbr">1000</span> 
			- число <span class="nmbr">1254</span>. Тогда <span class="cmds">MOV</span> 
			@<span class="regn">R2</span>,<span class="regn">R4</span> запишет в
			<span class="regn">R4</span> число <span class="regn">
			<span class="nmbr">1254</span></span>, ведь именно его адрес указан 
			в <span class="regn">R2</span>.</li>
		</ol>
		</li>
		<li><b>Автоинкрементная косвенная</b> адресация. Помимо основного действия 
		(косвенного обращения к ячейке памяти) производится изменение (<b>модификация</b>) 
		адреса этого обращения (ячейки). Слово &laquo;<b>инкремент</b>&raquo; означает 
		увеличение чего-либо, в данном случае адреса ячейки памяти, к которой мы 
		обращаемся (содержимого регистра, служащего указателем адреса). А &laquo;<b>авто</b>&raquo; 
		- это указание на то, что данное увеличение происходит само, не требуя отдельной 
		команды. Обозначение: (<span class="regn">RN</span>)+. То, что знак &laquo;+&raquo; 
		стоит <b>после</b> имени регистра, указывает на порядок выполнения команды: 
		сначала что-то делается с ячейкой, адрес которой помещён в регистр
		<span class="regn">RN</span>, а потом содержимое регистра увеличивается. 
		На сколько - зависит от формы оператора: если он работает с байтом (т.е. 
		записан с буквой &laquo;<span class="cmds">В</span>&raquo;), то на
		<span class="nmbr">1</span> (переход к адресу следующего байта), а если 
		со словом, то на <span class="nmbr">2</span> (переход к адресу следующего 
		слова). Но из этого правила есть исключение: если в качестве указателя адреса 
		используется регистр <span class="regn">SP</span> (адресуются ячейки стека), 
		то автоинкремент делается <b>только на два</b>, независимо от формы оператора 
		(то же относится и к регистру <span class="regn">PC</span>, но адресация 
		через <span class="regn">PC</span> - особая тема для разговора).
		<p>Пример: пусть в регистре <span class="regn">R2</span> записано число
		<span class="nmbr">1000</span>. Тогда команда <span class="cmds">CLR</span> 
		(<span class="regn">R2</span>)+ очистит <b>слово</b> по адресу
		<span class="nmbr">1000</span>, а содержимое регистра <span class="regn">
		R2</span> станет равно <span class="nmbr">1002</span>. Если затем выполнить 
		команду <span class="cmds">CLRB</span> (<span class="regn">R2</span>)+, 
		то очистится <b>байт</b> по адресу <span class="nmbr">1002</span> (младший 
		байт слова), а содержимое <span class="regn">R2</span> станет равно
		<span class="nmbr">1003</span> (<span class="regn">R2</span> указывает на 
		старший байт).</p>
		<p>Данный способ адресации обычно применяется для работы с массивами слов 
		или байтов. Если записать в регистр начальный адрес массива, а затем выполнить 
		команду с автоинкрементной адресацией столько раз, сколько элементов в массиве, 
		то команда (одна и та же, выполняемая, например, в цикле) каждый раз будет 
		работать со следующим элементом - обнулять его, пересылать куда-либо и т.п. 
		Если оператор имеет два операнда, как, например, <span class="cmds">MOV</span>, 
		то автоинкрементную адресацию можно использовать для каждого из них. Пусть 
		в <span class="regn">R2</span> записано число <span class="nmbr">1000</span>, 
		а в <span class="regn">R4</span> - <span class="nmbr">2000</span>. Тогда 
		команда <span class="cmds">MOV</span> (<span class="regn">R2</span>)+,(<span class="regn">R4</span>)+ 
		перешлёт содержимое ячейки <span class="nmbr">1000</span> в ячейку
		<span class="nmbr">2000</span>, после чего числа в <span class="regn">R2</span> 
		и <span class="regn">R4</span> будут равны соответственно
		<span class="nmbr">1002</span> и <span class="nmbr">2002</span>.</p>
		<p>Отдельный, &laquo;<i>хитрый</i>&raquo;, случай - автоинкремент регистра
		<span class="regn">PC</span>. Пусть, например, после команды хранится некоторая 
		константа</p>
		<pre>        <span class="cmds">MOV</span>     (<span class="regn">PC</span>)+,<span class="regn">R4</span>
        &lt;<b>константа</b>&gt;</pre>
		<p>Что произойдёт? &lt;<b>константа</b>&gt; запишется в регистр
		<span class="regn">R4</span>, ведь в момент исполнения команды в
		<span class="regn">PC</span> содержится адрес следующей команды, т.е. числа &lt;<b>константа</b>&gt;! 
		А затем <span class="regn">PC</span> увеличится на <span class="nmbr">2</span>, 
		т.е. управление будет передано уже на <b>следующую</b> после константы команду.</p>
		</li>
		<li><b>Автоинкрементная двойная косвенная</b> адресация. Этот способ не 
		слишком отличается от предыдущего, только в регистре-указателе при этом 
		содержится не адрес числа, с которым должен работать оператор, а <b>адрес 
		адреса</b>. Обозначение: @(<span class="regn">RN</span>)+.
		<p>Пример: пусть в ячейке <span class="nmbr">1000</span> записано число
		<span class="nmbr">1254</span>, а по адресу <span class="nmbr">1254</span> 
		- число <span class="nmbr">3333</span>. Тогда, если в <span class="regn">
		R2</span> хранится число <span class="nmbr">1000</span>, то команда
		<span class="cmds">MOV</span> @(<span class="regn">R2</span>)+,<span class="regn">R4</span> 
		перешлёт в <span class="regn">R4</span> число <span class="nmbr">3333</span>, 
		а содержимое регистра <span class="regn">R2</span> станет равным
		<span class="nmbr">1002</span>.</p>
		<p>Данный способ применяется относительно редко, но тем не менее он очень 
		ценен, так как позволяет работать, например, с таблицами адресов. Пусть 
		каждый элемент таблицы (а) является адресом одного из элементов таблицы 
		(б). Данная адресация позволяет, &laquo;<i>двигаясь</i>&raquo; по элементам 
		первой таблицы, проверять элементы второй, порядок следования которых может 
		быть произвольным (не совпадать с порядком следования их адресов).</p>
		</li>
		<li><b>Автодекрементная косвенная</b> адресация. Если сообщить, что &laquo;<b>декремент</b>&raquo; 
		означает <b>уменьшение</b> чего либо, то этот способ будет почти понятен, 
		не правда ли? У него только два отличия от автоинкрементной косвенной адресации: 
		во-первых, адрес в регистре-указателе не увеличивается, а уменьшается; во-вторых, 
		это происходит не <b>после</b> выполнения команды, а <b>до</b> неё, на что 
		указывает запись -(<span class="regn">RN</span>), в которой знак &laquo;-&raquo; 
		стоит перед обозначением регистра. В остальном же сходство с автоинкрементным 
		способом полное, включая то, что при операциях с байтом модификация числа 
		в регистре делается на <span class="nmbr">1</span>, а со словом - на
		<span class="nmbr">2</span>, и что регистр <span class="regn">SP</span> 
		всегда модифицируется только на <span class="nmbr">2</span>.
		<p>Пример: пусть в регистре <span class="regn">R2</span> записано число
		<span class="nmbr">1002</span>. Тогда команда <span class="cmds">CLR</span> 
		-(<span class="regn">R2</span>) очистит ячейку <span class="nmbr">1000</span> 
		(ту, адрес которой на <span class="nmbr">2</span> меньше, чем записанное 
		в регистре число), а содержимое регистра после операции, естественно, окажется 
		равным тоже <span class="nmbr">1000</span> - оно стало таким ещё <b>до</b> 
		очистки ячейки. Видимо, дальнейших примеров не требуется, по аналогии с 
		автоинкрементным способом всё и так ясно. Этот способ позволяет делать, 
		в общем, то же, что и автоинкрементный, но при работе с массивом его просмотр 
		или пересылка производится &laquo;<i>с конца</i>&raquo;, а перед началом 
		операции в регистре должен быть записан адрес следующей за последним элементом 
		массива ячейки.</p>
		<p>Однако этот способ позволяет делать и нечто более интересное - например, 
		перемещать числа в памяти. Пусть в <span class="regn">R2</span> записано 
		число <span class="nmbr">2004</span>, а по адресу <span class="nmbr">2002</span> 
		- число <span class="nmbr">1254</span>. Тогда команда <span class="cmds">
		MOV</span> -(<span class="regn">R2</span>),-(<span class="regn">R2</span>) 
		поместит число <span class="nmbr">1254</span> в ячейку
		<span class="nmbr">2000</span>, т.е. как бы &laquo;<i>передвинет</i>&raquo; 
		его в памяти с большего адреса на меньший. (Разумеется, по адресу
		<span class="nmbr">2002</span> число <span class="nmbr">1254</span> тоже 
		сохранится.) Как это произошло? Вначале содержимое <span class="regn">R2</span> 
		уменьшилось на <span class="nmbr">2</span>, став равным
		<span class="nmbr">2002</span>, и регистр указал на число
		<span class="nmbr">1254</span>. Теперь оно должно быть записано по адресу 
		второго операнда, но его указатель - тот же регистр, и опять вначале его 
		содержимое уменьшится на <span class="nmbr">2</span>, станет равно
		<span class="nmbr">2000</span>, а уже потом туда будет записано число. Нетрудно 
		догадаться, что таким способом можно &laquo;<i>сдвигать</i>&raquo; массивы 
		в памяти после удаления в середине какого-либо элемента (аналогичное применение 
		может найти и команда <span class="cmds">MOV</span> (<span class="regn">R2</span>)+,(<span class="regn">R2</span>)+).</p>
		</li>
	</ol>
	<p class="centr">★ ★ ★</p>
	<p>А теперь - маленькое развлечение и одновременно интересный пример по практике 
	использования автодекрементной адресации. Запишем команду <span class="cmds">
	MOV</span> -(<span class="regn">PC</span>),-(<span class="regn">PC</span>) (код
	<span class="nmbr">14747</span>). Для большего эффекта поместим её в старшие 
	адреса ОЗУ, в ячейку <span class="nmbr">77776</span> (с помощью директив МСД 
	это делается просто и безо всякого ассемблера: <span class="nmbr">77776</span><span class="var">А</span><span class="nmbr">14747</span><span class="var">И</span>), 
	а затем передадим на неё управление (запустим &laquo;<i>программу</i>&raquo; 
	по адресу этой команды: <span class="nmbr">77776</span><span class="var">G</span>) 
	Что случилось? Экран мгновенно стал &laquo;<i>полосатым</i>&raquo;, а ЭВМ... 
	Она &laquo;<i>мертва</i>&raquo;: не отвечает на нажатие клавиш и даже на такое &laquo;<i>мощное 
	лечебное средство</i>&raquo;, как клавиша &laquo;<i>СТОП</i>&raquo;, никак не 
	реагирует! Только системный сброс (или выключение, а затем включение питания) &laquo;<i>приводит 
	её в чувство</i>&raquo;. Что же это за &laquo;<i>бомба</i>&raquo;, которая мгновенно 
	парализовала все средства ЭВМ?</p>
	<p>После запуска в регистре <span class="regn">PC</span> содержится адрес следующей 
	команды - число <span class="nmbr">100000</span>. При обращении к первому операнду 
	содержимое <span class="regn">PC</span> уменьшается на <span class="nmbr">2</span>, 
	давая адрес <span class="nmbr">77776</span>, а там записан код команды - число
	<span class="nmbr">14747</span>. А куда оно перепишется? По адресу второго операнда, 
	но перед этим содержимое <span class="regn">PC</span> уменьшится ещё на
	<span class="nmbr">2</span> и станет равно <span class="nmbr">77774</span>, 
	т.е. укажет уже на следующую (&laquo;<i>нижележащую</i>&raquo;) ячейку памяти. 
	А потом, раз теперь в регистре <span class="regn">PC</span> адрес
	<span class="nmbr">77774</span>, то туда и будет передано управление, а там 
	снова та же команда, тот же &laquo;<i>смертельный</i>&raquo; код! Команда как 
	бы &laquo;<i>размножается</i>&raquo; в памяти ЭВМ, причём со страшной скоростью: 
	чтобы заполнить собой всю память, ей достаточно всего лишь
	<span class="nmbr">0</span>.<span class="nmbr">2</span> секунды! А почему ЭВМ 
	отказывает? Это станет ясно, если вы вспомните, что в зоне адресов
	<span class="nmbr">0</span>...<span class="nmbr">777</span> размещается системная 
	область и стек ЭВМ, её &laquo;<i>собственная память</i>&raquo;. А если стереть 
	содержимое памяти любого &laquo;<i>существа</i>&raquo;, пусть даже такого простого, 
	как БК, это если не смерть, то безумие...</p>
	<p>Но что же это всё-таки за команда, зачем мы потратили на её разбор столько 
	времени, и для чего она может пригодиться? Вы, наверное, слышали о компьютерных 
	вирусах, но, возможно, ещё не встречались ни с одним из них. Так вот, позвольте 
	представить: <span class="cmds">MOV</span> -(<span class="regn">PC</span>),-(<span class="regn">PC</span>) 
	- простейший вирус (точнее, ещё не настоящий вирус, такие программы носят название &laquo;<i>червяк</i>&raquo;), 
	вызванное им &laquo;<i>заболевание</i>&raquo; развивается молниеносно и, безусловно, &laquo;<i>смертельно</i>&raquo;. 
	Эта команда уничтожает всю информацию, хранимую в ОЗУ по адресам, меньшим, чем 
	адрес самой команды. А зачем может понадобиться такая страшная команда? Существует 
	ряд случаев, когда нужно срочно уничтожить хранимую в ОЗУ информацию. Например, 
	чтобы в написанной вами игре после запуска разрешалось только определённое число 
	попыток, а потом её нужно было снова загружать с МЛ (что затруднит нахождение 
	решений), поместите в любом месте программы этот вирус и, когда число попыток 
	исчерпано, заставьте его &laquo;<i>ожить</i>&raquo; (такой &laquo;<i>до поры 
	до времени спящий</i>&raquo; вирус носит название &laquo;<i>троянский конь</i>&raquo;). 
	Сложнее, но тоже возможно реализовать активизацию вируса, например, по истечении 
	заданного времени, после определённого числа копирований программы на МЛ (если 
	она имеет встроенный копировщик) или при попытке что-либо изменить в программе. 
	(Известно, что &laquo;<i>настоящие</i>&raquo; вирусы на IBM-совместимых компьютерах 
	были изначально созданы для наказания &laquo;<i>компьютерных воришек</i>&raquo;, 
	взламывающих защиты от копирования. - <em>Прим. ред.</em>) Как видим, даже вирусы 
	можно заставить работать с пользой. Но это ещё не всё. Изучая вирусы, создавая 
	их и борясь с ними, программисты совершенствуются уже не в ремесле, а в искусстве. 
	Последнее тоже приносит пользу, хотя отнюдь не перекрывает вред, приносимый 
	вирусами. (Рассуждения о полезности вирусов составляют личное мнение автора 
	статьи. На наш взгляд, написание вирусов можно рассматривать скорее как хулиганство 
	и стремление напакостить всем без исключения (ведь вирус &laquo;<i>бьёт</i>&raquo; 
	бесприцельно!). Учиться же программировать лучше на других, не менее интересных 
	и полезных, но безвредных вещах. - <em>Прим. ред.</em>)</p>
	<p>Ещё одно применение тот же принцип - &laquo;уничтожай, размножаясь&raquo; 
	- находит в оригинальной компьютерной игре &laquo;<i>бой в памяти</i>&raquo;: 
	в ОЗУ загружаются специальные &laquo;<i>боевые программы</i>&raquo;, и особый 
	монитор попеременно передаёт им управление, разрешая делать по нескольку &laquo;<i>ходов</i>&raquo; 
	по очереди. Цель - &laquo;<i>вывести из строя</i>&raquo; программу противника. 
	Эта игра была очень популярна среди программистов и любителей за рубежом несколько 
	лет назад, но сейчас интерес к ней значительно упал. (О том, как реализовать 
	на БК подобный &laquo;<i>многопрограммный режим</i>&raquo; с параллельной работой 
	нескольких программ, можно прочитать в журнале &laquo;<i>Информатика и образование</i>&raquo; 
	№<span class="nmbr">2</span> за <span class="nmbr">1992</span> г. - <em>Прим. 
	ред.</em>)</p>
	<p class="centr">★ ★ ★</p>
	<ol start="6">
		<li><b>Автодекрементная двойная косвенная</b> адресация. Обозначение: @-(<span class="regn">RN</span>). 
		Если сделать уже известные нам поправки, что декремент - это уменьшение, 
		и выполняется оно ДО обращения к ячейке, на которую указывает операнд, то 
		из автоинкрементной двойной косвенной адресации легко получается автодекрементная. 
		Далее, не детализируя, приведём пример. Пусть в регистре
		<span class="regn">R2</span> записано число <span class="nmbr">1002</span>, 
		по адресу <span class="nmbr">1000</span> - число <span class="nmbr">1254</span>, 
		а по адресу <span class="nmbr">1254</span> - <span class="nmbr">3333</span>. 
		Тогда команда <span class="cmds">MOV</span> @-(<span class="regn">R2</span>),<span class="regn">R4</span> 
		запишет в <span class="regn">R4</span> число <span class="nmbr">3333</span>. 
		Данный способ может быть применён для тех же целей, что и автоинкрементная 
		двойная косвенная адресация, но даёт возможность, скажем, просматривать 
		таблицу адресов с конца.
		<p>Отметим, что такого, казалось бы, логичного способа как &laquo;<i>двойная 
		косвенная адресация</i>&raquo;, записать которую можно было бы, например, 
		как @(<span class="regn">RN</span>), не существует. А жаль - он бы тоже 
		мог пригодиться... Но ещё не всё потеряно, мы можем &laquo;<i>обмануть</i>&raquo; 
		ассемблер и всё-таки задать адресацию таким образом! Как именно - увидим 
		позже.</p>
		<p>Кроме того, заметим, что все ранее рассмотренные способы адресации &laquo;<i>вписывались</i>&raquo; 
		в формат самой команды, и, таким образом, она при переводе в машинный код 
		занимала одно слово. Способы, описываемые ниже, таким преимуществом не обладают. 
		Они требуют задания некоторых дополнительных параметров, в формат одного 
		слова никак не укладывающихся. Такие команды занимают два, а то и три машинных 
		слова, однако потеря объёма памяти компенсируется ещё большей гибкостью 
		и универсальностью средств программирования на ассемблере. Но прежде чем 
		перейти к описанию этих способов адресации, введём ещё два общих обозначения:
		<span class="var">X</span> - восьмеричное число, <span class="labl">MET</span> 
		- произвольное имя метки.</p>
		</li>
		<li><b>Индексная</b> адресация. Это разновидность косвенной адресации через 
		регистр. Обозначение: <span class="var">X</span>(<span class="regn">RN</span>) 
		или <span class="labl">MET</span>(<span class="regn">RN</span>). Стоящее 
		перед регистром восьмеричное число <span class="var">X</span> или имя метки
		<span class="labl">MET</span> называется <b>индексом</b>, указывает <b>смещение</b> 
		от адреса, содержащегося в регистре, и заносится при трансляции вторым или 
		третьим словом команды. Восьмеричное число может быть записано как без знака, 
		так и (в последних версиях ассемблеров) со знаком &laquo;-&raquo; (в этом 
		случае при трансляции оно автоматически переводится в дополнительный код). 
		Вместо имени метки ассемблер тоже подставляет число - её абсолютный адрес, 
		полученный в результате трансляции и компоновки. Адрес же ячейки, к которой 
		мы обращаемся, при данном способе адресации определяется как сумма смещения 
		(индекса) и содержимого регистра <span class="regn">RN</span> (так называемой
		<b>базы</b>). Пример: пусть в регистре <span class="regn">R2</span> записано 
		число <span class="nmbr">2000</span>, тогда команда <span class="cmds">CLR</span>
		<span class="nmbr">1000</span>(<span class="regn">R2</span>) обнулит слово 
		по адресу <span class="nmbr">3000</span>, а <span class="cmds">CLR</span> 
		-<span class="nmbr">1000</span>(<span class="regn">R2</span>) -слово по 
		адресу <span class="nmbr">1000</span>.
		<p>Этот способ может быть использован, если при одном и том же содержимом 
		регистра, которое нежелательно почему-либо изменять, нужно выполнить действия 
		с несколькими ячейками, отстоящими от заданного в регистре адреса на некоторые 
		фиксированные &laquo;<i>расстояния</i>&raquo;. Например, если задать в
		<span class="regn">R2</span> адрес какого-либо байта экранного ОЗУ, то команда
		<span class="cmds">CLRB</span> <span class="nmbr">100</span>(<span class="regn">R2</span>) 
		очистит байт, находящийся в следующей телевизионной строке (под заданным), 
		а <span class="cmds">CLRB</span> <span class="nmbr">1200</span>(<span class="regn">R2</span>) 
		-байт, лежащий ниже на <span class="nmbr">10</span><sub>д</sub> строк.</p>
		<p>Ещё интереснее случай использования в качестве индекса имени метки. Предположим, 
		что нам нужно вместо заносимых в регистр <span class="regn">R2</span> чисел 
		(например <span class="nmbr">0</span>, <span class="nmbr">1</span>,
		<span class="nmbr">2</span>, ... <span class="nmbr">7</span>) подставить 
		значения <span class="nmbr">4</span>, <span class="nmbr">3</span>,
		<span class="nmbr">2</span>, <span class="nmbr">1</span>,
		<span class="nmbr">0</span>, <span class="nmbr">7</span>,
		<span class="nmbr">6</span> и <span class="nmbr">5</span> соответственно. 
		Эта задача называется <b>перекодировкой</b>. Можно решить её &laquo;<i>в 
		лоб</i>&raquo; - проверяя каждый раз содержимое регистра на соответствие
		<b>всем</b> значениям ряда по очереди. Но такой способ ужасно неэкономичен 
		как по времени, так и по занимаемому объёму ОЗУ (представьте, что возможных 
		кодов было бы <span class="nmbr">1000</span>). Лучше применить <b>табличный</b> 
		метод. Напишем программу, состоящую всего из одной (!) команды
		<span class="cmds">MOVB</span> <span class="labl">TAB</span>(<span class="regn">R2</span>),<span class="regn">R2</span> 
		и составим таблицу перекодировки, которая в нашем примере будет иметь вид:</p>
		<pre><span class="labl">TAB</span>: <span class="pscm">.B</span>:<span class="nmbr">4</span>,<span class="nmbr">3</span>,<span class="nmbr">2</span>,<span class="nmbr">1</span>,<span class="nmbr">0</span>,<span class="nmbr">7</span>,<span class="nmbr">6</span>,<span class="nmbr">5</span></pre>
		<p>(Забегая вперёд, поясним, что псевдокоманда <span class="pscm">.B</span>: 
		позволяет записать ряд чисел в последовательные байты памяти, начиная с 
		текущего адреса, в нашем случае - с адреса метки <span class="labl">TAB</span>.)</p>
		<p>Поставленная задача решена. Пусть, например, в регистре
		<span class="regn">R2</span> содержится число <span class="nmbr">3</span>. 
		Адрес первого операнда команды будет вычислен как сумма адреса метки
		<span class="labl">TAB</span> и содержимого регистра. Отсчитаем, начиная 
		с нуля, третий байт таблицы - это число <span class="nmbr">1</span>. Оно 
		и будет занесено вместо исходного числа <span class="nmbr">3</span> в регистр
		<span class="regn">R2</span> - перекодировка выполнена.</p>
		<p>Вообще же круг подобных задач весьма широк - от замены символов текста 
		(например, если набор символов, которые печатает принтер, ограничен или 
		их порядок в знаковой таблице не соответствует принятому в БК-0010) до вычисления 
		значений произвольной функции по её аргументу табличным методом. (Закодировав 
		значения синуса и косинуса для углов от <span class="nmbr">0</span> до
		<span class="nmbr">2</span>π с некоторым шагом, таким способом можно реализовать 
		вычисление координат точек окружности (или дуги) с заданным радиусом и, 
		соответственно, ассемблерную подпрограмму для её вычерчивания. - <em>Прим. 
		ред.</em>)</p>
		</li>
		<li><b>Индексная косвенная</b> адресация. Обозначение: @<span class="var">X</span>(<span class="regn">RN</span>) 
		или @<span class="labl">MET</span>(<span class="regn">RN</span>). По смыслу 
		она близка к предыдущей, но в ячейке, определяемой суммой индекса и содержимого 
		регистра, теперь находится не само число-операнд, а <b>его адрес</b>. С 
		таким явлением - двойной косвенностью - мы уже встречались, поэтому приводить 
		примеры не будем (читатель может придумать их сам), а лучше выполним данное 
		ранее обещание - покажем, как реализовать через регистр двойную косвенную 
		адресацию, которая в наборе команд ЭВМ &laquo;<i>официально</i>&raquo; не 
		существует. Как уже говорилось, логично было бы представить запись такой 
		адресации в виде @(<span class="regn">RN</span>), мы же вместо этого запишем 
		@<span class="nmbr">0</span>(<span class="regn">RN</span>) Цель достигнута 
		- мы обратились к ячейке с двойной косвенностью и без модификации содержимого 
		регистра-указателя. Правда, за этот &laquo;<i>обман</i>&raquo; придётся 
		платить - команда занимает целых два машинных слова, хотя содержимое второго 
		из них всего лишь нуль.
		<p>Индексная косвенная адресация применяется редко, но иногда без неё почти 
		невозможно обойтись. Например, когда нужно не просто перекодировать последовательность 
		чисел, а сравнить её с другой последовательностью (возможно, тоже перекодированной!). 
		С такой необходимостью вы непременно столкнётесь, если захотите написать 
		программу сортировки по алфавиту русских слов - ведь символы русского алфавита 
		в БК не упорядочены по возрастанию кодов.</p>
		</li>
		<li><b>Непосредственная</b> адресация. Этот способ позволяет в качестве 
		одного из операндов использовать число - константу, которая записывается 
		как #<span class="var">Х</span> или #<span class="labl">MET</span>. Значок &laquo;#&raquo;, 
		называемый на программистском жаргоне &laquo;<i>решёткой</i>&raquo;, в ассемблере 
		как раз и обозначает &laquo;<i>число</i>&raquo;. Восьмеричное число- операнд 
		может быть без знака или со знаком &laquo;-&raquo;, а имя метки ассемблер 
		при трансляции и компоновке заменяет на её абсолютный адрес, как и в двух 
		предыдущих способах. Полученный при этом числовой операнд записывается вторым 
		или третьим словом команды.
		<p>Ясно, что при этом способе часть команд, формально возможных, теряет 
		смысл. Например, практически бесполезна операция <span class="cmds">CLR</span> 
		#<span class="nmbr">1000</span>. Что мы тут можем обнулить? Только второе 
		слово самой команды, а зачем? Или, скажем, команда <span class="cmds">MOV</span> 
		#<span class="nmbr">1000</span>,#<span class="nmbr">2000</span>. Она всего 
		лишь перешлёт второе слово по адресу третьего. Трудно вообразить программу, 
		в которой это требуется... Но пора, наверное, перейти к примерам &laquo;<i>более 
		практического свойства</i>&raquo;. Пожалуйста:</p>
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">1000</span>,<span class="regn">R2</span>            <span class="cmmnt">; Запись в R2 числа 1000</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">40</span>,<span class="regn">R0</span>              <span class="cmmnt">; Запись в R0 числа 40</span></pre>
		<p>Обратим внимание, что во второй строке мы записываем число
		<span class="nmbr">40</span> в регистр <span class="regn">R0</span> с помощью &laquo;<i>байтовой</i>&raquo; 
		команды. Как это понимать, разве мы можем адресоваться не ко всему регистру, 
		а к его части? Да, можем. Если при регистровой адресации применена байтовая 
		команда, используется <b>младший</b> байт регистра. Раз так, то, казалось 
		бы, его старший байт при этом меняться не должен. Но не тут-то было! Если 
		с младшим байтом оперирует команда <span class="cmds">MOVB</span>, происходит 
		не всегда полезная вещь, называемая <b>распространением знака </b>- все 
		биты старшего байта регистра-приёмника (второго операнда) принимают значение 
		знакового разряда младшего байта (т.е. разряда <span class="nmbr">07</span>). 
		В приведённом примере (<span class="cmds">MOVB</span> #<span class="nmbr">40</span>,<span class="regn">R0</span>) 
		все разряды старшего байта <span class="regn">R0</span> обнулятся, даже 
		если мы не преследовали такой цели. Если выполнить команду
		<span class="cmds">MOVB</span> #<span class="nmbr">377</span>,<span class="regn">R0</span>, 
		в регистре <span class="regn">R0</span> окажется не <span class="nmbr">377</span>, 
		а <span class="nmbr">177777</span> (во все разряды старшего байта
		<span class="regn">R0</span> будут занесены единицы). А вот после
		<span class="cmds">MOV</span> #<span class="nmbr">377</span>,<span class="regn">R0</span> 
		в <span class="regn">R0</span> окажется число <span class="nmbr">377</span>, 
		как и следовало ожидать. Вообще же распространение знака возникает, если 
		число в младший байт регистра будет записано с применением любого способа 
		адресации в команде <span class="cmds">MOVB</span>. Это, видимо, единственный 
		случай, когда младший байт слова оказывает какое-то влияние на старший. 
		(Кроме &laquo;<i>явных</i>&raquo; ассемблерных команд: обмена местами старшего 
		и младшего байтов (<span class="cmds">SWAB</span>) и <b>небайтовых</b> команд 
		смещения вправо и влево (<span class="cmds">ASL</span>,
		<span class="cmds">ASR</span>, <span class="cmds">ROL</span> и
		<span class="cmds">ROR</span>). - <em>Прим. ред.</em>) При байтовых операциях 
		с ячейками ОЗУ такого, конечно же, не бывает.</p>
		<p>Продолжим примеры. Нижеследующая запись уже в какой-то степени напоминает 
		осмысленный текст программы:</p>
		<pre>        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R2</span>              <span class="cmmnt">; Запись адреса метки ТЕХ в R2</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">101</span>,(<span class="regn">R2</span>)+           <span class="cmmnt">; и запись в последовательные</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">102</span>,(<span class="regn">R2</span>)+           <span class="cmmnt">; ячейки памяти, начиная с метки</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">103</span>,(<span class="regn">R2</span>)+           <span class="cmmnt">; ТЕХ, чисел 101, 102 и 103</span>
                                     <span class="cmmnt">; (кодов символов &quot;А&quot;,&quot;В&quot;,&quot;С&quot;)</span></pre>
		<p>При написании программ часто приходится с помощью непосредственной адресации 
		засылать в регистры (реже - в ячейки памяти) коды символов (как это и сделано 
		в приведённом примере). Для этого их надо помнить наизусть, или, по крайней 
		мере, иметь под рукой таблицу кодов. Развитые версии ассемблеров (в том 
		числе, конечно, и <i>МИКРО.<span class="nmbr">10</span>К)</i> предоставляют 
		дополнительное удобство - возможность записи в качестве операндов самих 
		символов. Это тоже разновидность непосредственной адресации. Символы (они 
		могут быть любыми) должны быть заключены в апострофы, а их число не должно 
		быть больше двух.</p>
		<pre>        <span class="cmds">MOV</span>     '<span class="strn">a</span>',<span class="regn">R0</span>               <span class="cmmnt">;Примеры записи в регистр R0</span>
        <span class="cmds">MOV</span>     '<span class="strn">12</span>',<span class="regn">R0</span>              <span class="cmmnt">;кодов символов:</span>
        <span class="cmds">MOV</span>     '<span class="strn">A=</span>',<span class="regn">R0</span>              <span class="cmmnt">;&quot;а&quot;, &quot;1&quot; и &quot;2&quot;, &quot;А&quot; и &quot;=&quot;</span></pre>
		<p>Если при такой адресации в апострофах записан один символ, то его код 
		заносится в младший байт регистра (или ячейки памяти), если два - код первого 
		заносится в младший байт, а второго - в старший. (Коды, не имеющие символьного 
		представления, например перемещения курсора, управление выводом на дисплей 
		и т.д., приходится вводить &laquo;<i>по старинке</i>&raquo; - с помощью 
		#&lt;КОД&gt;. - <em>Прим. ред.</em>)</p>
		</li>
		<li><b>Абсолютная</b> адресация. Этот способ прост и прямолинеен: прямо 
		указывается абсолютный адрес ячейки памяти, к которой мы обращаемся. Обозначение: 
		@#<span class="cmds">Х</span>. Восьмеричное число <span class="cmds">X</span> 
		помещается при трансляции во второе или третье слово команды. Пример:
		<pre>        <span class="cmds">CLR</span>     @#<span class="nmbr">156</span>                <span class="cmmnt">; Очистка слова по адресу 156</span>
        <span class="cmds">CLRB</span>    @#<span class="nmbr">45</span>                 <span class="cmmnt">; Очистка байта по адресу 45</span>
        <span class="cmds">MOV</span>     @#<span class="nmbr">100112</span>,<span class="regn">R2</span>          <span class="cmmnt">; Запись содержимого слова </span>
                                     <span class="cmmnt">; по адресу 100112 в R2</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">137</span>,@#<span class="nmbr">1000</span>          <span class="cmmnt">; Запись числа 137 по адресу 1000</span></pre>
		<p>Данный способ достаточно широко применяется для обращения к ячейкам вне 
		самой программы, например по адресам системной области или ПЗУ. Обращаться 
		же к ячейкам, находящимся в ОЗУ пользователя (или тем более в самой программе), 
		удобнее с помощью <b>относительной</b> адресации.</p>
		</li>
		<li><b>Относительная</b> адресация. Этот способ является, пожалуй, самым 
		распространённым при задании адресов переходов и вызове подпрограмм (что 
		мы рассмотрим в своё время), а также при обращении к ячейкам памяти (переменным), 
		расположенным в ОЗУ пользователя, особенно в пределах самой программы. Обозначение:
		<span class="labl">MET</span>. При таком обращении ассемблер во время трансляции 
		вычисляет <b>смещение</b> (разность между адресами текущей команды и метки
		<span class="labl">MET</span>) и записывает это смещение вторым или третьим 
		словом команды. При исполнении программы адрес операнда определяется как 
		сумма текущего содержимого счётчика команд <span class="regn">PC</span> 
		и смещения. Последнее вычисляется в дополнительном коде с учётом знака, 
		поэтому такая адресация возможна как &laquo;<i>вперёд</i>&raquo;, так и &laquo;<i>назад</i>&raquo; 
		относительно текущей команды. Не вдаваясь в тонкости, которые больше волнуют 
		создателей ассемблер-систем, чем их пользователей, можно сказать, что относительная 
		адресация - это просто обращение к ячейке памяти, помеченной меткой
		<span class="labl">MET</span>. Для ассемблеров БК-0010, имеющих механизм 
		локальных меток, необходимо иметь в виду, что адресация (не только в этом, 
		но и во всех других случаях, когда в составе операндов употребляется имя 
		метки) возможна только с использованием обычных меток (начинающихся с буквы), 
		а локальные пригодны лишь для указания адресов переходов в операторах ветвления 
		и цикла. Это связано в основном с тем, что отличить локальную метку (начинающуюся 
		с цифры) от числа (например, индекса) ассемблер-система не может. Пример:
		<pre>        <span class="cmds">CLR</span>     <span class="labl">А1</span>                  <span class="cmmnt">; Адресация с использованием</span>
        <span class="cmds">MOV</span>     <span class="regn">R2</span>,<span class="labl">BR2</span>              <span class="cmmnt">; меток:</span>
        <span class="cmds">MOV</span>     <span class="labl">RGB</span>,(<span class="regn">R5</span>)+           <span class="cmmnt">; A1, BR2, RGB, TYP</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">377</span>,<span class="labl">TYP</span>
        <span class="cmds">MOVB</span>    <span class="labl">TYP</span>,<span class="regn">R4</span></pre>
		<p>Особо отметим, что метки, упоминаемые в операндах (при любом способе 
		адресации), должны быть <b>определены</b>, т.е. должны присутствовать в 
		тексте программы, помечая собой какие-либо строки (или же должны быть заданы
		<b>оператором прямого присваивания</b>, о котором речь пойдёт дальше). При 
		использовании имён неопределённых (отсутствующих) меток правильная компоновка 
		программы невозможна.</p>
		</li>
		<li><b>Относительная косвенная</b> адресация. Аналогична предыдущему способу, 
		но по адресу, определяемому меткой, находится не само число-операнд, а, 
		как обычно и случаях косвенной адресации, его <b>адрес</b>. Обозначение: 
		@<span class="labl">MET</span>. Применяется весьма редко, например для передачи 
		управления по адресу, который перед этим занесён в определённую ячейку памяти 
		(т.е. по значению переменной). Практически всегда этот способ адресации 
		может быть заменён на другой, (например регистровую косвенную адресацию), 
		по иногда он довольно удобен, так как не требует использования регистра.</li>
	</ol>
	<p class="centr">★ ★ ★</p>
	<p>На этом можно было бы считать изучение способов адресации законченным и в 
	заключение привести сводную таблицу по всем рассмотренным способам. Но сначала 
	сделаем заявление, на первый взгляд, противоречащее всему вышеизложенному: теоретически 
	возможных способов адресации всего восемь, в общем виде все они так или иначе 
	используют один из регистров общего назначения, т.е. являются разновидностями 
	регистровой адресации. Но позвольте, скажете вы, как же тогда быть с тем, что 
	мы рассмотрели <span class="nmbr">12</span> способов, и в четырёх последних 
	имена регистров вообще не фигурируют? Дело в том, что эти четыре способа являются 
	не самостоятельными, а лишь разновидностями первых восьми. Они выделены потому, 
	что имеют большое практическое значение, и по этой же причине в языке ассемблера 
	для них введены особые, &laquo;<i>нестандартные</i>&raquo; обозначения. Между 
	тем, смысл этих способов сводится к тому, что в качестве регистра-указателя 
	используется <span class="regn">R7</span> (или <span class="regn">PC</span>) 
	- счётчик команд. Проиллюстрируем это па примере. Как мы уже знаем, непосредственная 
	адресация обозначается как #<span class="var">Х</span>, где
	<span class="var">X</span> - число-операнд (для простоты не будем касаться меток). 
	Возьмём конкретную команду: <span class="cmds">MOV</span> #<span class="nmbr">1000</span>,<span class="regn">R2</span>. 
	При трансляции ассемблер заносит число <span class="nmbr">1000</span> во второе 
	слово. Но мы уже сталкивались с случаем, когда, применяя регистр
	<span class="regn">PC</span> и автоинкрементную адресацию, можно было прочитать 
	записанную после команды константу! Итак, непосредственная адресация - это вовсе 
	не новый метод, а всё тот же самый способ с автоинкрементом
	<span class="regn">PC</span>. И вместо <span class="cmds">MOV</span> #<span class="nmbr">1000</span>,<span class="regn">R2</span> 
	вполне можно записать:</p>
	<pre>        <span class="cmds">MOV</span>     (<span class="regn">PC</span>)+,<span class="regn">R2</span>
        <span class="pscm">.#</span><span class="nmbr">1000</span></pre>
	<p>(Здесь <span class="pscm">.#</span><span class="nmbr">1000</span> - это запись 
	числа <span class="nmbr">1000</span> по текущему адресу.)</p>
	<p>Совершенно так же можно &laquo;<i>развенчать</i>&raquo; и остальные три способа 
	- абсолютной, относительной и относительной косвенной адресации (предоставляем 
	это сделать читателю). Всё это всего лишь удобные приёмы записи текста программ 
	на языке ассемблера, частные случаи &laquo;<i>настоящих</i>&raquo; способов 
	адресации с использованием <span class="regn">PC</span>. Именно так мы их и 
	приведём в таблице.</p>
	<p>Основные способы адресации</p>
	<center>
	<table id="mcmd" class="border3">
		<tr>
			<th>
			<p>Номер (код)</p>
			</th>
			<th>
			<p>Наименование</p>
			</th>
			<th>
			<p>Обозначение</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p>Регистровая (прямая)</p>
			</td>
			<td>
			<p><span class="regn">RN</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Регистровая косвенная</p>
			</td>
			<td>
			<p>@<span class="regn">RN</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Автоинкрементная косвенная</p>
			</td>
			<td>
			<p>(<span class="regn">RN</span>)+</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
			<td>
			<p>Автоинкрементная двойная косвенная</p>
			</td>
			<td>
			<p>@(<span class="regn">RN</span>)+</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">4</span></p>
			</td>
			<td>
			<p>Автодекрементная косвенная</p>
			</td>
			<td>
			<p>-(<span class="regn">RN</span>)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">5</span></p>
			</td>
			<td>
			<p>Автодекрементная двойная косвенная</p>
			</td>
			<td>
			<p>@-(<span class="regn">RN</span>)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">6</span></p>
			</td>
			<td>
			<p>Индексная</p>
			</td>
			<td>
			<p><span class="var">X</span>(<span class="regn">RN</span>) или
			<span class="labl">MET</span>(<span class="regn">RN</span>)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p>Индексная косвенная</p>
			</td>
			<td>
			<p>@<span class="var">X</span>(<span class="regn">RN</span>) или @<span class="labl">MET</span>(<span class="regn">RN</span>)</p>
			</td>
		</tr>
	</table>
	</center>
	<p>Способы адресации с использованием <span class="regn">PC</span></p>
	<center>
	<table id="mcmd" class="border3">
		<tr>
			<th rowspan="2">
			<p>Код</p>
			</th>
			<th rowspan="2">
			<p>Наименование</p>
			</th>
			<th colspan="2">
			<p>Обозначение</p>
			</th>
		</tr>
		<tr>
			<th>
			<p>стандартное</p>
			</th>
			<th>
			<p>специальное</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Непосредственная</p>
			</td>
			<td>
			<p>(<span class="regn">PC</span>)+</p>
			</td>
			<td>
			<p>#<span class="var">Х</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
			<td>
			<p>Абсолютная</p>
			</td>
			<td>
			<p>@(<span class="regn">PC</span>)+</p>
			</td>
			<td>
			<p>@#<span class="var">Х</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">6</span></p>
			</td>
			<td>
			<p>Относительная</p>
			</td>
			<td>
			<p><span class="labl">MET</span>(<span class="regn">PC</span>)</p>
			</td>
			<td>
			<p><span class="labl">MET</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p>Относительная косвенная</p>
			</td>
			<td>
			<p>@<span class="labl">MET</span>(<span class="regn">PC</span>)</p>
			</td>
			<td>
			<p>@<span class="labl">MET</span></p>
			</td>
		</tr>
	</table>
	</center>
	<p>Как видим, действительно ничего принципиально нового в последних четырёх 
	способах адресации нет. Но их так называемая &laquo;<i>стандартная</i>&raquo; 
	запись для программистов на ассемблере выглядит в высшей степени необычно и 
	почти никогда не применяется.</p>
	<p>Можно ли &laquo;<i>изобрести</i>&raquo; ещё способы с использованием
	<span class="regn">PC</span>? Да, конечно. Но практического значения они не 
	имеют и потому или не применяются, или мы их используем, даже не задумываясь, 
	что у них есть столь &laquo;<i>именитые родичи</i>&raquo;, имеющие отдельные &laquo;<i>титулы</i>&raquo; 
	и &laquo;<i>гербы</i>&raquo;. Продемонстрируем такие &laquo;<i>открытия</i>&raquo;. 
	Допустим, мы по аналогии захотели создать способ с применением
	<span class="regn">PC</span>, имеющий код <span class="nmbr">0</span>. Что мы 
	получим? Например, <span class="cmds">MOV</span> <span class="regn">PC</span>,<span class="regn">R4</span>. 
	Что же тут нового? Или, скажем, код <span class="nmbr">1</span>:
	<span class="cmds">MOV</span> @<span class="regn">PC</span>,<span class="regn">R4</span> 
	- так мы просто запишем в <span class="regn">R4</span> код следующей команды. 
	Это нужно? Мягко говоря, не часто... Код <span class="nmbr">4</span>:
	<span class="cmds">MOV</span> -(<span class="regn">PC</span>),-(<span class="regn">PC</span>) 
	- вирус, с которым мы уже знакомы. И наконец, код <span class="nmbr">5</span>:
	<span class="cmds">MOV</span> @-(<span class="regn">PC</span>),<span class="regn">R4</span> 
	- эта команда перепишет в <span class="regn">R4</span>... число из ячейки с 
	адресом, равным коду текущей команды! Чепуха, и ничего более.</p>
	<h3><a name="toc_27"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Что будет записано в регистр <span class="regn">R0</span> командой
		<span class="cmds">MOV</span> <span class="regn">R1</span>,<span class="regn">R0</span>, 
		если в регистре <span class="regn">R1</span> содержится число
		<span class="nmbr">5555</span>?
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">5555</span>.</p>
			</li>
		</ul>
		</li>
		<li>Что будет записано в регистр <span class="regn">R5</span> последовательностью 
		команд:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">1000</span>,@#<span class="nmbr">2500</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">40000</span>,@#<span class="nmbr">1000</span>
        <span class="cmds">MOV</span>     @#<span class="nmbr">2500</span>,<span class="regn">R4</span>
        <span class="cmds">MOV</span>     <span class="regn">R4</span>,<span class="regn">R5</span>
        <span class="cmds">MOV</span>     @<span class="regn">R5</span>,<span class="regn">R5</span></pre>
		<ul id="ctrla">
			<li>
			<p>Число <span class="nmbr">40000</span>.</p>
			</li>
		</ul>
		</li>
		<li>Что будет записано в <span class="regn">R0</span> последовательностью 
		команд (считая, что метка <span class="labl">MET</span> определена и находится 
		в ОЗУ):
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">1000</span>,<span class="labl">MET</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">3402</span>,@#<span class="nmbr">1000</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">377</span>,@#<span class="nmbr">3400</span>
        <span class="cmds">MOV</span>     @<span class="labl">MET</span>,<span class="regn">R5</span>
        <span class="cmds">MOV</span>     -(<span class="regn">R5</span>),<span class="regn">R0</span></pre>
		<ul id="ctrla">
			<li>
			<p>Число <span class="nmbr">377</span>.</p>
			</li>
		</ul>
		</li>
		<li>Каким будет содержимое <span class="regn">R2</span> после выполнения 
		каждой из команд: <span class="cmds">MOVB</span> #<span class="nmbr">160</span>,<span class="regn">R2</span>;
		<span class="cmds">MOV</span> #<span class="nmbr">277</span>,<span class="regn">R2</span>;<span class="cmds">MOVB</span> 
		#<span class="nmbr">201</span>,<span class="regn">R2</span>? (Чтобы не ошибиться, &laquo;<i>нарисуйте</i>&raquo; 
		полученные числав двоичной форме, поразрядно.)
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">160</span>, <span class="nmbr">277</span>,
			<span class="nmbr">177601</span>.</p>
			</li>
		</ul>
		</li>
		<li>Команда <span class="cmds">MOV</span> -(<span class="regn">PC</span>),-(<span class="regn">PC</span>) &laquo;<i>саморазмножается</i>&raquo; 
		в ОЗУ в сторону младших адресов (&laquo;<i>вниз</i>&raquo; по памяти). Придумайте 
		команду, которая будет исполнять &laquo;<i>бег на месте</i>&raquo;, т.е. 
		переписывать свой код по своему же адресу и передавать себе управление.</li>
		<pre>        <span class="cmds">MOV</span>     -(<span class="regn">PC</span>),@<span class="regn">PC</span></pre>
		<li>Придумайте последовательность двух одинаковых команд, исполняющую &laquo;<i>бег 
		на месте</i>&raquo; (обязательно с использованием кодов обеих команд).</li>
		<pre>        <span class="cmds">MOV</span>     @<span class="regn">PC</span>,-(<span class="regn">PC</span>)
        <span class="cmds">MOV</span>     @<span class="regn">PC</span>,-(<span class="regn">PC</span>)</pre>
		<li>Придумайте команду, которая бы &laquo;<i>саморазмножалась</i>&raquo; 
		по памяти &laquo;<i>вверх</i>&raquo;.
		<ul id="ctrla">
			<li>
			<p>Такой команды нет.</p>
			</li>
		</ul>
		</li>
		<li>Что запишет в <span class="regn">R3</span> последовательность команд:
		<pre>        <span class="cmds">MOVB</span>    #<span class="nmbr">255</span>,<span class="regn">R0</span>
        <span class="cmds">CLR</span>     <span class="labl">MET</span>
        <span class="cmds">MOVB</span>    <span class="regn">R0</span>,<span class="labl">MET</span>
        <span class="cmds">MOV</span>     (<span class="regn">PC</span>)+,<span class="regn">R3</span>
<span class="labl">MET</span>:    <span class="cmds">CLR</span>     <span class="regn">R0</span></pre>
		<ul id="ctrla">
			<li>
			<p>Число <span class="nmbr">255</span>.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_28"></a>Оператор прямого присваивания. Выражения</h2>
	<p>После того, как изучены способы адресации, рассмотрим ещё два тесно примыкающих 
	к ним вопроса. Мы уже знаем, что метками в тексте программы помечаются некоторые 
	строки и что в процессе трансляции и компоновки метке присваивается текущий 
	адрес (т.е. адрес начала строки в которой она стоит). Но как быть, если имеется 
	в виду адрес в ПЗУ или в системной области? Может быть, в таких случаях придётся 
	ограничиться только абсолютной адресацией, прямо указывая адрес? Это не всегда 
	удобно, поэтому в ассемблере предусмотрен специальный механизм для <b>определения</b> 
	меток, так называемый <b>оператор прямого присваивания</b>. Он записывается 
	как <span class="labl">MET</span>=<span class="var">Х</span>, где
	<span class="var">X</span> - восьмеричное число без знака. Этот оператор нетранслируемый 
	(при трансляции он не преобразуется в машинный код, а только присваивает заданной 
	метке значение адреса <span class="var">X</span>, которое заносится в таблицу 
	меток и используется при дальнейшей трансляции и компоновке). Операторы прямого 
	присваивания принято размещать в начале каждого отдельного модуля программы.</p>
	<p>Что же можно определить с помощью этого оператора и для чего? Прежде всего, 
	особенности работы ассемблер-системы таковы (не будем вдаваться в подробные 
	объяснения, но сделано это для обеспечения перемещаемости программ), что обращение 
	по адресам системной области (<span class="nmbr">0</span> -
	<span class="nmbr">777</span>) и ПЗУ (<span class="nmbr">100000</span>-
	<span class="nmbr">177777</span>) возможно только с применением абсолютной адресации 
	или - косвенно - через регистр. Относительная адресация этих ячеек невозможна. 
	Вот эти-то абсолютные значения адресов и могут быть приравнены меткам с помощью 
	оператора прямого присваивания, причём при обращении по адресу определённой 
	таким образом метки адресация всё равно получается не относительная, а абсолютная. 
	С другой стороны, оператор прямого присваивания не может приравнять метке адрес, 
	лежащий в пределах ОЗУ пользователя - при трансляции и компоновке это обернётся 
	ошибкой. Пример (фрагмент листинга реальной программы - драйвера принтера):</p>
	<pre>        <span class="labl">REG</span>=<span class="nmbr">57</span>                      <span class="cmmnt">; Признак регистра</span>
        <span class="labl">CPR</span>=<span class="nmbr">256</span>                     <span class="cmmnt">; Копия порта</span>
        <span class="labl">POZ</span>=<span class="nmbr">374</span>                     <span class="cmmnt">; Позиция печати</span>
        <span class="labl">POR</span>=<span class="nmbr">177714</span>                  <span class="cmmnt">; Порт ввода-вывода</span>
       <span class="cmmnt"> ; Выход в Фокал или МСД</span>
        <span class="cmmnt">;..........</span>
        <span class="cmds">CLRB</span>    <span class="labl">REG</span>                 <span class="cmmnt">; Per. кот. сбросить</span>
        <span class="cmmnt">;..........</span>
        <span class="cmds">CLR</span>     <span class="labl">POZ</span>                 <span class="cmmnt">; Обнулить позицию</span>
        <span class="cmmnt">;..........</span>
        <span class="cmds">CLR</span>     <span class="labl">POR</span>                 <span class="cmmnt">; Очистить порт</span>
        <span class="cmmnt">;..........</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,<span class="labl">CPR</span>              <span class="cmmnt">; Запомнить символ</span></pre>
	<p>Здесь показано как определение меток в начале текста с помощью операторов 
	прямого присваивания, так и дальнейшее использование этих меток. Отметим, что 
	определённая таким способом метка может быть использована в составе команды 
	с любым методом адресации (не только относительным) и ведёт себя как обычная 
	переменная. Например, если бы мы записали <span class="cmds">MOV</span> #<span class="labl">POR</span>,<span class="regn">R4</span>, 
	то тем самым число <span class="nmbr">177714</span>, присвоенное метке
	<span class="labl">POR</span>, было бы записано в регистр <span class="regn">
	R4</span>.</p>
	<p>Развитые версии ассемблеров допускают адресацию операндов с помощью не только 
	меток, но и <b>выражений</b>, состоящих из <b>термов</b>. (Термами называются 
	входящие в состав выражения числа или символы, связанные знаками арифметических 
	операций &laquo;+&raquo; или &laquo;-&raquo;.) Количество термов в выражении 
	для большинства версий ассемблеров не должно превышать двух. Выражение записывается 
	как <span class="labl">MET</span>+<span class="var">Х</span> или
	<span class="labl">MET</span>-<span class="var">Х</span>. и в процессе трансляции 
	вычисляется его значение. Пример (адрес метки <span class="labl">ТЕХ</span> 
	равен <span class="nmbr">1100</span>):</p>
	<pre>        <span class="cmds">CLR</span>     <span class="labl">TEX</span>                  <span class="cmmnt">;Очистка ячейки 1100</span>
        <span class="cmds">CLR</span>     <span class="labl">ТЕХ</span>+<span class="nmbr">100</span>              <span class="cmmnt">;Очистка ячейки 1200</span>
        <span class="cmds">CLR</span>     <span class="labl">ТЕХ</span>-<span class="nmbr">100</span>              <span class="cmmnt">;Очистка ячейки 1000</span></pre>
	<p>Аналогично можно задать операнды с помощью выражений и в других случаях, 
	например:</p>
	<pre>        <span class="cmds">CLR</span>     <span class="labl">MET</span>+<span class="nmbr">10</span>(<span class="regn">R2</span>)
        <span class="cmds">MOV</span>     #<span class="labl">MET</span>-<span class="nmbr">122</span>,<span class="regn">R2</span>
        <span class="cmds">CLRB</span>    @<span class="labl">MET</span>+<span class="nmbr">43</span></pre>
	<p>(При трансляции и компоновке вторым словом данных команд записывается результат 
	вычисления выражений.)</p>
	<h3><a name="toc_30"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Что запишется в регистр <span class="regn">R1</span> в результате выполнения 
		программы.
		<pre>        <span class="labl">MET</span>=<span class="nmbr">254</span>
        <span class="cmds">MOV</span>     #<span class="labl">MET</span>+<span class="nmbr">4</span>,<span class="regn">R0</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">155</span>,-(<span class="regn">R0</span>)
        <span class="cmds">MOVB</span>    @#<span class="nmbr">256</span>,<span class="regn">R1</span></pre>
		<ul id="ctrla">
			<li>
			<p>Число <span class="nmbr">155</span>.</p>
			</li>
		</ul>
		</li>
		<li>Какая ячейка будет обнулена в результате выполнения программы:
		<pre>        <span class="labl">MET</span>=<span class="nmbr">100</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">150</span>,<span class="regn">R0</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">1400</span>,<span class="labl">MET</span>+<span class="nmbr">156</span>
        <span class="cmds">CLR</span>     @<span class="labl">MET</span>+<span class="nmbr">6</span>(<span class="regn">R0</span>)</pre>
		<ul id="ctrla">
			<li>
			<p>Ячейка с адресом <span class="nmbr">1400</span>.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_31"></a>Операторы ассемблера</h2>
	<p>Операторы (команды) определяют, <b>что</b> программа должна делать и в какой 
	последовательности. Операторов в составе ассемблера много, и их можно классифицировать 
	по-разному. Самой простой и удобной для изложения, видимо, является классификация 
	по функциям:</p>
	<ul>
		<li>вычислительные операторы (одно- и двухоперандные),</li>
		<li>операторы управления программой,</li>
		<li>операторы управления машиной,</li>
		<li>прочие.</li>
	</ul>
	<p>При описании операторов мы будем приводить форму их записи в общем виде следующим 
	образом. Если оператор может работать и с байтами, и со словами, то дополнение 
	его имени для работы с байтами будет приводиться в скобках, например
	<span class="cmds">MOV</span>(<span class="cmds">B</span>) Если в составе команды 
	допустимы любые способы адресации, то операнды в общем виде будут обозначаться 
	как <span class="oprt">А</span>,<span class="oprt">В</span> (<span class="oprt">А</span> 
	- <b>операнд</b>-<b>источник</b>, в процессе работы команды не меняющийся, а
	<span class="oprt">В</span> - <b>операнд</b>-<b>приёмник</b>, куда заносится 
	результат операции). Если один и тот же операнд является и источником, и приёмником, 
	то обозначим его как <span class="oprt">АВ</span>. Если в процессе выполнения 
	команды содержимое операндов не меняется (оба они как бы являются источниками), 
	будем обозначать их <span class="oprt">А1</span>,<span class="oprt">А2</span> 
	Если операнд в составе команды используется только как адрес перехода, обозначим 
	его в общем виде как <span class="oprt">N</span>. Если же описываемый оператор 
	допускает не любые способы адресации, а лишь некоторые, это будет отмечаться 
	особо, причём для обозначения этих способов будут использоваться уже знакомые 
	нам символы <span class="regn">RN</span>, <span class="var">X</span>,
	<span class="labl">MET</span>.</p>
	<p>Перед тем как перейти к описанию конкретных операторов, кратко напомним, 
	что кроме восьми регистров общего назначения в составе процессора имеется ещё 
	один служебный регистр <span class="regn">PS</span> или регистр <b>слова состояния 
	процессора</b> (ССП), с которым вы уже знакомы. При описании операторов нас 
	будут интересовать <span class="nmbr">4</span> младших разряда (бита) ССП - 
	так называемые флаги <b>условий</b>. Вспомним, что они обозначаются буквами
	<span class="symb">N</span>, <span class="symb">Z</span>, <span class="symb">
	V</span>, <span class="symb">С</span> и значение каждого из них устанавливается 
	равным нулю или единице в зависимости от результата выполнения очередной команды. 
	Эти биты используются для реализации условных переходов и для некоторых других 
	целей. Их значение устанавливается равным единице в следующих случаях:</p>
	<ul>
		<li><span class="symb">N</span>=<span class="nmbr">1</span>, если результат 
		операции - отрицательное число;</li>
		<li><span class="symb">Z</span>=<span class="nmbr">1</span>, если результат 
		операции - ноль;</li>
		<li><span class="symb">V</span>=<span class="nmbr">1</span>, если при операции 
		произошло переполнение (т.е. перенос в знаковый разряд);</li>
		<li><span class="symb">С</span>=<span class="nmbr">1</span>, если при операции 
		произошёл перенос (т.е. выход единицы за пределы слова или байта).</li>
	</ul>
	<p>В противных случаях соответствующие биты ССП равны нулю.</p>
	<h3><a name="toc_32"></a>1. Вычислительные операторы</h3>
	<p>С одним операндом</p>
	<ul>
		<li><span class="cmds">CLR</span>(<span class="cmds">B</span>)
		<span class="oprt">В</span> - <b>очистка</b>. Обнуляет слово (байт) операнда, 
		записывая в него нуль, независимо от исходного содержимого. Используется 
		для обнуления (сброса) программных счётчиков, признаков, сумматоров, подготовки 
		ячеек и т.п.</li>
		<li><span class="cmds">COM</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>поразрядное инвертирование</b>. Все биты 
		операнда независимо друг от друга заменяются на противоположные (нуль на 
		единицу, а единица - на нуль). Пусть в регистре <span class="regn">R4</span> 
		записано число <span class="nmbr">1 011 101 100 111 000</span> (восьмеричное
		<span class="nmbr">135470</span>). После выполнения команды
		<span class="cmds">COM</span> <span class="regn">R4</span> в регистре
		<span class="regn">R4</span> будет записано <span class="nmbr">0 100 010 
		011 000 111</span> (восьмеричное <span class="nmbr">042307</span>).
		<p>Другое название данной операции - <b>дополнение до единицы</b>, так как 
		сумма исходного значения и результата операции во всех разрядах содержит 
		единицы: <span class="oprt">АВ</span>+<span class="cmds">COM</span>(<span class="oprt">АВ</span>)=<span class="nmbr">1 
		111 111 111 111 111</span>.</p>
		</li>
		<li><span class="cmds">INC</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>инкремент</b>. К операнду прибавляется
		<span class="nmbr">1</span>.</li>
		<li><span class="cmds">DEC</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>декремент</b> Из операнда вычитается
		<span class="nmbr">1</span>.
		<p>При исполнении операторов <span class="cmds">INC</span> и
		<span class="cmds">DEC</span>, а также некоторых других (<span class="cmds">ASR</span>,
		<span class="cmds">ROL</span>, <span class="cmds">ADD</span>,
		<span class="cmds">SUB</span> и пр.) может произойти перенос за пределы 
		слова или байта, например при выполнении последовательности команд:</p>
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R0</span>
        <span class="cmds">INC</span>     <span class="regn">R0</span></pre>
		<p>Однако флаг переноса (<span class="symb">С</span>-разряд) при этом <b>
		не устанавливается</b>, что необходимо учитывать при использовании данных 
		операторов вместе с операторами условного перехода.</p>
		</li>
		<li><span class="cmds">NEG</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>инверсия знака</b>. Число заменяется на 
		отрицательное, равное прежнему по абсолютной величине, но представленное 
		в дополнительном коде.
		<p>Другое название данной операции - <b>дополнение до двух</b>, так как 
		сумма исходного числа и результата равна нулю плюс перенос &laquo;<i>за 
		пределы</i>&raquo; слова (т.е. устанавливается флаг переноса):
		<span class="oprt">AB</span>+<span class="cmds">NEG</span>(<span class="oprt">AB</span>)=<span class="nmbr">0</span>+<b>перенос</b>.</p>
		<p>(При использовании оператора <span class="cmds">NEG</span>(<span class="cmds">B</span>) 
		значение <span class="nmbr">100000</span><sub>8</sub> заменяется самим собой, 
		так как в записи с дополнением до двух для наибольшего отрицательного числа
		<span class="nmbr">100000</span><sub>8</sub> нет соответствующего положительного 
		- <em>Прим. ред.</em>)</p>
		</li>
		<li><span class="cmds">TST</span>(<span class="cmds">B</span>)
		<span class="oprt">A</span> - <b>проверка содержимого операнда</b>. Операнд 
		при этом не изменяется, но биты условий ССП устанавливаются в соответствии 
		с его содержимым. Например, если операнд равен нулю, то устанавливается 
		в единицу бит <span class="symb">Z</span>, а если отрицателен, то
		<span class="symb">N</span>.</li>
	</ul>
	<p>Кроме проверки операнда оператор <span class="cmds">TST</span>(<span class="cmds">B</span>) 
	иногда применяется для инкремента (или декремента) содержимого регистра на
	<span class="nmbr">2</span>. Например, команда <span class="cmds">TST</span> 
	(<span class="regn">R2</span>)+ увеличивает на <span class="nmbr">2</span> содержимое
	<span class="regn">R2</span>, причём делает это быстрее, чем две команды
	<span class="cmds">INC</span> <span class="regn">R2</span>, и занимает в ОЗУ 
	всего одно слово. Однако при таком использовании данного оператора в регистре 
	должно быть записано число, соответствующее <b>реально существующему адресу 
	ЭВМ</b>. В противном случае, например если в регистре <span class="regn">R2</span> 
	записано число <span class="nmbr">177776</span> (не существующий в БК-0010 адрес), 
	произойдёт прерывание по зависанию. (Это замечание, конечно, относится к любой 
	команде, выполняемой по косвенному адресу, независимо от того, с какой целью 
	она применяется.) Необходимо также отметить, что на некоторых ЭВМ с аналогичной 
	системой команд косвенное обращение к <b>слову</b> по <b>нечётному</b> содержимому 
	регистра тоже ведёт к зависанию. На БК-0010 вместо этого производится обращение 
	по меньшему <b>чётному</b> адресу, т.е. адрес обращения корректируется. Содержимое 
	же регистра после такой операции (при автоинкрементной или автодекрементной 
	адресации), как обычно, изменяется на <span class="nmbr">2</span>, т.е. остаётся 
	нечётным.</p>
	<ul>
		<li><span class="cmds">ASL</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>арифметический сдвиг влево</b>. Слово 
		(или байт) операнда поразрядно сдвигается влево, старший разряд при этом 
		переписывается в бит <span class="symb">С</span> ССП, а в младший разряд 
		заносится ноль. Пусть, например, в регистре <span class="regn">R2</span> 
		записано слово <span class="nmbr">1 011 101 100 111 000</span> (восьмеричное
		<span class="nmbr">135470</span>). После выполнения команды
		<span class="cmds">ASL</span> <span class="regn">R2</span> получим:
		<span class="nmbr">0 111 011 001 110 000</span> (восьмеричное
		<span class="nmbr">073160</span>), разряд <span class="symb">С</span>=<span class="nmbr">1</span>.
		<p>Оператор <span class="cmds">ASL</span>(<span class="cmds">B</span>) применяется 
		для умножения на <span class="nmbr">2</span> и других целей.</p>
		</li>
		<li><span class="cmds">ASR</span>(<span class="cmds">B</span>)
		<span class="oprt">АВ</span> - <b>арифметический сдвиг вправо</b>. Слово 
		(или байт) операнда поразрядно сдвигается вправо, младший разряд при этом 
		переписывается в бит <span class="symb">С</span> ССП, старший разряд не 
		меняется (т.е. не меняется знак числа. - <em>Прим. ред.</em>). Пусть, например, 
		в регистре <span class="regn">R2</span> хранится слово
		<span class="nmbr">1 011 101 100 111 000</span> (восьмеричное
		<span class="nmbr">135470</span>). После выполнения команды
		<span class="cmds">ASR</span> <span class="regn">R2</span> получим:
		<span class="nmbr">1 101 110 110 011 100</span> (восьмеричное
		<span class="nmbr">156634</span>), разряд <span class="symb">С</span>=<span class="nmbr">0</span>
		<p>Оператор <span class="cmds">ASR</span>(<span class="cmds">B</span>) применяется 
		для деления на <span class="nmbr">2</span> и других целей.</p>
		</li>
		<li><span class="cmds">ROL</span>(<span class="cmds">B</span>)
		<span class="oprt">AB</span> - <b>циклический сдвиг влево</b>. Слово (или 
		байт) операнда поразрядно сдвигается влево, старший разряд при этом переписывается 
		в бит <span class="symb">С</span> ССП, а предшествующее содержимое последнего 
		переходит в младший разряд операнда. Слово или байт как бы замыкается при 
		этом в кольцо (причём замыкающим звеном является бит <span class="symb">
		С</span> ССП) и происходит <b>вращение</b> этого кольца на один разряд влево.</li>
		<li><span class="cmds">ROR</span>(<span class="cmds">B</span>)
		<span class="oprt">AB</span> - <b>циклический сдвиг вправо</b>. Слово (или 
		байт) операнда поразрядно сдвигается вправо, младший разряд при этом переписывается 
		в бит <span class="symb">С</span> ССП, а предшествующее содержимое
		<span class="symb">С</span> переходит в старший разряд операнда (аналогично 
		оператору <span class="cmds">ROL</span>(<span class="cmds">B</span>), но 
		с вращением в другую сторону).
		<p>Два последних оператора могут также применяться для поразрядной перезаписи 
		одного операнда в другой через <span class="symb">С</span>-разряд. Примеры:</p>
		<pre>        <span class="cmds">ROL</span>     <span class="regn">R2</span>                  <span class="cmmnt">; старший бит содержимого R2</span>
        <span class="cmds">ROR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; переносится в старший бит R4</span>
        <span class="cmds">ROL</span>     <span class="regn">R2</span>                 <span class="cmmnt"> ; старший бит R2</span>
        <span class="cmds">ROL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; переносится в младший бит R4</span>
        <span class="cmds">ROR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; младший бит R2</span>
        <span class="cmds">ROL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; переносится в младший бит R4</span>
        <span class="cmds">ROR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; младший бит R2</span>
        <span class="cmds">ROR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; переносится в старший бит R4</span></pre>
		<p>Выполняя такие сочетания команд подряд несколько раз, можно &laquo;<i>выворачивать 
		наизнанку</i>&raquo; слово или его часть, выделять нужное число разрядов 
		в другое слово и т.д.</p>
		</li>
		<li><span class="cmds">ADC</span>(<span class="cmds">B</span>)
		<span class="oprt">AB</span> - <b>прибавление разряда переноса</b>. К операнду 
		прибавляется содержимое бита <span class="symb">C</span> ССП. Применяется 
		для учёта переноса при сложении. умножении, вычислении контрольных сумм 
		и для других целей.</li>
		<li><span class="cmds">SBC</span>(<span class="cmds">B</span>)
		<span class="oprt">AB</span> - <b>вычитание разряда переноса</b>. Из операнда 
		вычитается содержимое бита <span class="symb">C</span> ССП. Применяется 
		для учёта переноса при вычитании, делении и для других целей.</li>
	</ul>
	<p>(Оператор <span class="cmds">ADC</span>(<span class="cmds">B</span>) может 
	быть использован для обеспечения многократной точности при сложении чисел:</p>
	<pre>        <span class="cmds">ADD</span>     <span class="labl">А0</span>,<span class="labl">B0</span>               <span class="cmmnt">; сложение младших частей</span>
        <span class="cmds">ADC</span>     <span class="labl">В1</span>                  <span class="cmmnt">; прибавить перенос к старшей части</span>
        <span class="cmds">ADD</span>     <span class="labl">А1</span>,<span class="labl">В1</span>               <span class="cmmnt">; сложение старших частей</span></pre>
	<p><span class="cmds">SBC</span>(<span class="cmds">B</span>) аналогично используется 
	для обеспечения многократной точности при вычитании:</p>
	<pre>        <span class="cmds">SUB</span>     <span class="labl">А0</span>,<span class="labl">B0</span>
        <span class="cmds">SBC</span>     <span class="labl">В1</span>
        <span class="cmds">SUB</span>     <span class="labl">A1</span>,<span class="labl">B1</span></pre>
	<p>В данном примере показано вычитание с двойной точностью. - <em>Прим. ред.</em>)</p>
	<ul>
		<li><span class="cmds">SWAB</span> <span class="oprt">АВ</span> - <b>перестановка 
		байтов</b>. Старший и младший байты операнда меняются местами. Применяется 
		для побайтного доступа к содержимому слова и для других целей.</li>
		<li><span class="cmds">SXT</span> <span class="oprt">АВ</span> - <b>расширение 
		знака</b>. Всем разрядам операнда (слова) присваивается значение знакового 
		разряда. В результате операции слово может стать равным или
		<span class="nmbr">0</span> (если исходное число положительное), или
		<span class="nmbr">177777</span> (если отрицательное). Применяется для операций 
		с плавающей запятой, учёта знака и для других целей.</li>
		<li><span class="cmds">MFPS</span> <span class="oprt">В</span> - <b>чтение 
		ССП</b>. Содержимое ССП записывается в операнд. О структуре ССП подробно 
		говорилось в разделе, посвящённом описанию центрального процессора. Применяется 
		этот оператор очень редко, в основном для сохранения текущего ССП с целью 
		его последующего восстановления или анализа. Сохранение и анализ ССП при 
		вызовах подпрограмм и прерываний, а также при условных переходах ЦП обычно 
		осуществляет автоматически, поэтому данная команда требуется только тогда, 
		когда обработка ССП отличается от стандартной.</li>
		<li><span class="cmds">MTPS</span> <span class="oprt">А</span> - <b>запись 
		ССП</b>. Слово-операнд записывается в ССП. Применяется чаще всего для задания 
		необходимого уровня приоритета, реже для восстановления ССП после нестандартного 
		преобразования. Нужно отметить, что команды <span class="cmds">MTPS</span> 
		и <span class="cmds">MFPS</span> являются <b>байтовыми</b>, при косвенной 
		автоинкрементной или автодекрементной адресации через регистр его содержимое 
		будет меняться на <span class="nmbr">1</span>, а не на
		<span class="nmbr">2</span>, а при записи содержимого ССП в регистр его 
		старший байт будет изменяться, как это описано ниже для команды
		<span class="cmds">MOVB</span>.</li>
	</ul>
	<p>С двумя операндами</p>
	<ul>
		<li><span class="cmds">MOV</span>(<span class="cmds">B</span>)
		<span class="oprt">A</span>,<span class="oprt">B</span> - <b>пересылка</b>. 
		Содержимое операнда <span class="oprt">А</span> записывается (копируется) 
		в операнд <span class="oprt">В</span>. Содержимое <span class="oprt">А</span> 
		не меняется, исходное значение <span class="oprt">B</span> теряется. Этот 
		оператор, особенности его работы и примеры были подробно рассмотрены раньше. 
		Напомним только, что при байтовой пересылке <span class="oprt">В</span>
		<b>регистр</b> в нём происходит <b>распространение знака</b> младшего байта 
		на весь старший байт (подробно этот эффект рассмотрен в одном из предыдущих 
		номеров журнала. - <em>Прим. ред.</em>). Оператор <span class="cmds">MOV</span> 
		- наиболее часто используемый из всех операторов ассемблера.</li>
		<li><span class="cmds">BIC</span>(<span class="cmds">B</span>)
		<span class="oprt">A</span>,<span class="oprt">B</span> - <b>очистка разрядов 
		по маске</b>. Во втором операнде обнуляются биты (разряды) по <b>маске первого</b>. 
		Смысл этого действия следующий: во втором операнде (слове или байте) устанавливаются 
		равными <b>нулю</b> те разряды, которым соответствуют <b>единицы</b> в первом 
		операнде. Пусть в регистре <span class="regn">R2</span> хранится слово
		<span class="nmbr">0 100 001 111 010 100</span>, а в регистре
		<span class="regn">R4</span> - <span class="nmbr">0 110 100 000 100 111</span>. 
		Выполнив команду <span class="cmds">BIC</span> <span class="regn">R2</span>,<span class="regn">R4</span>, 
		получим в регистре <span class="regn">R4</span> число <span class="nmbr">
		0 010 100 000 100 011</span> - биты <span class="regn">R4</span>, которым 
		соответствуют единицы в <span class="regn">R2</span>, обнулены, остальные 
		не изменились.
		<p>Ещё один пример. После выполнения команд</p>
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R4</span>
        <span class="cmds">BIC</span>     #<span class="nmbr">177400</span>,<span class="regn">R4</span></pre>
		<p>содержимое <span class="regn">R4</span> станет равно
		<span class="nmbr">377</span> (выделен младший байт <span class="regn">R4</span>).</p>
		<p>Оператор <span class="cmds">BIC</span>(<span class="cmds">В</span>) широко 
		применяется для выборочного стирания отдельных разрядов слова (байта) с 
		целью выделения нужных разрядов и т.п.</p>
		</li>
		<li><span class="cmds">BIS</span>(<span class="cmds">B</span>)
		<span class="oprt">A</span>,<span class="oprt">B</span> - <b>установка разрядов 
		по маске</b>. В отличие от предыдущего оператора, во втором операнде устанавливаются 
		в <b>единицу</b> те разряды, которым соответствуют <b>единицы</b> в первом. 
		Для тех же исходных данных, что в предыдущем примере, результатом выполнения 
		команды <span class="cmds">BIS</span> <span class="regn">R2</span>,<span class="regn">R4</span> 
		будет содержимое <span class="regn">R4</span>:<span class="nmbr">0 110 101 
		111 110 111</span>, а последовательность команд
		<pre>        <span class="cmds">CLR</span>     <span class="regn">R4</span>
        <span class="cmds">BIS</span>     #<span class="nmbr">377</span>,<span class="regn">R4</span></pre>
		<p>даст содержимое <span class="regn">R4</span>, равное
		<span class="nmbr">377</span>.</p>
		<p>Оператор <span class="cmds">BIS</span>(<span class="cmds">B</span>) широко 
		применяется для выборочной записи определённых разрядов, &laquo;<i>наложения</i>&raquo; 
		операндов и т.п.</p>
		</li>
		<li><span class="cmds">BIT</span>(<span class="cmds">B</span>)
		<span class="oprt">А1</span>,<span class="oprt">А2</span> - <b>проверка 
		битов по маске</b>. Проверяются биты (разряды) второго операнда по <b>маске 
		первого</b>. Оба операнда не меняются, но по результатам проверки устанавливаются 
		биты условий ССП. Смысл операции следующий. Если <b>хотя бы одному</b> разряду 
		первого операнда, равному <b>единице</b>, соответствует <b>единица</b> в 
		том же разряде второго операнда, результат <b>не нулевой</b>. Если же <b>
		всем единицам</b> первого операнда соответствуют только <b>нули</b> второго, 
		результат <b>нулевой</b>. Чаще всего оператор используется для проверки 
		какого-либо отдельного бита, для чего в первом операнде задаётся маска, 
		в которой присутствует только одна единица в соответствии с проверяемым 
		разрядом второго. Например, если нажата любая клавиша, в системном регистре
		<span class="nmbr">177716</span> разряд <span class="nmbr">06</span> будет 
		равен <span class="nmbr">0</span>, в противном случае - единице. Тогда для 
		выявления факта нажатия клавиши можно применить команду
		<span class="cmds">BIT</span> #<span class="nmbr">100</span>,<span class="nmbr">177716</span>. 
		Если клавиша нажата, результат исполнения команды равен нулю и наоборот.</li>
		<li><span class="cmds">CMP</span>(<span class="cmds">B</span>)
		<span class="oprt">А1</span>,<span class="oprt">А2</span> - <b>сравнение</b>. 
		Операнды сравниваются между собой и по результатам сравнения устанавливаются 
		биты условий ССП. Сами операнды при этом не меняются. Сравнение осуществляется 
		псевдовычитанием <b>второго</b> операнда из <b>первого</b>, т.е. как бы 
		осуществляется действие (<span class="oprt">А1</span>-<span class="oprt">А2</span>). 
		Например, если операнды равны, то результат операции - нуль (<span class="symb">Z</span>=<span class="nmbr">l</span>), 
		если второй операнд больше первого, то результат отрицательный (<span class="symb">N</span>=<span class="nmbr">1</span>) 
		и т.д. Оператор применяется очень широко как для сравнения операндов, так 
		и для инкремента (или декремента) регистров общего назначения, причём он 
		позволяет модифицировать содержимое регистра сразу на <span class="nmbr">
		4</span> (например <span class="cmds">CMP</span> (<span class="regn">R2</span>)+,(<span class="regn">R2</span>)+ 
		), ничего при этом не меняя, кроме содержимого <span class="regn">R2</span> 
		и битов условий, и занимая всего одно слово. Но необходимо помнить, что 
		биты условий при таком использовании не имеют никакого отношения к содержимому 
		регистра и обнаружить после такой команды, например, произошло ли переполнение
		<span class="regn">R2</span>, невозможно. Кроме того, содержимое регистра 
		должно указывать на реально существующий адрес, иначе произойдёт зависание.</li>
		<li><span class="cmds">ADD</span> <span class="oprt">А</span>,<span class="oprt">В</span> 
		- <b>сложение</b>. Содержимое операндов (слов) суммируется, результат записывается 
		во <b>второй</b> операнд, первый же при этом не меняется, т.е. выполняется 
		присваивание <span class="oprt">В</span>=<span class="oprt">В</span>+<span class="oprt">А</span>. 
		Операция широко применяется для сложения и умножения.</li>
		<li><span class="cmds">SUB</span> <span class="oprt">А</span>,<span class="oprt">В</span> 
		- <b>вычитание</b>. Из <b>второго</b> операнда вычитается <b>первый</b>, 
		результат записывается во <b>второй</b> операнд, первый не меняется, т.е. 
		выполняется присваивание <span class="oprt">В</span>=<span class="oprt">В</span>-<span class="oprt">А</span>. 
		Необходимо всегда помнить, что порядок вычитания в операторе
		<span class="cmds">SUB</span> (из второго - первый) обратен псевдовычитанию 
		в операторе <span class="cmds">CMP</span> (из первого - второй), это часто 
		путают. Оператор <span class="cmds">SUB</span> широко применяется для вычитания 
		и деления, иногда - для сравнения.</li>
		<li><span class="cmds">XOR</span> <span class="regn">RN</span>,<span class="oprt">B</span> 
		- <b>поразрядное</b> &laquo;<b>исключающее или</b>&raquo;. Выполняется логическая 
		функция &laquo;<i>исключающее или</i>&raquo; между соответствующими разрядами 
		(битами) первого и второго операндов, результат заносится во второй операнд. 
		Первый операнд может быть только регистром общего назначения, второй адресуется 
		любым способом.</li>
	</ul>
	<p>Что такое &laquo;<i>исключающее или</i>&raquo;? Это функция, фиксирующая 
	несовпадение битов, так называемая функция <b>неравнозначности</b>. Поясним 
	сказанное таблицей состояний.</p>
	<table id="cntr" class="border3">
		<tr>
			<th>
			<p><span class="nmbr">1</span>-й бит</p>
			</th>
			<th>
			<p><span class="nmbr">2</span>-й бит</p>
			</th>
			<th>
			<p>Результат</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
		</tr>
	</table>
	<p>Подобная операция выполняется между всеми разрядами операндов, в результате 
	чего получается число, содержащее не разность, а как бы разницу между ними. 
	Одинаковые операнды дают в результате ноль, взаимно-инверсные - число
	<span class="nmbr">177777</span>. Такая функция даёт возможность &laquo;<i>наслаивать</i>&raquo; 
	одно число на другое, например формировать на экране спрайты на фоне другого 
	изображения с сохранением последнего. Если вывести то же самое изображение с 
	помощью функции <span class="cmds">XOR</span> на то же место вторично, то оно 
	исчезнет, а фон восстановится. Аналогично можно &laquo;<i>наслаивать</i>&raquo; 
	звуки в многоголосных мелодиях, воспроизводимых одним динамиком, и т.п. Пусть 
	в <span class="regn">R2</span> записано число <span class="nmbr">0 101 110 111 
	001 011</span>, a в <span class="regn">R4</span> - <span class="nmbr">1 001 
	100 111 101 011</span>. Тогда после выполнения команды <span class="cmds">XOR</span>
	<span class="regn">R2</span>,<span class="regn">R4</span> в
	<span class="regn">R4</span> будет записано <span class="nmbr">1 100 010 000 
	100 000</span>.</p>
	<h3><a name="toc_33"></a>2. Операторы управления программой</h3>
	<p>Эта группа операторов предназначена для управления ходом вычислительного 
	процесса (организации ветвлений, подпрограмм и циклов).</p>
	<ul>
		<li><span class="cmds">BR</span> <span class="labl">MET</span> - <b>безусловное 
		ветвление</b>. Вызывает переход (передачу управления) по адресу
		<span class="labl">MET</span> независимо от битов условий. Метка, по которой 
		выполняется переход, может быть как обычной, так и локальной.</li>
	</ul>
	<p>Здесь, как и во всех других командах <b>ветвления</b>, адрес передачи управления 
	определяется суммой текущего значения счётчика команд <span class="regn">PC</span> 
	и младшего байта команды, в который при трансляции заносится разность (#<span class="labl">MET</span>-<span class="regn">PC</span>) 
	в дополнительном коде, делённая на <span class="nmbr">2</span>, - <b>смещение</b>. 
	При исполнении команды ветвления смещение умножается на <span class="nmbr">2</span> 
	с учётом знака и прибавляется к содержимому <span class="regn">PC</span>. Таким 
	образом обеспечивается передача управления на расстояние до
	<span class="nmbr">256</span><sub>д</sub> байт &laquo;<i>вперёд</i>&raquo; или &laquo;<i>назад</i>&raquo;, 
	считая от текущего адреса.</p>
	<p>Все остальные команды ветвления (кроме <span class="cmds">BR</span>) являются
	<b>условными</b>, т.е. передача управления по адресу <span class="labl">MET</span> 
	осуществляется, если биты условий, установившиеся после выполнения <b>предшествующей</b> 
	команды в разрядах <span class="nmbr">00</span>...<span class="nmbr">03</span> 
	ССП, удовлетворяют условиям оператора ветвления. В противном случае программа 
	выполняется дальше, а оператор ветвления игнорируется. Сами по себе операторы 
	ветвления <b>не меняют</b> биты условий, поэтому можно располагать их друг за 
	другом для последовательной проверки нескольких условий. Удобно привести все 
	операторы ветвления в виде таблицы:</p>
	<table id="mcmd" class="border3">
		<tr>
			<th>
			<p>Команда</p>
			</th>
			<th>
			<p>Условие ветвления</p>
			</th>
			<th>
			<p>Определяющие биты условий</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BNE</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>не равно нулю</p>
			</td>
			<td>
			<p><span class="symb">Z</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BEQ</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>равно нулю</p>
			</td>
			<td>
			<p><span class="symb">Z</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BPL</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>плюс</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BMI</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>минус</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BVC</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>нет переполнения</p>
			</td>
			<td>
			<p><span class="symb">V</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BVS</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>есть переполнение</p>
			</td>
			<td>
			<p><span class="symb">V</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BCC</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>нет переноса</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BCS</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>есть перенос</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td colspan="3">
			<p class="centr">...с учетом знака...</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BGT</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше нуля</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="symb">V</span> и
			<span class="symb">Z</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLT</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше нуля</p>
			</td>
			<td>
			<p><span class="symb">N</span> xor <span class="symb">V</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BGE</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="symb">V</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLE</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">N</span> xor <span class="symb">V</span>=<span class="nmbr">1</span> 
			или <span class="symb">Z</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BGT</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше нуля</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="symb">V</span> и
			<span class="symb">Z</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLT</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше нуля</p>
			</td>
			<td>
			<p><span class="symb">N</span> xor <span class="symb">V</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BGE</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">N</span>=<span class="symb">V</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLE</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">N</span> xor <span class="symb">V</span>=<span class="nmbr">1</span> 
			или <span class="symb">Z</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td colspan="3">
			<p class="centr">...без учета знака</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BHI</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше нуля</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">0</span> и
			<span class="symb">Z</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLO</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше нуля</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BHIS</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>больше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BLOS</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p>меньше или равно нулю</p>
			</td>
			<td>
			<p><span class="symb">C</span>=<span class="nmbr">1</span> или
			<span class="symb">Z</span>=<span class="nmbr">1</span></p>
			</td>
		</tr>
	</table>
	<p>Первые восемь операторов в особых пояснениях не нуждаются, они проверяют 
	отдельные биты условий. Операторы же <span class="cmds">BLO</span> и
	<span class="cmds">BHIS</span>, полностью совпадающие с <span class="cmds">BCS</span> 
	и <span class="cmds">BCC</span> соответственно, введены исключительно для удобства 
	программистов (дизассемблер обычно восстанавливает их только в виде
	<span class="cmds">BCS</span> и <span class="cmds">BCC</span>, не учитывая, 
	в какой форме они были записаны в исходном тексте). А вот вопрос о различии 
	в действии операторов переходов с учётом и без учёта знака нуждается в отдельном 
	рассмотрении.</p>
	<p>Как известно, числа со знаком изображаются в системе команд нашей ЭВМ в дополнительном 
	коде, т.е. старший бит числа является <b>знаковым</b> ноль, если число положительное, 
	и единица, если отрицательное. Диапазон абсолютных величин чисел со знаком, 
	естественно, меньше за счёт уменьшения разрядности на <span class="nmbr">1</span>. 
	Поэтому существует и второе представление - без знака, только для положительных 
	чисел, но с большей разрядностью. В связи с этим и возникают парадоксы при сравнении 
	чисел. Например, любое число без знака больше нуля. А со знаком - больше нуля 
	только положительные числа, отрицательные меньше. Это утверждение кажется банальным, 
	но при использовании операторов ветвления форму представления чисел обязательно 
	надо учитывать. Как правило, при логических операциях (сравнение кодов, сортировка 
	и т.п.) удобнее рассматривать числа без знака, а при арифметических вычислениях 
	- со знаком. Вообще же правильный выбор команд ветвления -довольно сложная задача, 
	и некоторые авторы не случайно рекомендуют сводить сравнение чисел к таким вариантам, 
	когда становится возможным применение лишь двух операторов -
	<span class="cmds">BNE</span> и <span class="cmds">BEQ</span>, которые всегда 
	действуют однозначно. Относясь к таким рекомендациям сочувственно, нужно всё-таки 
	ясно отдавать себе отчёт, что далеко не все задачи сводимы к частным вариантам, 
	а плата за такое преобразование велика - потеря памяти и быстродействия. Поэтому 
	следует применять все операторы ветвления, но тогда, когда это необходимо. А 
	чтобы не делать ошибок, нужно точно представлять себе, какой результат возможен 
	при той или иной операции, при тех или иных исходных данных, а не применять 
	операторы бездумно, по шаблону.</p>
	<p>Пример простейшей программы с использованием операторов ветвления:</p>
	<pre>        <span class="cmmnt">; &quot;мигание&quot; экрана</span>
<span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R0</span>           <span class="cmmnt">; В R0 все биты единичные</span>
<span class="locl">1</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>            <span class="cmmnt">; Начало экрана</span>
<span class="locl">2</span>:      <span class="cmds">MOV</span>     <span class="regn">R0</span>,(<span class="regn">R1</span>)+             <span class="cmmnt">; Запись очередного слова в ОЗУ</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">100000</span>,<span class="regn">R1</span>           <span class="cmmnt">; Конец экрана?</span>
        <span class="cmds">BNE</span>     <span class="locl">2</span>                    <span class="cmmnt">; Нет - продолжать</span>
        <span class="cmds">TST</span>     <span class="regn">R0</span>                   <span class="cmmnt">; R0 = 0 (цикл очистки)?</span>
        <span class="cmds">BEQ</span>     <span class="locl">0</span>                    <span class="cmmnt">; Да - записать единицы в R0</span>
        <span class="cmds">CLR</span>     <span class="regn">R0</span>                   <span class="cmmnt">; Иначе обнулить R0 и войти</span>
        <span class="cmds">BR</span>      <span class="locl">1</span>                    <span class="cmmnt">; в цикл очистки экрана</span>
        <span class="pscm">END</span></pre>
	<ul>
		<li><span class="cmds">JMP</span> <span class="oprt">N</span> - <b>безусловный 
		переход</b>. Эта команда, в отличие от безусловного ветвления
		<span class="cmds">BR</span>, передаёт управление по любому адресу, а не 
		только на <span class="nmbr">256</span><sub>д</sub> байт, и допускает задание 
		адреса перехода любым способом (есть, конечно, и исключения. Например, невозможна 
		передача управления на регистр - <span class="cmds">JMP</span>
		<span class="regn">RN</span>). Локальные метки в составе адреса перехода 
		не допускаются.</li>
		<li><span class="cmds">JSR</span> <span class="regn">RN</span>,<span class="oprt">N</span> 
		- <b>переход к подпрограмме</b>. По этой команде процессор прерывает обработку 
		текущей последовательности операторов, записывает в стек содержимое указанного 
		регистра <span class="regn">RN</span> (как бы автоматически выполняя команду
		<span class="cmds">MOV</span> <span class="regn">RN</span>,-(<span class="regn">SP</span>) 
		), переписывает в регистр <span class="regn">RN</span> содержимое
		<span class="regn">PC</span> (а там в этот момент записан адрес следующей 
		команды программы), а затем заносит в <span class="regn">PC</span> адрес 
		подпрограммы <span class="oprt">N</span> (способ его задания может быть 
		любым, с теми же ограничениями, что и для оператора <span class="cmds">JMP</span>), 
		вследствие чего следующей исполняется первая команда подпрограммы.</li>
	</ul>
	<p>В конце подпрограммы должна стоять <b>команда возврата</b> -
	<span class="cmds">RTS</span> <span class="regn">RN</span>, где
	<span class="regn">RN</span> - тот же самый регистр, что в операторе
	<span class="cmds">JSR</span>. По этой команде ЦП переписывает содержимое
	<span class="regn">RN</span> в <span class="regn">PC</span> (т.е. восстанавливает 
	адрес следующей за переходом к подпрограмме команды основной программы), затем 
	восстанавливает из стека содержимое <span class="regn">RN</span> (как бы автоматически 
	выполняя команду <span class="cmds">MOV</span> (<span class="regn">SP</span>)+,<span class="regn">RN</span>), 
	и выполнение основной программы продолжается. Из одной подпрограммы можно обратиться 
	к другой, из неё - к третьей и т.д. Важно лишь, чтобы используемый в качестве 
	буфера адреса возврата регистр (это может быть как один и тот же регистр для 
	всех вложенных подпрограмм, так и разные) во время работы подпрограммы не менял 
	своё содержимое (если, конечно, это не делается со специальными целями), иначе 
	правильный возврат из подпрограммы станет невозможен. Количество последовательных 
	обращений из одной подпрограммы в другую (так называемый <b>уровень вложенности</b>) 
	ограничен допустимой глубиной стека.</p>
	<p>Наиболее удобно использовать в качестве <span class="regn">RN</span> счётчик 
	команд <span class="regn">PC</span>. Если при этом проанализировать работу операторов
	<span class="cmds">JSR</span> и <span class="cmds">RTS</span>, то окажется, 
	что по команде <span class="cmds">JSR</span> <span class="regn">PC</span>,<span class="oprt">N</span> 
	в стеке сохраняется, а по команде <span class="cmds">RTS</span>
	<span class="regn">PC</span> восстанавливается непосредственно адрес возврата 
	из подпрограммы! Этот способ обращения к подпрограммам очень удобен тем, что 
	позволяет не занимать ни одного операционного регистра под адрес возврата, ведь 
	их и так не очень много. Понятно, что данный способ обращения к подпрограммам 
	используется чаще других, и для него в ассемблере &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	даже предусмотрена специальная форма записи: вместо <span class="cmds">JSR</span>
	<span class="regn">PC</span>,<span class="oprt">N</span> -
	<span class="cmds">CALL</span> <span class="oprt">N</span>, вместо
	<span class="cmds">RTS</span> <span class="regn">PC</span> -
	<span class="cmds">RET</span>. Наличие такой формы отнюдь не запрещает в &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	и стандартного обращения, просто такое - короче и удобнее.</p>
	<p>Входов в подпрограмму (как и выходов) может быть несколько, в зависимости 
	от разных условий, но всегда нужно помнить, что при входе в подпрограмму указатель 
	стека <span class="regn">SP</span> уменьшается на <span class="nmbr">2</span> 
	и при выходе из неё не оператором <span class="cmds">RTS</span> (<span class="cmds">RET</span>), 
	а иначе (например <span class="cmds">BR</span>, <span class="cmds">JMP</span> 
	и т.п.) стек необходимо восстанавливать. В противном случае он рано или поздно 
	будет исчерпан и ЭВМ перестанет работать. В самой же подпрограмме со стеком 
	следует работать осторожно и заботиться, чтобы при выходе из неё адрес возврата 
	находился в вершине стека.</p>
	<ul>
		<li><span class="cmds">RTS</span> <span class="regn">RN</span> - <b>возврат 
		из подпрограммы</b>. Подробно рассмотрен выше. В &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
		вместо <span class="cmds">RTS</span> <span class="regn">PC</span> может 
		использоваться оператор <span class="cmds">RET</span>.</li>
		<li><span class="cmds">MARK</span> <span class="var">X</span> - <b>пометить 
		стек</b>. Эта команда применяется крайне редко, может быть, потому что ни 
		в одном литературном источнике она не описана достаточно понятно. Попытаемся 
		восполнить этот пробел.</li>
	</ul>
	<p>Бывают случаи, когда при обращении к подпрограмме нужно передать ей ряд чисел 
	- <b>параметров</b>. Эти числа при каждом обращении к одной и той же подпрограмме 
	могут быть различными, и их может быть разное количество. В таких случаях довольно 
	удобно перед вызовом заносить параметры в стек, извлечь же их в подпрограмме 
	можно, например, с помощью индексной адресации или иным путём. Но так как параметров 
	может быть разное количество, то каждый раз по выходе из подпрограммы стек надо 
	восстанавливать. Команда <span class="cmds">MARK</span> делает это автоматически. 
	Как её применять?</p>
	<p>Сначала выберем один из регистров <span class="regn">RN</span> под буфер 
	адреса возврата и запишем его содержимое в стек. Какой регистр выбрать? В отличие 
	от общего случая применения команды <span class="cmds">JSR</span>
	<span class="regn">RN</span>, при использовании команды <span class="cmds">MARK</span> 
	в качестве регистра возврата может быть использован <b>только</b>
	<span class="regn">R5</span> - это заложено в ЦП аппаратно. Затем занесём в 
	стек <span class="var">X</span> параметров. После этого запишем в стек саму 
	команду в форме <span class="cmds">MARK</span> <span class="var">X</span>, где
	<span class="var">X</span> - количество параметров (восьмеричное число от
	<span class="nmbr">0</span> до <span class="nmbr">77</span>). Наконец, запишем 
	адрес вершины стека в <span class="regn">R5</span> и обратимся к подпрограмме 
	через другой регистр. Если в конце подпрограммы стоит команда
	<span class="cmds">RTS</span> <span class="regn">R5</span>, то стек и регистры 
	автоматически будут восстановлены. Не вдаваясь в дальнейшие подробности, просто 
	приведём пример. Регистром возврата выбран <span class="regn">R5</span> (напомним, 
	что только он и может быть выбран!), а обращение к подпрограмме пусть производится 
	через регистр <span class="regn">PC</span>. Занесём в стек три параметра:</p>
	<pre>        <span class="cmds">MOV</span>     <span class="regn">R5</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить R5</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">101</span>,-(<span class="regn">SP</span>)          <span class="cmmnt">; Занести параметры -</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">102</span>,-(<span class="regn">SP</span>)          <span class="cmmnt">; коды символов</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">103</span>,-(<span class="regn">SP</span>)          <span class="cmmnt">; &quot;А&quot;. &quot;В&quot; и &quot;С&quot;</span>
        <span class="cmds">MOV</span>     <span class="labl">MR3</span>,-(<span class="regn">SP</span>)           <span class="cmmnt">; Занести код команды MARK</span> <span class="cmmnt">3</span>
        <span class="cmds">MOV</span>     <span class="regn">SP</span>,<span class="regn">R5</span>               <span class="cmmnt">; Занести адрес возврата</span>
        <span class="cmds">CALL</span>    <span class="labl">SBR</span>                 <span class="cmmnt">; Перейти к подпрограмме SBR</span>
        <span class="cmmnt">;.........                  ; Дальнейший текст программы</span>
<span class="labl">SBR</span>:    <span class="cmmnt">;.........                  ; Текст подпрограммы SBR</span>
        <span class="cmds">RTS</span>     <span class="regn">R5</span>                  <span class="cmmnt">; Выход из подпрограммы</span>
                                    <span class="cmmnt">; с восстановлением стека</span>
<span class="labl">MR3</span>:    <span class="cmds">MARK</span>    <span class="nmbr">3</span>                   <span class="cmmnt">; Код команды MARK 3</span></pre>
	<p>Читатель, программирующий на ассемблере, может, конечно, предложить массу 
	других способов как для передачи параметров подпрограмме, так и для восстановления 
	стека без команды <span class="cmds">MARK</span>. Но поскольку данная команда 
	существует, разобрать её было необходимо хотя бы для того, чтобы избежать вопросов. 
	А применять её или нет - дело сугубо личное. Большинство программирующих на 
	ассемблере решают этот вопрос отрицательно и, может быть, правильно делают - 
	при программировании и так хватает забот, даже без использования столь сложной 
	по структуре и малоэффективной команды.</p>
	<ul>
		<li><span class="cmds">SOB</span> <span class="regn">RN</span>,<span class="labl">MET</span> 
		- <b>вычитание единицы и ветвление</b>. Этот оператор может быть использован 
		для организации циклов. При его исполнении сначала происходит вычитание 
		единицы из содержимого регистра <span class="regn">RN</span>, а затем, если 
		результат <b>не нулевой</b>, - переход к метке <span class="labl">MET</span>. 
		Если же содержимое <span class="regn">RN</span> стало равно нулю, то программа 
		выполняется дальше. Метка <span class="labl">MET</span> может быть как локальной, 
		так и обычной и должна быть расположена <b>до</b> оператора
		<span class="cmds">SOB</span>, т.е. передача управления возможна только &laquo;<i>назад</i>&raquo; 
		и не более чем на <span class="nmbr">64</span><sub>д</sub> слова. Это объясняется 
		тем, что в операторе <span class="cmds">SOB</span> для хранения смещения 
		используются только младшие <span class="nmbr">6</span> бит, а при исполнении 
		перехода смещение (без знака) умножается на <span class="nmbr">2</span> 
		и вычитается из <span class="regn">PC</span>. Циклы могут быть и вложенными, 
		но число вложений, если не принимать специальных мер, не может превышать 
		количества операционных регистров, которые используются для хранения цикловых 
		переменных. Помимо организации вычислений этот оператор часто используется 
		для создания временных задержек при работе программ, причём &laquo;<i>пустой</i>&raquo; 
		цикл <span class="cmds">SOB</span> при исходном содержимом регистра, равном 
		нулю, выполняется на БК-0010 примерно за <span class="nmbr">0</span>.<span class="nmbr">4</span>&nbsp;с. 
		Если потребуются большие задержки, следует прибегнуть к вложенным циклам 
		или ввести в цикл &laquo;<i>пустые</i>&raquo; команды, например
		<span class="cmds">CMP</span> <span class="regn">RN</span>,<span class="regn">RN</span>. 
		Приведём пример использования данного оператора, причём это будет уже знакомая 
		программа &laquo;<i>мигания</i>&raquo; экрана, но теперь решённая иными 
		средствами.</li>
	</ul>
	<pre>        <span class="cmmnt">; &quot;мигание&quot; экрана</span>
<span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R0</span>          <span class="cmmnt">; Все биты в R0 - единицы</span>
<span class="locl">1</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>           <span class="cmmnt">; Начало экрана</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">20000</span>,<span class="regn">R2</span>           <span class="cmmnt">; Цикл из 20000 повторов</span>
<span class="locl">2</span>:      <span class="cmds">MOV</span>     <span class="regn">R0</span>,(<span class="regn">R1</span>)+            <span class="cmmnt">; Запись очередного слова в ОЗУ</span>
        <span class="cmds">SOB</span>     <span class="regn">R2</span>,<span class="locl">2</span>                <span class="cmmnt">; Если не конец - продолжать</span>
        <span class="cmds">BEQ</span>     <span class="locl">0</span>                   <span class="cmmnt">; Если 0, записать все единицы</span>
        <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Иначе обнулить R0 и войти</span>
        <span class="cmds">BR</span>      <span class="locl">1</span>                   <span class="cmmnt">; в цикл очистки экрана</span>
        <span class="pscm">END</span></pre>
	<p>Сравните эту программу с аналогичной, приведённой ранее (где цикл был организован 
	с помощью оператора <span class="cmds">CMP</span>). Какая из них короче и какая 
	работает быстрее? Обратите внимание, что оператор <span class="cmds">SOB</span> 
	не меняет биты условий, поэтому нам удалось обойтись без проверки содержимого
	<span class="regn">R0</span> оператором <span class="cmds">TST</span>.</p>
	<p>При работе с циклами нужно быть внимательным, чтобы не передать управление 
	на оператор, задающий начальное значение переменной цикла, иначе цикл станет 
	бесконечным. С этой же целью нужно заботиться о сохранении в цикле содержимого 
	регистра- счётчика <span class="regn">RN</span>, если он должен использоваться 
	для других целей.</p>
	<h3><a name="toc_34"></a>3. Операторы прерывания</h3>
	<p>Эта важная группа операторов имеет общую черту: встретив такой оператор, 
	ЦП прерывает выполнение текущей задачи. Что такое прерывание, было уже достаточно 
	подробно описано в разделе, посвящённом архитектуре ЭВМ (см. №
	<span class="nmbr">2</span> за <span class="nmbr">1994</span> г.), и возвращаться 
	к этому вопросу мы не будем. Подробно разберём только <b>командные прерывания</b>.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="var">X</span> - <b>командное 
		прерывание по вектору</b> <span class="nmbr">30</span>.</li>
		<li><span class="cmds">TRAP</span> <span class="var">X</span> - <b>командное 
		прерывание по вектору</b> <span class="nmbr">34</span>.</li>
	</ul>
	<p>Командные прерывания <span class="cmds">EMT</span> и <span class="cmds">TRAP</span> 
	(иначе называемые <b>командными запросами</b>) очень похожи друг на друга. Знак
	<span class="var">X</span> здесь - <b>аргумент</b> <span class="cmds">EMT</span> 
	или <span class="cmds">TRAP</span>, лежащий в пределах <span class="nmbr">0</span>...<span class="nmbr">377</span>. 
	Рассмотрим, как работают эти команды, на примере <span class="cmds">EMT</span>.</p>
	<p>Пусть процессор встретил в программе команду с кодом <span class="cmds">EMT</span>
	<span class="var">X</span>. Первым делом происходит прерывание по вектору
	<span class="nmbr">30</span> (как обычно сохраняя в стеке <span class="regn">
	SP</span> и <span class="regn">PC</span>). И вот тут-то появляется &laquo;<i>неожиданность</i>&raquo; 
	- по адресу, указанному в ячейке @#<span class="nmbr">30</span>, находится не 
	конкретная, единственная программа обработки прерывания, а целый пакет программ! 
	Но ничего ужасного не происходит: &laquo;<i>на пороге</i>&raquo; нас встречает 
	маленькая, но очень важная программа - <b><span class="cmds">EMT</span>-диспетчер</b>. 
	Что он делает? Первым делом выделяет младший байт команды <span class="cmds">
	EMT</span>, т.е. её аргумент. По аргументу (или, как ещё говорят, по <b>номеру
	<span class="cmds">EMT</span></b>) <span class="cmds">EMT</span>-диспетчер находит 
	в специальной таблице адрес программы, которая нам нужна, и передаёт ей управление. 
	Таким образом, задавая номер <span class="cmds">EMT</span>, мы можем с помощью 
	этой единственной команды обращаться к множеству программ, выполняющих самые 
	разные функции.</p>
	<p>Но чем же такое обращение отличается от вызова подпрограмм, ведь их тоже 
	можно написать множество и обращаться к каждой просто по имени метки? Это вроде 
	бы проще и понятнее. Верно, только вот &laquo;<i>закавыка</i>&raquo; - команда 
	обращения к подпрограмме занимает в памяти два слова, а <span class="cmds">EMT</span> 
	- только одно! Таких обращений в тексте программы может быть несколько сотен, 
	и тогда <span class="cmds">EMT</span> дает экономию памяти в сотни слов. Для 
	БК с её, мягко говоря, не слишком ёмкой памятью, это немаловажно.</p>
	<p>А что же <span class="cmds">TRAP</span>, какова роль этой команды? Практической 
	разницы между <span class="cmds">EMT</span> и <span class="cmds">TRAP</span> 
	нет, вернее, разница чисто условная. Для команды <span class="cmds">TRAP</span> 
	выполняется прерывание по вектору <span class="nmbr">34</span>. В самой же команде 
	указывается, как и в <span class="cmds">EMT</span>, номер в диапазоне
	<span class="nmbr">0</span>...<span class="nmbr">377</span>. Команды
	<span class="cmds">EMT</span> принято использовать в системных программах ЭВМ. 
	a <span class="cmds">TRAP</span> - в пользовательских. Что же касается порядка 
	их обработки, он одинаков - для вектора <span class="nmbr">34</span> программа 
	обработки должна начинаться с <b><span class="cmds">TRAP</span>-диспетчера</b>, 
	аналогичного <span class="cmds">EMT</span>- диспетчеру.</p>
	<p>Программа <span class="cmds">EMT</span>-диспетчера БК-0010 расположена по 
	адресу <span class="nmbr">100112</span> и обслуживает множество команд
	<span class="cmds">EMT</span> с различными номерами. Каждая из них делает что-то 
	своё, иногда эти действия весьма сложны, причём ими может воспользоваться не 
	только сама ЭВМ, но и программист. Тем самым иногда можно избежать написания 
	длинных и очень сложных подпрограмм - достаточно вписать в программу команду
	<span class="cmds">EMT</span> с нужным номером, а подпрограмма обработки уже 
	готова - она &laquo;<i>ждёт</i>&raquo; в ПЗУ. Тут необходимо отметить (спасибо 
	разработчикам БК-0010, а особая благодарность - автору МДС <em>М.И. Дябину</em>), 
	что содержимое мониторно-драйверной системы нашей ЭВМ (а тем самым и система 
	командных запросов <span class="cmds">EMT</span>) осталось неизменным с
	<span class="nmbr">1985</span> г., когда компьютер БК-0010 &laquo;<i>пошёл в 
	серию</i>&raquo;, и до сего дня, когда освоен выпуск последней модели БК-0010.01 
	с новой отличной бездребезговой клавиатурой и полностью переработанной печатной 
	платой. Это очень важно - ведь изменись МДС хоть частично, все ранее разработанные 
	Прикладные программы оказались бы написанными впустую, они не работали бы на 
	новых моделях компьютеров! К чему это приводит, видно на примере БК-0011. Не 
	успела она появиться в продаже, как разработчикам что-то в ней не понравилось, 
	и они сочли своим долгом изменить её мониторно-драйверную систему. А новая МДС 
	БК-0011М оказалась программно несовместимой с прежней. Это, без всякого преувеличения, 
	настоящая катастрофа для всех владельцев БК-0011 - старый компьютер уже не выпускают, 
	программ для него нет и никогда не будет - слишком мало экземпляров БК-0011 
	было выпущено! Это трагедия и для разработчиков - они сразу и навсегда подорвали 
	доверие пользователей к новой машине: кто гарантирует, что завтра снова не изменится 
	МДС БК-0011М и её владельцы вновь не окажутся &laquo;<i>у разбитого корыта</i>&raquo;... 
	Это удар и для программистов - всё, разработанное ими в ужасной спешке и зачастую 
	почти бесплатно для БК-0011, уже не годится для БК-0011М и никогда не окупится.</p>
	<p>К счастью, с БК-0010 ничего такого не происходило - все её модели до настоящего 
	времени полностью программно совместимы друг с другом на уровне машинных команд, 
	в том числе и <span class="cmds">EMT</span>-запросов.</p>
	<p>На что же годны имеющиеся в системе БК-0010 командные прерывания
	<span class="cmds">EMT</span>, или, другими словами, что они делают?</p>
	<p>Начнём с того, что на БК-0010 для номеров <span class="cmds">EMT</span> приняты 
	только чётные числа. Это чистая условность - можно было бы использовать и нечётные, 
	но с чётными <span class="cmds">EMT</span>-диспетчер вышел чуть проще, а такого 
	множества функций, какое было бы возможно с использованием всех чисел, просто 
	не нужно.</p>
	<p>Каждая команда <span class="cmds">EMT</span> (имеющая свой номер) делает 
	что-то своё. Но между ними есть и нечто общее - обычно они требуют задания каких-либо 
	параметров (исходных данных). Данные эти задаются, как правило, в одном или 
	нескольких регистрах общего назначения, до вызова команды <span class="cmds">
	EMT</span>. После выполнения команды содержимое РОН может остаться тем же (сохраняться) 
	или стать иным. Часто новое значение РОН несёт ценную информацию, которая может 
	быть использована (а иногда эта информация - единственный результат выполнения
	<span class="cmds">EMT</span>). По ходу знакомства с различными
	<span class="cmds">EMT</span>-функциями мы будем приводить сведения как о входной, 
	так и о выходной информации (если она представляет интерес), и указывать, какие 
	РОН не сохраняются при выполнении <span class="cmds">EMT</span> (о их сохранении 
	следует позаботиться до вызова <span class="cmds">EMT</span>). Наиболее употребительным 
	функциям <span class="cmds">EMT</span> мы будем уделять больше внимания. Будем 
	рассматривать их не в порядке номеров, а по функциональному назначению.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">4</span> - <b>инициализация 
		драйвера клавиатуры</b> Переписываются (устанавливаются в исходные значения) 
		векторы прерывания от клавиатуры (<span class="nmbr">60</span> и
		<span class="nmbr">274</span>), сбрасывается маска прерываний от клавиатуры 
		(разряд <span class="nmbr">06</span> регистра <span class="nmbr">177660</span>), 
		устанавливается режим передачи кодов клавиатуры по запросам рабочей программы 
		и код <span class="nmbr">12</span> для клавиши &laquo;<i>ВВОД</i>&raquo;.
		<span class="regn">R0</span> не сохраняется. <span class="cmds">EMT</span>
		<span class="nmbr">4</span> используется весьма редко, например если по 
		ходу программы мы запретили прерывание от клавиатуры и нужно его разрешить.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">14</span> - <b>инициализация 
		всех драйверов</b>. Применяется, напротив, очень часто для &laquo;<i>начальной 
		установки</i>&raquo; всех параметров ЭВМ (а особенно режимов дисплея). Обеспечивает 
		установку в исходное состояние всех ячеек системной области (кроме стека), 
		всех векторов прерывания и системных регистров, очистку экрана, установку 
		исходных режимов дисплея и ТЛГ-канала, очистку порта ввода-вывода. Таким 
		образом, БК-0010 приводится практически в такое же состояние, как после 
		перезапуска системы (или включения питания). Регистры, кроме
		<span class="regn">R5</span>, не сохраняются. Эту команду следует применять 
		с некоторой осторожностью, так как из-за сохранения содержимого стека после 
		выполнения <span class="cmds">EMT</span> <span class="nmbr">14</span> иногда 
		по окончании работы программы возможен неожиданный эффект - выход из МСД 
		в ПМ или даже в Фокал со стиранием ОЗУ.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">6</span> - <b>ввод 
		кода символа с клавиатуры</b>. По данной команде работа программы прерывается, 
		и ЭВМ ждёт нажатия клавиши. Код нажатой клавиши заносится в младший байт
		<span class="regn">R0</span>, старший байт очищается. Применяется очень 
		широко как для ввода кодов отдельных символов или команд, так и просто для 
		приостанова программы и ожидания нажатия клавиши (организация паузы). Следует 
		помнить, что. когда ЭВМ ждёт нажатия клавиши по команде
		<span class="cmds">EMT</span> <span class="nmbr">6</span>, она находится 
		в режиме прерывания, следовательно, вершина стека уже на
		<span class="nmbr">4</span> меньше исходной. Нажатие в этот момент клавиши &laquo;<i>СТОП</i>&raquo; 
		- не одно и то же, что останов с её помощью работающей программы, в смысле 
		содержимого стека на момент останова и положения его вершины (содержимого
		<span class="regn">SP</span>), иногда это может быть существенно.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">16</span> - <b>передача 
		кодов драйверу дисплея</b>. Это &laquo;<span class="cmds">EMT</span>
		<span class="nmbr">6</span> наоборот&raquo; - вывод на экран символа, код 
		которого содержится в младшем байте <span class="regn">R0</span> (или исполнение 
		команды управления режимами экрана, если в <span class="regn">R0</span> 
		её код). Содержимое старшего байта <span class="regn">R0</span> при исполнении
		<span class="cmds">EMT</span> <span class="nmbr">16</span> значения не имеет 
		и не меняется. Пожалуй, это наиболее часто применяемая команда
		<span class="cmds">EMT</span> - с её помощью можно выводить как отдельные 
		символы, так и целые тексты. Все регистры при её исполнении сохраняются. 
		Приведём примеры использования этих команд.</li>
	</ul>
	<pre>1)      <span class="cmds">MOVB</span>    #<span class="nmbr">77</span>,<span class="regn">R0</span>              <span class="cmmnt">; Вывод на экран</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; символа    &quot;?&quot;</span>
        <span class="pscm">END</span>
 
2)      <span class="cmds">MOVB</span>    #<span class="nmbr">14</span>,<span class="regn">R0</span>              <span class="cmmnt">; Сброс экрана</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; и вывод символа</span>
        <span class="cmds">MOVB</span>    '<span class="strn">A</span>',<span class="regn">R0</span>              <span class="cmmnt">; &quot;А&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="pscm">END</span>
 
3)      <span class="cmds">MOV</span>     '<span class="strn">АБ</span>',<span class="regn">R0</span>             <span class="cmmnt">; Вывод на экран</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Двух символов</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; &quot;А&quot; и &quot;Б&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="pscm">END</span>
 
4) <span class="locl">0</span>:   <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Вывод на экран</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; символов, вводимых</span>
        <span class="cmds">CMPB</span>    #<span class="nmbr">40</span>,<span class="regn">R0</span>              <span class="cmmnt">; с клавиатуры; завершение -</span>
        <span class="cmds">BNE</span>     <span class="locl">0</span>                   <span class="cmmnt">; по клавише &quot;ПРОБЕЛ&quot;</span>
        <span class="pscm">END</span>
 
5)      <span class="cmds">MOV</span>     #<span class="nmbr">7</span>,<span class="regn">R0</span>               <span class="cmmnt">; Цикл</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">100</span>,<span class="regn">R1</span>             <span class="cmmnt">; из 64д звуковых</span>
<span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; сигналов</span>
        <span class="cmds">SOB</span>     <span class="regn">R1</span>,<span class="locl">0</span>
        <span class="pscm">END</span>
 
6) <span class="locl">0</span>:   <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Пауза до нажатия клавиши</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">14</span>,(<span class="regn">R1</span>)+           <span class="cmmnt">; Команда очистки экрана</span>
        <span class="cmds">MOVB</span>    '<span class="strn">П</span>',(<span class="regn">R1</span>)+           <span class="cmmnt">; Ввод в ОЗУ</span>
        <span class="cmds">MOV</span>     '<span class="strn">ри</span>',(<span class="regn">R1</span>)+          <span class="cmmnt">; строки символов -</span>
        <span class="cmds">MOV</span>     '<span class="strn">вe</span>',(<span class="regn">R1</span>)+          <span class="cmmnt">; слова &quot;Привет&quot;</span>
        <span class="cmds">MOVB</span>    '<span class="strn">т</span>',(<span class="regn">R1</span>)+
        <span class="cmds">CLRB</span>    (<span class="regn">R1</span>)+               <span class="cmmnt">; Нулевой байт - конец текста</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
<span class="locl">1</span>:      <span class="cmds">MOVB</span>    (<span class="regn">R1</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; Вывод текста на экран</span>
        <span class="cmds">BEQ</span>     <span class="locl">0</span>                   <span class="cmmnt">; побайтно до нулевого байта,</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; затем - повторение с начала</span>
        <span class="cmds">BR</span>      <span class="locl">1</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">END</span>
</pre>
	<p>В приведённых примерах листинги заканчиваются командой <span class="pscm">
	END</span>, но это не обязательно - они могут представлять собой подпрограммы 
	или фрагменты программ. Для полного использования возможностей команды
	<span class="cmds">EMT</span> <span class="nmbr">16</span> необходимо знать 
	не только коды символов БК-0010, но и командные коды. Эти сведения достаточно 
	полно изложены в прилагаемых к БК руководствах, и подробно останавливаться на 
	них нет необходимости.</p>
	<p>Заметим, что приведённая в последнем примере строка текста предварительно 
	записывается в память отнюдь не оптимальным способом, но другого варианта мы 
	пока ещё &laquo;<i>не проходили</i>&raquo;.</p>
	<h3><a name="toc_35"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Чему будет равно содержимое регистра <span class="regn">R0</span> в 
		результате исполнения последовательно каждой из команд:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">77000</span>,<span class="regn">R0</span>
        <span class="cmds">INC</span>     <span class="regn">R0</span>
        <span class="cmds">COMB</span>    <span class="regn">R0</span></pre>
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">77000</span>; <span class="nmbr">77001</span>;
			<span class="nmbr">77376</span>.</p>
			</li>
		</ul>
		</li>
		<li>Чему будет равно содержимое регистра <span class="regn">R5</span> в 
		результате исполнения последовательно каждой из команд:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R5</span>
        <span class="cmds">ASL</span>     <span class="regn">R5</span>
        <span class="cmds">ASL</span>     <span class="regn">R5</span>
        <span class="cmds">ROL</span>     <span class="regn">R5</span>
        <span class="cmds">ROL</span>     <span class="regn">R5</span></pre>
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">177777</span>, <span class="nmbr">177776</span>;
			<span class="nmbr">177774</span>; <span class="nmbr">177771</span>,
			<span class="nmbr">177763</span>.</p>
			</li>
		</ul>
		</li>
		<li>Что получится в результате выполнения команды <span class="cmds">XOR</span> 
		#<span class="nmbr">1000</span>,@#<span class="nmbr">2400</span> ?
		<ul id="ctrla">
			<li>
			<p>Ничего, так как первым операндом команды <span class="cmds">XOR</span> 
			может быть только <span class="regn">RN</span> - один из регистров общего 
			назначения. Такая команда даже не будет оттранслирована ассемблером.</p>
			</li>
		</ul>
		</li>
		<li>Как переписать младший байт из регистра <span class="regn">R0</span> 
		в регистр <span class="regn">R4</span>, не изменяя при этом старшие байты
		<span class="regn">R0</span> и <span class="regn">R4</span> (остальные регистры 
		и ячейки памяти не использовать)? Напишите соответствующую программу.</li>
		<pre>        <span class="cmds">CLRB</span>    <span class="regn">R4</span>
        <span class="cmds">BISB</span>    <span class="regn">R0</span>,<span class="regn">R4</span></pre>
		<li>Как установятся биты условий ССП <span class="symb">N</span>,
		<span class="symb">Z</span>, <span class="symb">V</span>,
		<span class="symb">С</span> в результате исполнения последовательно из каждой 
		команд:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">177777</span>,<span class="regn">R0</span>
        <span class="cmds">INC</span>     <span class="regn">R0</span>
        <span class="cmds">ADD</span>     #<span class="nmbr">77777</span>,<span class="regn">R0</span>
        <span class="cmds">ASL</span>     <span class="regn">R0</span>
        <span class="cmds">ASL</span>     <span class="regn">R0</span></pre>
		<ul id="ctrla">
			<li>
			<p><span class="symb">N</span>=<span class="nmbr">1</span>;
			<span class="symb">Z</span>=<span class="nmbr">0</span>;
			<span class="symb">V</span>=<span class="nmbr">0</span>;
			<span class="symb">C</span>=<span class="nmbr">0</span></p>
			<p><span class="symb">N</span>=<span class="nmbr">0</span>;
			<span class="symb">Z</span>=<span class="nmbr">1</span>;
			<span class="symb">V</span>=<span class="nmbr">0</span>;
			<span class="symb">C</span>=<span class="nmbr">0</span></p>
			<p><span class="symb">N</span>=<span class="nmbr">0</span>;
			<span class="symb">Z</span>=<span class="nmbr">0</span>,
			<span class="symb">V</span>=<span class="nmbr">0</span>;
			<span class="symb">C</span>=<span class="nmbr">0</span></p>
			<p><span class="symb">N</span>=<span class="nmbr">1</span>;
			<span class="symb">Z</span>=<span class="nmbr">0</span>;
			<span class="symb">V</span>=<span class="nmbr">1</span>;
			<span class="symb">C</span>=<span class="nmbr">0</span></p>
			<p><span class="symb">N</span>=<span class="nmbr">1</span>;
			<span class="symb">Z</span>=<span class="nmbr">0</span>;
			<span class="symb">V</span>=<span class="nmbr">0</span>;
			<span class="symb">C</span>=<span class="nmbr">1</span></p>
			</li>
		</ul>
		</li>
		<li>Будет ли выполняться ветвление по оператору <span class="cmds">BGE</span> 
		в данной программе:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">377</span>,<span class="regn">R0</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">120</span>,<span class="regn">R1</span>
        <span class="cmds">CMPB</span>    <span class="regn">R0</span>,<span class="regn">R1</span>
        <span class="cmds">BGE</span>     <span class="labl">MET</span></pre>
		<p>Что изменится, если вместо оператора <span class="cmds">CMPB</span> использовать
		<span class="cmds">CMP</span>?</p>
		<ul id="ctrla">
			<li>
			<p>Не будет, так как число <span class="nmbr">377</span> отрицательное 
			и меньше числа <span class="nmbr">120</span>, а оператор
			<span class="cmds">BGE</span> учитывает знак. При замене
			<span class="cmds">CMPB</span> на <span class="cmds">CMP</span> ветвление 
			будет выполняться</p>
			</li>
		</ul>
		</li>
		<li>Сколько раз будет выполнен цикл <span class="cmds">SOB</span> в данном 
		случае:
		<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">10</span>,<span class="regn">R0</span>
<span class="locl">0</span>:      <span class="cmds">DEC</span>     <span class="regn">R0</span>
        <span class="cmds">SOB</span>     <span class="regn">R0</span>,<span class="locl">0</span></pre>
		<ul id="ctrla">
			<li>
			<p><span class="nmbr">4</span> раза, так как регистр-счётчик
			<span class="regn">R0</span> дополнительно модифицируется в геле цикла.</p>
			</li>
		</ul>
		</li>
		<li>Сколько символов &laquo;<i class="strn">А</i>&raquo; выведет на экран 
		следующая программа:
		<pre>       <span class="cmds">MOV</span>     '<span class="strn">A</span>',<span class="regn">R0</span>
<span class="locl">0</span>:     <span class="cmds">MOV</span>     #<span class="nmbr">10</span>,<span class="regn">R1</span>
       <span class="cmds">EMT</span>     <span class="nmbr">16</span>
       <span class="cmds">SOB</span>     <span class="regn">R1</span>,<span class="locl">0</span></pre>
		<ul id="ctrla">
			<li>
			<p>Бесконечное множество, так как цикл организован неправильно - запись 
			константы в <span class="regn">R1</span> включена в цикл.</p>
			</li>
		</ul>
		</li>
		<li>Напишите программу, которая по нажатию любой клавиши (кроме клавиши &laquo;<i>СТОП</i>&raquo;) 
		выводила бы на экран символ &laquo;<span class="symb">?</span>&raquo;</li>
		<pre><span class="locl">0</span>:    <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">MOV</span>     '<span class="strn">?</span>',<span class="regn">R0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">BR</span>      <span class="locl">0</span></pre>
		<li>Напишите программу, которая преобразовывала бы символы, вводимые с клавиатуры 
		в любом регистре (&laquo;<i>РУС</i>&raquo;, &laquo;<i>ЛАТ</i>&raquo;, &laquo;<i>СТР</i>&raquo;, &laquo;ЗАГЛ&raquo;), 
		в символы в регистре &laquo;ЛАТ-ЗАГЛ&raquo; соответственно нажатой клавише 
		(например, &laquo;<i>л</i>&raquo; - в &laquo;<i>L</i>&raquo;) и выводила 
		на экран исходный символ, а через чёрточку - преобразованный, причём каждая 
		следующая пара символов должна выводиться с новой строки.
		<ul id="ctrla">
			<li>
			<p>Подсказка: для того чтобы преобразовать символы из одного регистра 
			в другой, достаточно сбросить (или установить) определённые разряды 
			(биты) кода символа. Определить, какие именно, легко, если выписать 
			двоичные коды символов разных регистров друг под другом.</p>
			<pre><span class="locl">0</span>:    <span class="cmds">MOV</span>     #<span class="nmbr">12</span>,<span class="regn">R0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,<span class="regn">R1</span>
        <span class="cmds">MOV</span>     '<span class="strn">-</span>',<span class="regn">R0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">MOV</span>     <span class="regn">R1</span>,<span class="regn">R0</span>
        <span class="cmds">BIC</span>     #<span class="nmbr">240</span>,<span class="regn">R0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>
        <span class="pscm">END</span></pre>
			</li>
		</ul>
		</li>
	</ol>
	<p>В этой части мы закончим рассмотрение <span class="cmds">EMT</span>-функций 
	БК-0010 и их роли в программировании на ассемблере.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">10</span> - <b>ввод 
		строки символов с клавиатуры</b>. Данная команда позволяет вводить с клавиатуры 
		в заданную область ОЗУ последовательность кодов символов (а также командные 
		коды). Адрес начала области ОЗУ, в которую осуществляется ввод, задаётся 
		в <span class="regn">R1</span>, ограничители строки - в
		<span class="regn">R2</span>: младший байт <span class="regn">R2</span> 
		- длина строки в байтах (нуль соответствует <span class="nmbr">200000</span> 
		байт), старший - код символа-ограничителя. Работа <span class="cmds">EMT</span>
		<span class="nmbr">10</span> заканчивается после удовлетворения одного из 
		двух условий: строка достигает заданной длины или вводится символ-ограничитель. 
		причём его код заносится в строку последним. По окончании ввода в
		<span class="regn">R1</span> возвращается адрес байта, следующего за концом 
		строки, в <span class="regn">R2</span> - разность заданной длины и реально 
		введённого количества символов. Ошибочно введённые знаки можно удалять клавишей &laquo;<i>ЗАБОЙ</i>&raquo;.
		<span class="cmds">EMT</span> <span class="nmbr">10</span> широко применяется 
		для ввода текстов, чисел в символьном виде для последующей их обработки, 
		имён файлов и т.п.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">20</span> - <b>вывод 
		строки символов на экран</b>. Эта команда выполняет действие, противоположное
		<span class="cmds">EMT</span> <span class="nmbr">10</span>. Адрес начала 
		строки символов задаётся в <span class="regn">R1</span>. ограничители строки 
		- в <span class="regn">R2</span> (так же, как для <span class="cmds">EMT</span>
		<span class="nmbr">10</span>, младший байт - длина строки,
		<span class="nmbr">0</span> соответствует <span class="nmbr">200000</span>, 
		старший - код символа-ограничителя, причём он выводится на экран последним). 
		С помощью <span class="cmds">EMT</span> <span class="nmbr">20</span> можно 
		не только выводить символы, но и изменять режимы вывода (очистка экрана, 
		переключение формата <span class="nmbr">32</span>/<span class="nmbr">64</span> 
		символа в строке и т.п.), если коды соответствующих команд присутствуют 
		в строке. Применяется очень широко для вывода текстовых сообщений. Примеры:</li>
	</ul>
	<pre>1) <span class="locl">0</span>:   <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Пауза до нажатия клавиши</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">14</span>,(<span class="regn">R1</span>)+           <span class="cmmnt">; Команда очистки экрана</span>
        <span class="cmds">MOVB</span>    '<span class="strn">П</span>',(<span class="regn">R1</span>)+           <span class="cmmnt">; Запись в ОЗУ</span>
        <span class="cmds">MOV</span>     '<span class="strn">ри</span>',(<span class="regn">R1</span>)+          <span class="cmmnt">; строки символов   -</span>
        <span class="cmds">MOV</span>     '<span class="strn">ве</span>',(<span class="regn">R1</span>)+          <span class="cmmnt">; слова &quot;Привет&quot;</span>
        <span class="cmds">MOVB</span>    '<span class="strn">т</span>',(<span class="regn">R1</span>)+
        <span class="cmds">CLRB</span>    (<span class="regn">R1</span>)+               <span class="cmmnt">; Нулевой байт - конец текста</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Вывод на экран строки текста,</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; с метки ТЕХ</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; до нулевого байта</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">END
</span>
2) <span class="locl">0</span>:   <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Ввод строки текста (максимальная</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">5377</span>,<span class="regn">R2</span>            <span class="cmmnt">; длина 256д байт, символ-</span>
        <span class="cmds">EMT</span>     <span class="nmbr">10</span>                  <span class="cmmnt">; ограничитель - код 12 &quot;ВВОД&quot;)</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; и её последующая выдача на</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">5377</span>,<span class="regn">R2</span>            <span class="cmmnt">; экран. Буфер строки начинается</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; с метки ТЕХ</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">END</span></pre>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">22</span> - <b>запись 
		символа в служебную строку</b>. Позволяет вывести в служебную строку необходимые 
		сообщения, например фамилию автора, название программы и т.п. Информация 
		выводится по одному символу (соответственно, для вывода строки нужно использовать 
		цикл), код этого символа записывается в <span class="regn">R0</span>, а 
		номер позиции в служебной строке - в <span class="regn">R1</span>. Символы 
		выводятся как в режиме БЛР- ИСУ, т.е. коды управления (<span class="nmbr">10</span>,
		<span class="nmbr">22</span>, <span class="nmbr">30</span> и т.п.) отображаются 
		в виде стрелок. Нулевое содержимое <span class="regn">R0</span> означает 
		очистку служебной строки. Позиция отсчитывается от левого края, первому 
		символу соответствует <span class="nmbr">0</span>. При использовании команды 
		необходимо учитывать, что в правой части служебной строки ЭВМ сама выводит 
		сообщения при переключении режимов, при этом текст, выведенный туда пользователем, 
		может быть затёрт. Пример:</li>
	</ul>
	<pre><span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">2</span>,<span class="regn">R1</span>               <span class="cmmnt">; Вывод начиная с 3-й позиции</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Пауза до нажатия клавиши</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R2</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">233</span>,<span class="regn">R0</span>             <span class="cmmnt">; Команда переключения</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; формата</span>
        <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Очистка</span>
        <span class="cmds">EMT</span>     <span class="nmbr">22</span>                  <span class="cmmnt">; служебной строки</span>
        <span class="cmds">MOV</span>     '<span class="strn">Пр</span>',(<span class="regn">R2</span>)+          <span class="cmmnt">; Запись в ОЗУ</span>
        <span class="cmds">MOV</span>     '<span class="strn">ив</span>',(<span class="regn">R2</span>)+          <span class="cmmnt">; строки символов –</span>
        <span class="cmds">MOV</span>     '<span class="strn">eт</span>',(<span class="regn">R2</span>)+          <span class="cmmnt">; слова &quot;Привет!&quot;</span>
        <span class="cmds">MOV</span>     '! ',(<span class="regn">R2</span>)+
        <span class="cmds">CLRB</span>    (<span class="regn">R2</span>)+               <span class="cmmnt">; Нулевой байт - конец текста</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R2</span>             <span class="cmmnt">; Адрес начала текста</span>
<span class="locl">1</span>:      <span class="cmds">MOVB</span>    (<span class="regn">R2</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; Вывод текста</span>
        <span class="cmds">BEQ</span>     <span class="locl">0</span>                   <span class="cmmnt">; в служебную строку</span>
        <span class="cmds">EMT</span>     <span class="nmbr">22</span>
        <span class="cmds">INC</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Программа зациклена</span>
        <span class="cmds">BR</span>      <span class="locl">1</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">END</span></pre>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">24</span> - <b>установка 
		курсора по координатам</b>. Координата <span class="argm">X</span> задаётся 
		в регистре <span class="regn">R1</span>, <span class="argm">Y</span> - в
		<span class="regn">R2</span>. В графическом режиме по <span class="cmds">
		EMT</span> <span class="nmbr">24</span> аналогичным образом устанавливается 
		графический курсор. Если значение координат превышает число знакомест (или 
		точек) экрана, то курсор устанавливается по модулю имеющегося на экране 
		числа знакомест. (В данном случае слова &laquo;<i>по модулю</i>&raquo; обозначают 
		использование функции <span class="cmdf">MOD</span>, т.е. вычисление остатка 
		от деления. Так, если значение <span class="argm">X</span> задано равным
		<span class="nmbr">79</span>. а ширина экрана в данном режиме вывода соответствует
		<span class="nmbr">64</span> символам, то курсор устанавливается в позиции, 
		равной <span class="nmbr">79</span> <span class="cmdf">MOD</span>
		<span class="nmbr">64</span> = <span class="nmbr">15</span>. - <em>Прим. 
		ред.</em>) Началом координат, как это принято для БК-0010, считается левый 
		верхний угол экрана.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">26</span> - <b>чтение 
		координат курсора</b>. Как и предыдущая команда, <span class="cmds">EMT</span>
		<span class="nmbr">26</span> работает и в символьном, и в графическом режимах. 
		Значение координат читается: <span class="argm">X</span> - в
		<span class="regn">R1</span>, <span class="argm">Y</span> - в
		<span class="regn">R2</span>.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">30</span> - <b>формирование 
		точки по координатам</b>. Координаты точки задаются: <span class="argm">
		X</span> - в <span class="regn">R1</span>, <span class="argm">Y</span> - 
		в <span class="regn">R2</span>. В <span class="regn">R0</span> указывается 
		код операции: <span class="nmbr">1</span> (или любое ненулевое значение) 
		- запись точки, <span class="nmbr">0</span> - стирание. Предварительная 
		установка графического режима не требуется. Цвет (в цветном режиме) может 
		быть задан соответствующей командой заранее. Если координаты точки выходят 
		за пределы экрана, то команда игнорируется, но заданные координаты запоминаются 
		как последние отработанные.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">32</span> - <b>формирование 
		вектора</b>. Задаются координаты конца вектора: <span class="argm">X</span> 
		- в <span class="regn">R1</span>, <span class="argm">Y</span> - в
		<span class="regn">R2</span>. В <span class="regn">R0</span> указывается 
		код операции, как и для <span class="cmds">EMT</span> <span class="nmbr">
		30</span>: <span class="nmbr">1</span> (или любое ненулевое значение) - 
		запись вектора, <span class="nmbr">0</span> - стирание. Может быть предварительно 
		задан цвет. Началом вектора считается конец последнего начерченного или 
		стёртого вектора (по <span class="cmds">EMT</span> <span class="nmbr">32</span>) 
		либо последняя обработанная точка (по <span class="cmds">EMT</span>
		<span class="nmbr">30</span>). Если координаты начала или конца вектора 
		оказываются за пределами экрана, вектор в соответствии с ними всё равно 
		строится. хотя на экране отображается только его видимая часть. Приведём 
		пример.</li>
	</ul>
	<pre><span class="cmmnt">; &quot;муаровый&quot; узор</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">1</span>,<span class="regn">R0</span>               <span class="cmmnt">; Зачерчивание экрана</span>
        <span class="cmds">CLR</span>     <span class="regn">R3</span>                  <span class="cmmnt">; из левого верхнего</span>
<span class="locl">0</span>:      <span class="cmds">CLR</span>     <span class="regn">R1</span>                  <span class="cmmnt">; угла фигурой типа</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; &quot;радиальный луч&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">30</span>                  <span class="cmmnt">; Регистр R3 используется</span>
        <span class="cmds">MOV</span>     <span class="regn">R3</span>,<span class="regn">R1</span>               <span class="cmmnt">; как буфер координаты</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">357</span>,<span class="regn">R2</span>             <span class="cmmnt">; X конца луча</span>
        <span class="cmds">EMT</span>     <span class="nmbr">32</span>
        <span class="cmds">CMP</span>     (<span class="regn">R3</span>)+,(<span class="regn">R3</span>)+
        <span class="cmds">BR</span>      <span class="nmbr">0</span>                   <span class="cmmnt">; Программа зациклена</span>
        </pre>
	<p>Отметим, что предпоследняя команда ничего, в общем-то, не сравнивает, а использована 
	только для увеличения содержимого <span class="regn">R3</span> сразу на
	<span class="nmbr">4</span>. При этом она занимает всего одно слово, в отличие, 
	например, от команды <span class="cmds">ADD</span> #<span class="nmbr">4</span>,<span class="regn">R3</span>, 
	занимающей два слова. С таким использованием команды <span class="cmds">CMP</span> 
	мы уже знакомы.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">12</span> - <b>установка 
		ключей клавиатуры</b>. Как известно, БК-0010 имеет механизм <b>ключей</b> 
		(или функциональных клавиш) – клавиши <span class="nmbr">0</span>...<span class="nmbr">9</span> 
		могут быть запрограммированы на выдачу определённых текстовых строк при 
		нажатии их в регистре &laquo;<i>НР</i>&raquo; (&laquo;<i>АР2</i>&raquo;). 
		Для программирования ключа необходимо задать его номер (от
		<span class="nmbr">1</span> для клавиши &laquo;<i>1</i>&raquo; до
		<span class="nmbr">12</span> для &laquo;<i>0</i>&raquo;) в регистре
		<span class="regn">R0</span>, а адрес текста ключа в памяти - в
		<span class="regn">R1</span> и выполнить <span class="cmds">EMT</span>
		<span class="nmbr">12</span> Первый байт текста должен содержать длину строки 
		в байтах и как символ не выводится. При содержимом <span class="regn">R1</span>, 
		равном <span class="nmbr">0</span>, происходит сброс ключа. Если программирование 
		ключей производится для языка высокого уровня, например Фокала, то тексты 
		ключей необходимо размещать в специально отведённой для этого зоне (для 
		Фокала - по адресам <span class="nmbr">1000</span>...<span class="nmbr">1377</span>).
		<span class="regn">R0</span> не сохраняется. Пример (программирование ключа
		<span class="nmbr">5</span>):</li>
	</ul>
	<pre>        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">7</span>,(<span class="regn">R1</span>)+            <span class="cmmnt">; Числосимволов текста</span>
        <span class="cmds">MOVB</span>    '<span class="strn">К</span>',(<span class="regn">R1</span>)+           <span class="cmmnt">; Текст</span>
        <span class="cmds">MOV</span>     '<span class="strn">EY</span>',(<span class="regn">R1</span>)+          <span class="cmmnt">; &quot;KEY N 5&quot;</span>
        <span class="cmds">MOV</span>     '<span class="strn"> N</span>',(<span class="regn">R1</span>)+
        <span class="cmds">MOV</span>     '<span class="strn"> 5</span>',(<span class="regn">R1</span>)+
        <span class="cmds">MOV</span>     #<span class="nmbr">5</span>,<span class="regn">R0</span>               <span class="cmmnt">; Номер ключа</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес текста ключа</span>
        <span class="cmds">EMT</span>     <span class="nmbr">12</span>                  <span class="cmmnt">; Запрограммировать ключ</span>
<span class="locl">0</span>:      <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Ожидание (вечный пустой цикл)</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">END</span></pre>
	<p>После запуска данной программы ключ будет запрограммирован. Если нажать клавишу &laquo;<i>СТОП</i>&raquo;, 
	можно выйти в ПМ или МСД и проверить результат, нажимая клавишу &laquo;<i>5</i>&raquo; 
	в регистре &laquo;<i>АР2</i>&raquo;. (Отметим, что ожидание с помощью
	<span class="cmds">BR</span> <span class="nmbr">0</span> в конце программы нам 
	понадобилось только потому, что мы ещё не успели познакомиться с командой останова 
	процессора.)</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">34</span> - <b>чтение 
		слова состояния дисплея</b> (ССД, не пугать с ССП!). ССД - это двухбайтное 
		машинное слово, дающее исчерпывающее представление об установленных режимах 
		дисплея БК-0010. По <span class="cmds">EMT</span> <span class="nmbr">34</span> 
		ССД заносится в <span class="regn">R0</span>, причём каждому режиму дисплея 
		соответствует один из битов: если он равен <span class="nmbr">1</span>, 
		то режим включён, если <span class="nmbr">0</span> - выключен (или включён 
		альтернативный режим). В системной области ОЗУ начиная с адреса
		<span class="nmbr">40</span> размещён массив служебных переменных - признаков 
		режимов, с которых и считывается при отработке <span class="cmds">EMT</span>
		<span class="nmbr">34</span> слово состояния дисплея. При этом каждому биту 
		ССД соответствует байт в памяти, его содержимое равно <span class="nmbr">
		0</span> при бите ССД, равном <span class="nmbr">0</span>, и
		<span class="nmbr">377</span> - при <span class="nmbr">1</span> (кроме бита
		<span class="nmbr">03</span>, сигнализирующего о включении русского регистра, 
		которому соответствует содержимое ячейки <span class="nmbr">43</span>, равное
		<span class="nmbr">200</span>), как это указано в таблице ССД.</li>
	</ul>
	<table id="mcmd" class="border3">
		<caption>Таблица ССД </caption>
		<tr>
			<th>
			<p>Разряд ССД</p>
			</th>
			<th>
			<p>Адрес байта</p>
			</th>
			<th>
			<p>Включённый режим дисплея</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">00</span></p>
			</td>
			<td>
			<p><span class="nmbr">40</span></p>
			</td>
			<td>
			<p>Цвет (режим <span class="nmbr">32</span> символа в строке)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">01</span></p>
			</td>
			<td>
			<p><span class="nmbr">41</span></p>
			</td>
			<td>
			<p>Инверсия экрана </p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">02</span></p>
			</td>
			<td>
			<p><span class="nmbr">42</span></p>
			</td>
			<td>
			<p>Режим &laquo;<i>РП</i>&raquo; (расширенной памяти)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">03</span></p>
			</td>
			<td>
			<p><span class="nmbr">43</span></p>
			</td>
			<td>
			<p>Регистр &laquo;<i>РУС</i>&raquo;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">04</span></p>
			</td>
			<td>
			<p><span class="nmbr">44</span></p>
			</td>
			<td>
			<p>Подчёркивание</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">05</span></p>
			</td>
			<td>
			<p><span class="nmbr">45</span></p>
			</td>
			<td>
			<p>Инверсия символа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">06</span></p>
			</td>
			<td>
			<p><span class="nmbr">46</span></p>
			</td>
			<td>
			<p>Индикация символов управления</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">07</span></p>
			</td>
			<td>
			<p><span class="nmbr">47</span></p>
			</td>
			<td>
			<p>Блокировка редактирован ия</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">08</span></p>
			</td>
			<td>
			<p><span class="nmbr">50</span></p>
			</td>
			<td>
			<p>Режим &laquo;<i>ГРАФ</i>&raquo;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">09</span></p>
			</td>
			<td>
			<p><span class="nmbr">51</span></p>
			</td>
			<td>
			<p>Режим &laquo;<i>ЗАП</i>&raquo;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">10</span></p>
			</td>
			<td>
			<p><span class="nmbr">52</span></p>
			</td>
			<td>
			<p>Режим &laquo;<i>СТИР</i>&raquo;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">11</span></p>
			</td>
			<td>
			<p><span class="nmbr">53</span></p>
			</td>
			<td>
			<p>Режим <span class="nmbr">32</span> символа в служебной строке</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">12</span></p>
			</td>
			<td>
			<p><span class="nmbr">54</span></p>
			</td>
			<td>
			<p>Подчёркивание в служебной строке</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">13</span></p>
			</td>
			<td>
			<p><span class="nmbr">55</span></p>
			</td>
			<td>
			<p>Инверсия символа в служебной строке</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">14</span></p>
			</td>
			<td>
			<p><span class="nmbr">56</span></p>
			</td>
			<td>
			<p>Гашение курсора</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">15</span></p>
			</td>
			<td>
			<p><span class="nmbr">57</span></p>
			</td>
			<td>
			<p>Не используется</p>
			</td>
		</tr>
	</table>
	<p>Очевидно, что, пользуясь ССД (или прямо проверяя значения служебных байтов 
	- переменных), можно установить, какие режимы дисплея включены, и программно 
	переключать нужные режимы как в кодах (выдавая необходимые команды с помощью
	<span class="cmds">EMT</span> <span class="nmbr">16</span>), так и на языках 
	высокого уровня.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">36</span> - <b>работа 
		с магнитофоном</b>. Это самое сложное из всех командных прерываний БК-0010. 
		Перед обращением к нему в <span class="regn">R1</span> заносится адрес
		<b>блока параметров</b>. Блок параметров - это специально выделенная зона 
		ОЗУ, куда предварительно записывается информация, обеспечивающая работу
		<span class="cmds">EMT</span> <span class="nmbr">36</span>. Блок параметров 
		может быть размещён начиная с любого чётного адреса ОЗУ, но в системной 
		области под него специально зарезервирована зона адресов
		<span class="nmbr">320</span>...<span class="nmbr">371</span>. Приведём 
		распределение ячеек этой зоны (при расположении блока параметров в любом 
		другом месте ОЗУ последовательность ячеек сохраняется):</li>
	</ul>
	<table id="mcmd" class="border3">
		<tr>
			<th>
			<p>Адреса байтов</p>
			</th>
			<th>
			<p>Содержимое</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">320</span></p>
			</td>
			<td>
			<p>Команда</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">321</span></p>
			</td>
			<td>
			<p>Ответ</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">322</span>, <span class="nmbr">323</span></p>
			</td>
			<td>
			<p>Адрес массива на запись или чтение</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">324</span>, <span class="nmbr">325</span></p>
			</td>
			<td>
			<p>Длина массива на запись (при чтении нужно обнулять)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">326</span>...<span class="nmbr">345</span></p>
			</td>
			<td>
			<p>Имя массива на запись или чтение</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">346</span>, <span class="nmbr">347</span></p>
			</td>
			<td>
			<p>Адрес текущего массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">350</span>, <span class="nmbr">351</span></p>
			</td>
			<td>
			<p>Длина текущего массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">352</span>...<span class="nmbr">371</span></p>
			</td>
			<td>
			<p>Имя текущего массива</p>
			</td>
		</tr>
	</table>
	<p>(<b>Текущим</b> называется массив (файл), имя которого прочитано последним, 
	независимо от того, загружался ли он в ОЗУ.) Вот по этим-то адресам и заносятся 
	все необходимые данные при чтении или записи файлов в Фокале, Бейсике, ПМ или 
	МСД.</p>
	<p>Байт &laquo;<b>команда</b>&raquo; в блоке параметров задаёт необходимый режим 
	работы ЭВМ с магнитофоном и может принимать значения:</p>
	<p><span class="nmbr">0</span> - останов двигателя магнитофона,</p>
	<p><span class="nmbr">1</span> - пуск двигателя магнитофона,</p>
	<p><span class="nmbr">2</span> - запись файла на МЛ,</p>
	<p><span class="nmbr">3</span> - чтение файла с МЛ.</p>
	<p><span class="nmbr">4</span> - фиктивное чтение.</p>
	<p>Отметим, что при исполнении команд <span class="nmbr">2</span>,
	<span class="nmbr">3</span> и <span class="nmbr">4</span> двигатель магнитофона 
	включается и отключается автоматически, отдельная подача команд
	<span class="nmbr">0</span> и <span class="nmbr">1</span> не требуется. (Вообще 
	говоря, команды <span class="nmbr">0</span> и <span class="nmbr">1</span> нужны 
	только при оборудовании магнитофона дистанционным управлением. В этом случае, 
	когда после завершения операций <span class="nmbr">2</span>,
	<span class="nmbr">3</span> или <span class="nmbr">4</span> БК отключает двигатель, 
	невозможно даже просто перемотать ленту - дистанционное управление блокирует 
	запуск двигателя с клавиш магнитофона. Для ручной перемотки нужно либо отключить 
	ДУ, отстыковав соответствующий штекер магнитофонного кабеля БК, либо, что проще, 
	заранее предусмотреть в программе команды включения-выключения двигателя аналогично 
	реализации МП и МС в МСТД. - <em>Прим. ред.</em>)</p>
	<p>Байт <b>ответа</b> сообщает о результатах исполнения команды и может принимать 
	следующие значения:</p>
	<p><span class="nmbr">0</span> - операция завершена без ошибок,</p>
	<p><span class="nmbr">1</span> - имя файла на МЛ не совпадает с заданным,</p>
	<p><span class="nmbr">2</span> - ошибка контрольной суммы,</p>
	<p><span class="nmbr">4</span> - останов по клавише &laquo;<i>СТОП</i>&raquo;.</p>
	<p>Теперь, наверное, вам понятно, как записать или прочитать заданный файл. 
	Рассмотрим пример (выбран вариант записи файла на МЛ, как более сложный):</p>
	<pre><span class="cmmnt">; Запись файла на МЛ с помощью EMT</span> <span class="cmmnt">36</span>
<span class="labl">BEG</span>:    <span class="cmds">MOV</span>     #<span class="nmbr">346</span>,<span class="regn">R3</span>             <span class="cmmnt">; Конец имени файла</span>
<span class="locl">0</span>:      <span class="cmds">MOVB</span>    #<span class="nmbr">40</span>,-(<span class="regn">R3</span>)           <span class="cmmnt">; Очистка имени файла</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">320</span>,<span class="regn">R3</span>             <span class="cmmnt">; (запись пробелов во все байты,</span>
        <span class="cmds">BNE</span>     <span class="nmbr">0</span>                   <span class="cmmnt">; до R3 = 320)</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">2</span>,(<span class="regn">R3</span>)+            <span class="cmmnt">; Команда &quot;запись&quot;; R3+2 = 322</span>
        <span class="cmds">MOV</span>     '<span class="strn">A=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Запрос &quot;адреса&quot;</span>
        <span class="cmds">CALL</span>    <span class="labl">INP</span>                 <span class="cmmnt">; Ввод адреса; R3+2 = 324</span>
        <span class="cmds">MOV</span>     '<span class="strn">Д=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Запрос &quot;ДЛИНА=&quot;</span>
        <span class="cmds">CALL</span>    <span class="labl">INP</span>                 <span class="cmmnt">; Ввод длины; R3+2 = 326</span>
        <span class="cmds">MOV</span>     '<span class="strn">И=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Запрос &quot;ИМЯ=&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Выдача запроса</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; на экран</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">5020</span>,<span class="regn">R2</span>            <span class="cmmnt">; Ограничители; &quot;ВВОД&quot; или длина 16д</span>
        <span class="cmds">MOV</span>     <span class="regn">R3</span>,<span class="regn">R1</span>               <span class="cmmnt">; Адрес имени - 326</span>
        <span class="cmds">EMT</span>     <span class="nmbr">10</span>                  <span class="cmmnt">; Ввод имени</span>
        <span class="cmds">MOVB</span>    #<span class="nmbr">40</span>,-(<span class="regn">R1</span>)           <span class="cmmnt">; Заменить последний байт имени</span>
                                    <span class="cmmnt">; (код 12) на пробел</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">320</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес блока параметров</span>
        <span class="cmds">EMT</span>     <span class="nmbr">36</span>                  <span class="cmmnt">; Выполнить запись файла</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ожидание нажатия клавиши</span>
        <span class="cmds">BR</span>      <span class="labl">BEG</span>                 <span class="cmmnt">; Программа зациклена</span>
<span class="cmmnt">; Выдача запросов, ввод числовых данных</span>
<span class="labl">INP</span>:    <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Первый символ запроса</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Второй символ</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">100472</span>            <span class="cmmnt">; Ввод восьмеричного числа в R5</span>
        <span class="cmds">MOV</span>     <span class="regn">R5</span>,(<span class="regn">R3</span>)+            <span class="cmmnt">; Число - в блок параметров; R3+2</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">12</span>,<span class="regn">R0</span>              <span class="cmmnt">; Перевод</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; строки</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход из подпрограммы</span>
        <span class="pscm">END</span>                         <span class="cmmnt">; Конец программы</span></pre>
	<p>Построчный комментарий видимо, делает ненужными дальнейшие пояснения. Отметим 
	только, что для ввода восьмеричного числа, задающего начальный адрес и длину, 
	мы воспользовались подпрограммой ПЗУ, расположенной по адресу
	<span class="nmbr">100472</span>, - это избавило от необходимости отводить под 
	аналогичную, довольно длинную подпрограмму место в ОЗУ. Часть команд программы, 
	повторяющихся дважды, вынесены в подпрограмму <span class="labl">INP</span>. 
	Данный алгоритм не является единственно возможным, но автор стремился сделать 
	программу предельно короткой. Удалось ли это - решать читателям, когда они начнут 
	писать свои аналогичные программы. Тем и интересно программирование, что вариантов 
	решения одной задачи, даже не слишком сложной, может быть множество. Нередко 
	при работе с файлами требуется не ввод адреса и длины с клавиатуры, а задание 
	этих параметров программно (например, начало и длина файла, набираемого в редакторе 
	текстов). тогда алгоритм будет иным. Если же требуется не запись файла на МЛ, 
	а его чтение, фиктивное чтение или управление магнитофоном, характер программы 
	также изменится. Мы надеемся, что после приведённого примера читателю не составит 
	труда написать эти программы самостоятельно.</p>
	<p>Пользуясь случаем, рассмотрим кратко формат записи файла БК-0010 на МЛ. Файл 
	начинается с <b>установочной последовательности</b> (УсП), которая представляет 
	собой запись <span class="nmbr">10000</span> нулевых битов. Эта последовательность 
	нулей служит, во-первых, для поиска начала файла, а во-вторых, для автоматической 
	подстройки скорости чтения (для разных БК-0010, а особенно для разных магнитофонов 
	она может существенно различаться; это же свойство обеспечивает возможность 
	записи файлов с повышенной скоростью). Но ведь последовательность из
	<span class="nmbr">10000</span> нулей может присутствовать и в самом файле! 
	Чтобы не спутать такой фрагмент с началом файла, на МЛ вслед за УсП записывается
	<b>маркер</b> - специальная кодовая последовательность импульсов. Помимо опознавания 
	начала файла маркер служит также для определения <b>фазы</b> записи - ведь полярность 
	выхода различных магнитофонов может быть разной. Если маркер опознан, начинается 
	чтение следующего за ним <b>оглавления файла</b>, представляющего собой точную 
	копию блока информации, находящейся при записи файла по адресам
	<span class="nmbr">322</span>...<span class="nmbr">345</span> (т.е. адреса, 
	длины и имени файла), но при чтении эти параметры заносятся по адресам
	<span class="nmbr">346</span>...<span class="nmbr">371</span>. После чтения 
	оглавления производится сверка имени файла, и при его несовпадении с заданным 
	в ячейку <span class="nmbr">301</span> записывается байт ответа и производится 
	выход в основную программу. Затем, если имя совпало с заданным на чтение, производится, 
	в зависимости от команды, истинное либо фиктивное чтение. После загрузки в ОЗУ 
	БК считывает последнее слово файла - <b>контрольную сумму</b> (КС). Затем вычисляется 
	КС загруженного в ОЗУ массива и сравнивается с прочитанной. В зависимости от 
	результата этого сравнения формируется байт ответа в блоке параметров, и работа 
	команды <span class="cmds">EMT</span> <span class="nmbr">36</span> завершается. 
	Запись производится аналогично. КС, сопровождающая файл на МЛ, вычисляется как 
	сумма всех его байтов с учётом битов переноса. При вычислении КС загруженного 
	файла его УсП, маркер, оглавление и сама КС не учитываются.</p>
	<p>(Завершая обсуждение функции <span class="cmds">EMT</span>
	<span class="nmbr">36</span>, следует обратить внимание на её использование 
	в БК, оснащённых дисководом. При работе с большинством имеющихся сегодня дисковых 
	систем (кроме разве лишь давно устаревших версий НОРТОНа для БК без расширенного 
	ОЗУ) реализуется автоматическая &laquo;<i>переадресация</i>&raquo; чтения- записи 
	файлов по <span class="cmds">EMT</span> <span class="nmbr">36</span> на диск. 
	Делается это путём перехвата <span class="cmds">EMT</span>-прерывания и подмены 
	функции <span class="cmds">EMT</span> <span class="nmbr">36</span> на её &laquo;<i>дисковую</i>&raquo; 
	версию, что обеспечивает нормальную работу с диском большинства старых программ, 
	рассчитанных на магнитофон.</p>
	<p>Из сказанного следует два достаточно важных вывода. Во-первых, при написании 
	прикладных программ с целью обеспечения их универсальности ввод-вывод файлов 
	нужно производить стандартным способом через <span class="cmds">EMT</span>
	<span class="nmbr">36</span>, а не путём прямого обращения к &laquo;<i>магнитофонным</i>&raquo; 
	подпрограммам монитора (кроме особых случаев, когда это действительно необходимо, 
	а программа рассчитана только на работу с магнитной лентой). Второй вывод касается 
	адаптации уже существующих программ к диску. Эта адаптация в большинстве случаев 
	состоит в обеспечении загрузки с диска отдельных частей многофайловых программ. 
	Так вот, делать это следует тоже только с использованием стандартной функции
	<span class="cmds">EMT</span> <span class="nmbr">36</span>. Попытки же писать 
	собственные загрузчики, непосредственно работающие с каталогом имён и секторами 
	данных на диске, приводят к тому, что подобная адаптация работает лишь в одной 
	ОС. А в результате кому-то приходится в конце концов &laquo;<i>взламывать</i>&raquo; 
	такую программу и делать адаптацию заново, дабы получить возможность работы 
	с ней в других операционных системах. - <em>Прим. ред.</em>)</p>
	<p>Теперь кратко упомянем несколько оставшихся <span class="cmds">EMT</span>. 
	Все они относятся к работе с ТЛГ-каналом. Поскольку эти команды применяются, 
	когда необходимо обеспечить связь между несколькими ЭВМ, между ЭВМ и принтером 
	с последовательным каналом и т.п., то ясно, что они - &laquo;<i>не для простых 
	смертных</i>&raquo;, а для довольно квалифицированных пользователей (программистов). 
	Как уже говорилось, для использования ТЛГ-канала в некоторых моделях БК необходимо 
	установить на плате компьютера перемычки, чтобы соединить вход и выход ТЛГ с 
	контактами разъёма порта ввода-вывода, что также требует некоторой квалификации. 
	Перемычки показаны на принципиальной схеме ЭВМ (см. № <span class="nmbr">2</span> 
	за <span class="nmbr">1994</span> г., с.<span class="nmbr">35</span>, справа 
	внизу, перемычки <span class="nmbr">52</span> и <span class="nmbr">53</span>. 
	- <em>Прим. ред.</em>), а мы на этом останавливаться не будем, чтобы не &laquo;<i>провоцировать</i>&raquo; 
	начинающих на рискованные эксперименты, грамотный же специалист легко найдёт 
	их сам. Как говорится, &laquo;Богу - Богово...&raquo;.)</p>
	<p>Несколько более подробные сведения о данных командах содержатся в &laquo;<i>Руководстве 
	системного программиста</i>&raquo;, прилагаемом к БК, а мы их просто перечислим 
	и назовём.</p>
	<ul>
		<li><span class="cmds">EMT</span> <span class="nmbr">40</span> - <b>инициализация 
		драйвера тлг</b>-<b>канала</b>.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">42</span> - <b>передача 
		байта по тлг</b>- <b>линии</b>.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">44</span> - <b>приём 
		байта с тлг</b>-<b>линии</b>.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">46</span> - <b>передача 
		массива по тлг</b>-<b>линии</b>.</li>
		<li><span class="cmds">EMT</span> <span class="nmbr">50</span> - <b>приём 
		массива с тлг</b>- <b>линии</b>.</li>
	</ul>
	<p>В <span class="cmds">EMT</span>-диспетчере БК-0010 предусмотрены также ещё
	<span class="nmbr">16</span> так называемых <b>резервных входов</b>
	<span class="cmds">EMT</span> с номерами <span class="nmbr">52</span>,
	<span class="nmbr">54</span>, ... <span class="nmbr">110</span>. При обращении 
	к ним происходит передача управления по адресам, равным соответственно
	<span class="nmbr">160000</span>, <span class="nmbr">160004</span>, ...
	<span class="nmbr">160074</span>. Эти входы могут быть использованы, если вместо 
	тест-ПЗУ разместить, начиная с адреса <span class="nmbr">160000</span>, ПЗУ 
	пользователя. (При подключённом контроллере дисковода его ПЗУ попадает как раз 
	в область адресов начиная с <span class="nmbr">160000</span>, и тогда некоторые 
	из названных <span class="cmds">EMT</span>-функций можно использовать для вызова 
	подпрограмм доступа к диску. Подробнее об этом см. в № <span class="nmbr">1</span> 
	за <span class="nmbr">1993</span> г., с. <span class="nmbr">102</span>. -
	<em>Прим. ред.</em>)</p>
	<p>На этом рассмотрение командных прерываний <span class="cmds">EMT</span> можно 
	считать законченным. К вопросу о том, как использовать полученные знания, мы 
	вернёмся позже, а пока продолжим изучение операторов ассемблера и первым разберём 
	уже упомянутый ранее оператор <span class="cmds">TRAP</span>.</p>
	<ul>
		<li><span class="cmds">TRAP</span> <span class="var">X</span> - <b>командное 
		прерывание по вектору</b> <span class="nmbr">34</span>, где
		<span class="var">X</span> – номер <span class="cmds">TRAP</span>, восьмеричное 
		число от <span class="nmbr">0</span> до <span class="nmbr">377</span>. Предназначен 
		этот оператор в основном для программ пользователя, а в остальном он очень 
		похож на <span class="cmds">EMT</span>. Пользователь может написать свою 
		программу <span class="cmds">TRAP</span>-диспетчера и создать свой пакет 
		программ обработки прерываний <span class="cmds">TRAP</span>, аналогичный
		<span class="cmds">EMT</span>-пакету, но решающий другие задачи. Воспользуемся 
		случаем и приведём пример простейшего <span class="cmds">TRAP</span>-диспетчера. 
		Предположим, что мы хотим использовать прерывание <span class="cmds">TRAP</span> 
		для такой банальной цели, как вывод на экран символов, коды которых соответствуют 
		номерам <span class="cmds">TRAP</span>. Вспомним, как выполняется командное 
		прерывание. Обнаружив в программе команду прерывания <span class="cmds">
		TRAP</span>, процессор выполняет действия, которые можно условно изобразить 
		следующей программой:</li>
	</ul>
	<pre>        <span class="cmds">MFPS</span>    -(<span class="regn">SP</span>)               <span class="cmmnt">; Сохранить текущее ССП</span>
        <span class="cmds">MOV</span>     <span class="regn">PC</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить адрес следующей</span>
                                    <span class="cmmnt">; команды</span>
        <span class="cmds">MTPS</span>    @#<span class="nmbr">36</span>                <span class="cmmnt">; Записать новое ССП</span>
        <span class="cmds">MOV</span>     @#<span class="nmbr">34</span>,<span class="regn">PC</span>             <span class="cmmnt">; Записать адрес программы</span>
                                    <span class="cmmnt">; обработки прерывания</span></pre>
	<p>Конечно, такую программу нам писать не нужно, процессор делает это сам: программа 
	обработки прерываний заложена в него на аппаратном уровне (если точнее - на 
	так называемом <b>микропрограммном</b>). Но вот процессор перешёл к программе 
	обработки прерывания. Что будет собой представлять эта программа для нашего 
	случая? Раз мы хотим получить вывод символов, код которых соответствует номеру
	<span class="cmds">TRAP</span>, нам, видимо, следует извлечь этот номер. Вспомним, 
	что коды <span class="cmds">TRAP</span> лежат в диапазоне <span class="nmbr">
	104400</span>...<span class="nmbr">104777</span>, т.е. искомый номер - это младший 
	байт команды. А как &laquo;<i>выудить</i>&raquo; командный код? В стеке у нас 
	сохранен адрес следующей команды. Уменьшив его на <span class="nmbr">2</span>, 
	получим адрес <span class="cmds">TRAP</span>. А дальше уже просто: косвенное 
	обращение по этому адресу даст код <span class="cmds">TRAP</span>, используем 
	его младший байт как код символа, вот и всё! Но прежде чем всё это делать, мы 
	должны записать в вектор <span class="nmbr">34</span> значение, соответствующее 
	адресу нашей программы обработки прерывания. Пусть программа обработки
	<span class="cmds">TRAP</span> помечена меткой <span class="labl">TRP</span>. 
	Запишем:</p>
	<pre>        <span class="cmds">MOV</span>     #<span class="labl">TRP</span>,@#<span class="nmbr">34</span>           <span class="cmmnt">; Записать новый</span>
                                    <span class="cmmnt">; вектор 34</span></pre>
	<p>Если бы требовалось на время исполнения <span class="cmds">TRAP</span> запретить 
	все прерывания от внешних устройств, мы могли бы задать также нужный приоритет 
	процессора во втором слове вектора, например.</p>
	<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">340</span>,@#<span class="nmbr">36</span>           <span class="cmmnt">; Задать максимальный</span>
                                    <span class="cmmnt">; приоритет</span></pre>
	<p>Однако в данном случае это не принципиально. А теперь напишем саму программу 
	обработки прерывания.</p>
	<pre><span class="cmmnt">; Программа обработки прерывания TRAP</span>
<span class="labl">TRP</span>:    <span class="cmds">MOV</span>     <span class="regn">R0</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить R0</span>
        <span class="cmds">MOV</span>     <span class="nmbr">2</span>(<span class="regn">SP</span>),<span class="regn">R0</span>            <span class="cmmnt">; Извлечь адрес следующей команды</span>
        <span class="cmds">MOV</span>     -(<span class="regn">R0</span>),<span class="regn">R0</span>            <span class="cmmnt">; Извлечь текущую команду (TRAP)</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Вывести на экран символ, код</span>
                                    <span class="cmmnt">; которого в младшем байте R0</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; Восстановить R0</span>
        <span class="cmds">RTI</span>                         <span class="cmmnt">; Выход из прерывания</span></pre>
	<p>Как видим, программа получилась очень простой, это диктуется целью, которую 
	мы себе поставили. Если теперь написать, например, последовательность команд:
	<span class="cmds">TRAP</span> <span class="nmbr">101</span>,
	<span class="cmds">TRAP</span> <span class="nmbr">102</span>,
	<span class="cmds">TRAP</span> <span class="nmbr">103</span>, то на экран будут 
	выведены три символа: &laquo;<i>АВС</i>&raquo;. Команды их выдачи на экран занимают 
	всего три слова, тогда как, например, при &laquo;<i>классическом</i>&raquo; 
	способе вывода (занести код символа в регистр <span class="regn">R0</span> и 
	выполнить <span class="cmds">EMT</span> <span class="nmbr">16</span>) потребовалось 
	бы девять слов! Между тем, сама программа обработки <span class="cmds">TRAP</span> 
	занимает у нас семь слов. При достаточно частом обращении к ней мы получим существенную 
	экономию памяти. Если же задача сохранения и последующего восстановления
	<span class="regn">R0</span> не ставится, то программа обработки
	<span class="cmds">TRAP</span> будет ещё короче.</p>
	<p>(Может показаться, что в данном примере функция <span class="cmds">TRAP</span> 
	используется слишком уж &laquo;<i>примитивно</i>&raquo;. Однако на практике 
	необходимость в реализации подобного механизма передачи аргумента функции через 
	номер команды <span class="cmds">TRAP</span> встречается довольно часто. Так, 
	в трансляторе вильнюсского Бейсика именно таким способом осуществляется обращение 
	к подпрограмме выдачи на экран сообщений об ошибках: номер ошибки содержится 
	в младшем байте команды <span class="cmds">TRAP</span>. - <em>Прим. ред.</em>)</p>
	<ul>
		<li><span class="cmds">IOT</span> - <b>командное прерывание по вектору
		<span class="nmbr">20</span></b>. Предназначено для обслуживания устройств 
		ввода-вывода в операционных системах, в БК-0010 практически не используется. 
		Выполняется точно так же, как <span class="cmds">EMT</span> или
		<span class="cmds">TRAP</span>, с той разницей, что младший байт команды 
		не содержит дополнительной информации (номера). Может быть использовано 
		для обращения к какой-либо одной подпрограмме.</li>
		<li><span class="cmds">BPT</span> - <b>командное прерывание по вектору
		<span class="nmbr">14</span></b>. Используется в отладчиках, подробно будет 
		рассмотрено позже.</li>
		<li><span class="cmds">RTI</span> - <b>возврат из прерывания</b>. Используется 
		для выхода из подпрограммы обработки прерываний (кроме отладочных). Восстанавливает 
		стек, ССП и адрес очередной команды. При отработке оператора
		<span class="cmds">RTI</span> процессор автоматически выполняет (на микропрограммном 
		уровне) действия, аналогичные последовательности команд:</li>
	</ul>
	<pre>        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">PC</span>            <span class="cmmnt">; Восстановить адрес</span>
                                    <span class="cmmnt">; команды прерванной</span>
                                    <span class="cmmnt">; программы</span>
        <span class="cmds">MTPS</span>    (<span class="regn">SP</span>)+               <span class="cmmnt">; Восстановить ССП</span></pre>
	<ul>
		<li><span class="cmds">RTT</span> - <b>возврат из отладочного прерывания</b>. 
		Используется для выхода из отладочного прерывания, когда установлен
		<span class="symb">T</span>-разряд ССП, но может применяться и для выхода 
		из других прерываний. Отличие <span class="cmds">RTT</span> от
		<span class="cmds">RTI</span> состоит лишь в том, что прерывание по
		<span class="symb">T</span>-разряду при отработке <span class="cmds">RTT</span> 
		не наступает, а выполняется следующая команда и лишь после неё происходит 
		прерывание по <span class="symb">T</span>-разряду. Можно сказать, что команда
		<span class="cmds">RTT</span> &laquo;<i>непрозрачна при трассировке</i>&raquo;. 
		(Подробно о её использовании мы поговорим позднее.)</li>
		<li><span class="cmds">HALT</span> - <b>останов</b>. В сущности, эта команда 
		есть не что иное, как командное прерывание по вектору <span class="nmbr">
		4</span>, и дальнейшие действия ЭВМ всецело зависят от того, как построена 
		программа обработки прерывания по этому вектору. Команда (обычно неправильно 
		относимая к &laquo;<i>командам управления машиной</i>&raquo;) может быть 
		использована не только для останова, но и для любых других целей, аналогично 
		прочим командам прерываний, но нужно помнить, что, изменяя вектор
		<span class="nmbr">4</span> и программу обработки прерывания по этому вектору, 
		мы меняем и порядок работы клавиши &laquo;<i>СТОП</i>&raquo;.</li>
	</ul>
	<h2><a name="toc_36"></a>Операторы управления машиной</h2>
	<ul>
		<li><span class="cmds">WAIT</span> - <b>ожидание</b>. Приостанавливает выполнение 
		текущей программы до прерывания от внешних устройств (клавиатуры, таймера, 
		клавиши &laquo;<i>СТОП</i>&raquo;). Может быть использован для организации 
		паузы и ожидания реакции пользователя (или прерывания от внешних устройств), 
		но нужно помнить, что прерывания возникают при этом в соответствии с приоритетом 
		внешних устройств и процессора, и для прерывания, например, от клавиатуры 
		приоритет процессора должен быть менее <span class="nmbr">4</span> (Применяется 
		редко.)</li>
		<li><span class="cmds">RESET</span> <b>сброс внешних устройств</b>, Оператор 
		вызывает выдачу сигнала INIT по командной магистрали общей шины, который 
		сбрасывает все устройства ЭВМ (порт, системные регистры) в исходное состояние. 
		Особенность выполнения данного оператора на БК-0010 такова, что после него 
		обычно необходимо инициализировать драйвер клавиатуры командой
		<span class="cmds">EMT</span> <span class="nmbr">4</span>. Применяется крайне 
		редко. (Оператор <span class="cmds">RESET</span> может быть использован 
		и нестандартно, обеспечивая при этом возможность распознавания одновременного 
		нажатия нескольких клавиш на клавиатуре БК - см. № <span class="nmbr">1</span> 
		за <span class="nmbr">1993</span> г., с . <span class="nmbr">129</span>. 
		- <em>Прим. ред.</em>)</li>
	</ul>
	<h2><a name="toc_37"></a>Прочие операторы</h2>
	<ul>
		<li><span class="cmds">NOP</span> - <b>&laquo;пустая&raquo; операция</b>. 
		Используется при отладке, если нужно временно исключить какую-то команду, 
		или для создания небольшой задержки (около <span class="nmbr">4</span>&nbsp;мкс). 
		Не делает ничего. Код этой команды - <span class="nmbr">240</span>.</li>
	</ul>
	<p>К данной группе относятся также <b>команды изменения признаков</b>, т.е. 
	разрядов <span class="nmbr">00</span>...<span class="nmbr">03</span> ССП. Используются 
	они редко.</p>
	<ul>
		<li><span class="cmds">CLN</span> - <b>очистка <span class="symb">N</span></b>.</li>
		<li><span class="cmds">CLZ</span> - <b>очистка <span class="symb">Z</span></b>.</li>
		<li><span class="cmds">CLV</span> - <b>очистка <span class="symb">V</span></b>.</li>
		<li><span class="cmds">CLC</span> - <b>очистка <span class="symb">C</span></b>.</li>
		<li><span class="cmds">CCC</span> - <b>очистка всех разрядов</b>.</li>
		<li><span class="cmds">SEN</span> - <b>установка <span class="symb">N</span></b>.</li>
		<li><span class="cmds">SEZ</span> - <b>установка <span class="symb">Z</span></b>.</li>
		<li><span class="cmds">SEV</span> - <b>установка <span class="symb">V</span></b>.</li>
		<li><span class="cmds">SEC</span> - <b>установка <span class="symb">C</span></b>.</li>
		<li><span class="cmds">SCC</span> - <b>установка всех разрядов</b>.</li>
	</ul>
	<p>(Существуют и другие машинные команды, обеспечивающие очистку или установку 
	одновременно двух или трёх признаков, но они не имеют сокращённой ассемблерной 
	записи. Их коды приведены в Приложении <span class="nmbr">4</span> к книге:
	<em>Осетинский А.Г., Осетинский М.Г., Писаревский А.Н.</em> Фокал для микро- 
	и мини-компьютеров. Л.: Машиностроение, <span class="nmbr">1988</span>. -
	<em>Прим. ред.</em>)</p>
	<h2><a name="toc_38"></a>Псевдооператоры</h2>
	<p>Как уже неоднократно говорилось, каждый оператор с принадлежащими ему операндами 
	(если они имеются) при трансляции переводится в машинный код, образуя машинную 
	команду, или инструкцию. Но имеется ряд специфических задач, для решения которых 
	обычных операторов недостаточно (например, резервирование места под константы, 
	переменные и массивы, запись в память текстов (вы помните, как неуклюже мы делали 
	это в наших прежних примерах?), символьных и цифровых последовательностей и 
	т.п.) Этой цели служат <b>псевдооператоры</b>, или псевдокоманды.</p>
	<p>В отличие от обычных операторов, псевдокоманды при трансляции не переводятся 
	в машинные коды, они представляют собой лишь указания транслятору, что записать 
	в память с текущего адреса или что выполнить при трансляции. Заносимая в память 
	информация, если она имеется, следует после псевдооператора. Рассмотрим, какие 
	псевдооператоры имеются в ассемблерах &laquo;<i>МИКРО</i>&raquo;. Все они начинаются 
	с символа &laquo;<b>точка</b>&raquo;, который в ассемблере означает <b>текущий 
	адрес</b>. Таким образом, любой псевдооператор можно истолковать как указание 
	транслятору: &laquo;<i>записать с текущего адреса...</i>&raquo;.</p>
	<ul>
		<li><span class="pscm">.E</span> - <b>обнуление слова или байта и приведение 
		текущего адреса к чётному</b>. Как известно, команды ассемблера после трансляции 
		занимают от одного до трёх машинных слов. Но слово это два байта, а значит, 
		любая команда может после трансляции начинаться лишь с <b>чётного</b> адреса. 
		Однако бывают ситуации, когда при написании программы мы не можем с определённостью 
		сказать, чётным ли будет текущий адрес. Это случается, например, если в 
		текст программы вписана последовательность символов или байтовых кодов С 
		другой стороны, при выводе, скажем, текстовых сообщений удобно отмечать 
		конец текста нулевым байтом. Обе задачи решаются одновременно, если в конце 
		текста (или последовательности кодов) стоит псевдооператор
		<span class="pscm">.E</span>. Встречая его, транслятор заносит в память 
		нулевой байт, если адрес нечётный, или нулевое слово, если чётный. Адрес, 
		таким образом, всегда приводится к чётному. Кроме того, данный псевдооператор 
		можно применять для резервирования отдельных слов памяти под переменные, 
		если их исходное значение - ноль.</li>
		<li><span class="pscm">.+</span><span class="var">Х</span> - <b>зарезервировать
		<span class="var">X</span> байт ОЗУ</b>. Встречая в тексте этот псевдооператор, 
		транслятор обнуляет указанное количество байтов (вместо
		<span class="var">X</span> записывается конкретное восьмеричное число) и 
		увеличивает на <span class="var">X</span> текущий адрес. Применяется для 
		выделения памяти под массивы, приведения текущего адреса к нужному, &laquo;<i>подгонки</i>&raquo; 
		длины программ под &laquo;<i>круглое</i>&raquo; число и т.п. Пусть, например, 
		мы с помощью оператора <span class="cmds">EMT</span> <span class="nmbr">
		10</span> будем вводить текст максимальной длиной <span class="nmbr">20</span> 
		байт, а начало буфера текста соответствует метке <span class="labl">Т1</span>. 
		Тогда для выделения буфера под текст достаточно записать:
		<span class="labl">Т1</span>: <span class="pscm">.+</span><span class="nmbr">20</span>.</li>
		<li><span class="pscm">.#</span><span class="var">Х</span> или
		<span class="pscm">.#</span><span class="labl">MET</span> - <b>запись константы 
		в слово по текущему адресу</b>. Константой может быть как восьмеричное число 
		(без знака или со знаком &laquo;<i>минус</i>&raquo;), так и имя глобальной 
		метки (можно и с коррекцией адреса в виде выражений <span class="labl">MET</span>+<span class="var">Х</span> 
		или <span class="labl">MET</span>-<span class="var">Х</span>, где
		<span class="var">X</span> - восьмеричное число). В составе псевдокоманды 
		может быть через запятую перечислено несколько констант, например:
		<pre>&nbsp;<span class="pscm">.#</span><span class="nmbr">14563</span>,<span class="labl">ТЕХ</span>+<span class="nmbr">140</span>,<span class="labl">Т27</span>,-<span class="nmbr">20</span>,<span class="nmbr">24</span>,<span class="nmbr">0</span>,<span class="nmbr">532</span></pre>
		</li>
	</ul>
	<p>Каждая из перечисленных таким образом констант записывается в очередное машинное 
	слово. Если константой является адрес метки, то его абсолютное значение транслятор 
	заносит только после компоновки программы. В менее совершенных версиях ассемблеров 
	допускается запись после <span class="pscm">.#</span> только одного значения 
	константы, но зато часто разрешается писать по несколько псевдооператоров в 
	строке.</p>
	<p>Этот псевдооператор широко применяется для записи констант, переменных (с 
	заданием их исходного значения), а также строк абсолютных адресов меток, которые 
	можно затем использовать для адресации различных модулей программы.</p>
	<p>Приведём пример такой записи. Пусть в программе имеется
	<span class="nmbr">10</span> модулей, помеченных метками <span class="labl">
	М0</span>, <span class="labl">M1</span>, <span class="labl">М2</span>, ...
	<span class="labl">М9</span>. а директивы передачи управления этим модулям - 
	вводимые с клавиатуры цифры &laquo;<i>0</i>&raquo;, &laquo;<i>1</i>&raquo;, &laquo;<i>2</i>&raquo;, 
	... &laquo;<i>9</i>&raquo; соответственно. Как оптимально организовать блок 
	управления такой программой? Запишем:</p>
	<pre><span class="labl">BEG</span>:    <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ввод директивы</span>
        <span class="cmds">ASL</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Умножить на 2 код цифры</span>
        <span class="cmds">JMP</span>     @<span class="labl">ADR</span>-<span class="nmbr">140</span>(<span class="regn">R0</span>)        <span class="cmmnt">; Передача управления модулю</span>
<span class="labl">ADR</span>:    <span class="pscm">.#</span><span class="labl">М0</span>,<span class="labl">М1</span>,<span class="labl">М2</span>,<span class="labl">M3</span>,<span class="labl">М4</span>,<span class="labl">М5</span>,<span class="labl">М6</span>,<span class="labl">М7</span>,<span class="labl">М8</span>,<span class="labl">М9</span></pre>
	<p>Первая строка программы вполне понятна, мы заносим с клавиатуры в
	<span class="regn">R0</span> код директивы, причём нулю соответствует код
	<span class="nmbr">60</span>, единице - <span class="nmbr">61</span>, и т.д. 
	В последней же строке записаны адреса меток модулей, на которые мы должны передать 
	управление. Адрес каждой метки, естественно, занимает одно слово, а значит, 
	адреса следуют с интервалом два байта, а коды управления <span class="nmbr">
	60</span>, <span class="nmbr">61</span>... и т.д. - с интервалом в один байт. 
	Чтобы привести последний в соответствие с интервалом следования меток, во второй 
	строке мы умножаем код на <span class="nmbr">2</span>. А вот в третьей строке, 
	которая, собственно, и передаёт управление, использованы все возможные ухищрения 
	адресации. Мы передаём управление по адресу, который, в свою очередь, записан 
	по адресу (двойная косвенность!), определяемому выражением:
	<span class="regn">R0</span>+#<span class="labl">ADR</span>-<span class="nmbr">140</span>. 
	А число <span class="nmbr">140</span> есть не что иное как удвоенный код символа &laquo;<i>0</i>&raquo;. 
	Таким образом, если, например, мы вводим директиву &laquo;<i>3</i>&raquo;, в 
	результате у нас получается <span class="nmbr">63</span>*<span class="nmbr">2</span>+#<span class="labl">ADR</span>-<span class="nmbr">140</span> 
	= #<span class="labl">ADR</span>+<span class="nmbr">6</span>. А по адресу #<span class="labl">ADR</span>+<span class="nmbr">6</span> 
	записан адрес метки <span class="labl">М3</span>, на неё и будет передано управление. 
	Отметим, что наша программа не имеет защиты от ошибок - если мы введём директиву, 
	код которой больше кода клавиши &laquo;<i>9</i>&raquo; или меньше, чем у &laquo;<i>0</i>&raquo;, 
	результат будет непредсказуем. Следовало бы после оператора
	<span class="cmds">EMT</span> <span class="nmbr">6</span> проверять содержимое
	<span class="regn">R0</span> на соответствие заданному диапазону кодов, например 
	так:</p>
	<pre>        <span class="cmds">CMPB</span>    '<span class="strn">0</span>',<span class="regn">R0</span>
        <span class="cmds">BHI</span>     <span class="labl">BEG</span>
        <span class="cmds">CMPB</span>    '<span class="strn">9</span>',<span class="regn">R0</span>
        <span class="cmds">BLO</span>     <span class="labl">BEG</span></pre>
	<p>(В первоначальном тексте примера мы этот фрагмент не привели, заботясь о 
	его максимальной простоте.)</p>
	<ul>
		<li><span class="pscm">.B</span>: - <b>запись константы в байт по текущему 
		адресу</b>. В качестве констант могут использоваться только восьмеричные 
		числа от <span class="nmbr">0</span> до <span class="nmbr">377</span>. Несколько 
		чисел после одного псевдооператора может быть записано через запятую (в 
		ранних версиях - только одно число). Эта псевдокоманда применяется в основном 
		для записи строк кодов управления режимами вывода на экран или для простейшей 
		генерации звука (код <span class="nmbr">7</span> - щелчок как при нажатии 
		на клавишу). Можно также, записав строку кодов клавиш управления, найти 
		в ней заданный код (директиву) и передать управление на модуль программы, 
		пользуясь, в свою очередь, строкой меток, например так:</li>
	</ul>
	<pre><span class="labl">BEG</span>:    <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ввод директивы</span>
        <span class="cmds">MOV</span>     #<span class="labl">DIR</span>,<span class="regn">R4</span>             <span class="cmmnt">; Начало таблицы кодов директив</span>
<span class="locl">0</span>:      <span class="cmds">CMPB</span>    <span class="regn">R0</span>,(<span class="regn">R4</span>)+            <span class="cmmnt">; Код совпадает?</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; Да - передать управление</span>
        <span class="cmds">TSTB</span>    @<span class="regn">R4</span>                 <span class="cmmnt">; Конец таблицы?</span>
        <span class="cmds">BNE</span>     <span class="locl">0</span>                   <span class="cmmnt">; Нет - продолжать поиск кода</span>
        <span class="cmds">BR</span>      <span class="labl">BEG</span>                 <span class="cmmnt">; Иначе (кода в таблице нет) идём к началу</span>
<span class="locl">1</span>:      <span class="cmds">SUB</span>     #<span class="labl">DIR</span>,<span class="regn">R4</span>             <span class="cmmnt">; Номер кода директивы</span>
        <span class="cmds">ASL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Умножить на 2</span>
        <span class="cmds">JMP</span>     @<span class="labl">ADR</span>-<span class="nmbr">2</span>(<span class="regn">R4</span>)          <span class="cmmnt">; Передать управление по таблице</span>
                                    <span class="cmmnt">; меток, в соответствии с номером </span>
                                    <span class="cmmnt">; кода директивы, с поправкой</span>
<span class="labl">DIR</span>:     <span class="pscm">.B</span>:<span class="nmbr">10</span>,<span class="nmbr">22</span>,<span class="nmbr">31</span>,<span class="nmbr">32</span>,<span class="nmbr">33</span><span class="pscm">.E</span>
<span class="labl">ADR</span>:     <span class="pscm">.#</span><span class="labl">М1</span>,<span class="labl">М2</span>,<span class="labl">M3</span>,<span class="labl">М4</span>,<span class="labl">М5</span></pre>
	<p>В данной программе мы используем две таблицы. В первой, под меткой
	<span class="labl">DIR</span> содержится список кодов директив (используются, 
	для примера, коды клавиш управления курсором). Введя директиву, мы ищем её код 
	в таблице. Если он найден, вычисляем его номер от начала таблицы. Но коды директив 
	- байты, а адреса меток передачи управления - слова, поэтому удваиваем номер 
	и вычисляем адрес соответствующей метки в таблице <span class="labl">ADR</span> 
	(как адрес начала таблицы плюс номер метки). По этой метке и передаётся управление. 
	Поясним, что запись @<span class="labl">ADR</span>-<span class="nmbr">2</span> 
	появилась в программе потому, что после нахождения директивы содержимое регистра
	<span class="regn">R4</span> инкрементируется и указывает на адрес следующей 
	директивы, из-за чего при обращении к метке мы должны ввести поправку. Псевдокоманда
	<span class="pscm">.E</span> в конце таблицы <span class="labl">DIR</span> приводит 
	адрес метки <span class="labl">ADR</span> к чётному, а нулевой байт отмечает 
	конец таблицы. Чтобы всё было окончательно ясно, покажем, как можно организовать 
	модули программы, к которым мы обращаемся таким образом. Пример выбран простейший 
	- по нажатиям клавиш-директив наша программа будет выдавать имена меток (но 
	так можно построить любые модули). После программы, введённой в предыдущем примере, 
	допишем:</p>
	<pre><span class="labl">М1</span>:     <span class="cmds">MOV</span>     '<span class="strn">M1</span>',<span class="regn">R0</span>             <span class="cmmnt">; М1 - &laquo;стрелка влево&raquo;</span>
        <span class="cmds">BR</span>      <span class="labl">TYP</span>
<span class="labl">М2</span>:     <span class="cmds">MOV</span>     '<span class="strn">М2</span>',<span class="regn">R0</span>             <span class="cmmnt">; М2 - &laquo;стрелка в начало экрана&raquo;</span>
        <span class="cmds">BR</span>      <span class="labl">TYP</span>
<span class="labl">M3</span>:     <span class="cmds">MOV</span>     '<span class="strn">M3</span>',<span class="regn">R0</span>             <span class="cmmnt">; M3 - &laquo;стрелка вправо&raquo;</span>
        <span class="cmds">BR</span>      <span class="labl">TYP</span>
<span class="labl">М4</span>:     <span class="cmds">MOV</span>     '<span class="strn">M4</span>',<span class="regn">R0</span>             <span class="cmmnt">; М4 - &laquo;стрелка вверх&raquo;</span>
        <span class="cmds">BR</span>      <span class="labl">TYP</span>
<span class="labl">М5</span>:     <span class="cmds">MOV</span>     '<span class="strn">M5</span>',<span class="regn">R0</span>             <span class="cmmnt">; М5 - &laquo;стрелка вниз&raquo;</span>
        <span class="cmds">BR</span>      <span class="labl">TYP</span>
<span class="labl">TYP</span>:    <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Печать на</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; экране имени</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; метки</span>
        <span class="cmds">BR</span>      <span class="labl">BEG</span>                 <span class="cmmnt">; К началу</span>
        <span class="pscm">END</span></pre>
	<p>Данный способ передачи управления интересен тем, что таблицы могут расширяться 
	неограниченно, по мере написания новых модулей программы. Если же вместо оператора
	<span class="cmds">JMP</span> @<span class="labl">ADR</span>-<span class="nmbr">2</span>(<span class="regn">R4</span>) 
	использовать <span class="cmds">CALL</span> @<span class="labl">ADR</span>-<span class="nmbr">2</span>(<span class="regn">R4</span>), 
	то в качестве модулей можно использовать подпрограммы, после исполнения которых 
	управление будет возвращаться в основную программу, - иногда такой способ удобнее.</p>
	<ul>
		<li><span class="pscm">.@</span><span class="labl">MET</span> - <b>смещение 
		к метке</b>. При трансляции в слово по текущему адресу заносится разность 
		между адресом метки и текущим адресом - <b>смещение к метке</b>. Как обычно, 
		можно ввести в это смещение поправку, записав псевдооператор в виде
		<span class="pscm">.@</span><span class="labl">MET</span>+<span class="var">Х</span> 
		или <span class="pscm">.@</span><span class="labl">MET</span>-<span class="var">Х</span>, 
		где <span class="var">X</span> - восьмеричное число. Эта псевдокоманда широко 
		используется для получения абсолютных адресов меток в перемещаемых программах. 
		В самом деле, когда мы заносим абсолютный адрес метки, например, оператором
		<span class="cmds">MOV</span> #<span class="labl">MET</span>,<span class="regn">R4</span>, 
		второе слово данной команды заносится в память один раз при компоновке, 
		а его значение зависит от заданного начального адреса, по которому программа 
		компонуется и в дальнейшем будет работать. Стоит только изменить адрес загрузки 
		такой программы, и она работать не будет, так как действительные адреса 
		меток перестанут совпадать с полученными при компоновке. Иначе дело обстоит, 
		если задано смещение: как бы мы ни перемещали программу, &laquo;<i>расстояние</i>&raquo; 
		от текущего адреса до метки будет неизменным. Как пользоваться данной псевдокомандой? 
		Предположим, что нам нужно получить в каком-либо регистре абсолютный адрес 
		метки <span class="labl">MET</span>. Напишем программу:</li>
	</ul>
	<pre>        <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R4</span>               <span class="cmmnt">; Занести текущий адрес</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R4</span>            <span class="cmmnt">; Прибавить смещение </span>
        <span class="pscm">.@</span><span class="labl">MET</span>+<span class="nmbr">2</span>                     <span class="cmmnt">; Смещение с поправкой на +2</span></pre>
	<p>Мы получили абсолютный адрес метки <span class="labl">MET</span> в регистре
	<span class="regn">R4</span>. Каким образом это делается? Вначале мы записали 
	в <span class="regn">R4</span> текущий адрес. Во второй строке прибавили к этому 
	адресу смещение, полученное с помощью псевдооператора <span class="pscm">.@</span> 
	в третьей строке. Мы добились этого, косвенно обращаясь через регистр
	<span class="regn">PC</span>, в котором в этот момент находится адрес следующей 
	команды, т.е. как раз нужной нам строки Но в момент обращения к
	<span class="regn">PC</span> в первой строке мы записали адрес, на
	<span class="nmbr">2</span> меньший, чем адрес строки псевдооператора, и вынуждены 
	исправить эту ошибку, внеся поправку в смещение (&laquo;<i>+<span class="nmbr">2</span></i>&raquo;), 
	То, что мы во второй строке не просто косвенно обращаемся к
	<span class="regn">PC</span>, а с инкрементом, служит важной цели - увеличить 
	содержимое <span class="regn">PC</span> на <span class="nmbr">2</span> и таким 
	образом &laquo;<i>перескочить</i>&raquo; строку с псевдооператором: передавать 
	на неё управление нельзя, там не команда, а произвольное число. Пользуясь таким 
	приёмом, можно получить адрес метки независимо от того, находится она до или 
	после псевдооператора. Как всегда в таких случаях, метка должна быть глобальной, 
	а не локальной. Возможны и иные приёмы получения абсолютных адресов меток с 
	помощью данного псевдооператора, но предложенный - самый экономичный по расходу 
	памяти и быстродействию.</p>
	<p>Все вышеперечисленные псевдооператоры могут быть записаны как в одну строку 
	друг за другом в любой последовательности, так и в отдельных строках, но при 
	этом надо учитывать, что псевдокоманды <span class="pscm">.#</span> и
	<span class="pscm">.@</span> могут правильно работать только при их трансляции 
	по чётным адресам. В псевдооператоре <span class="pscm">.@</span> можно, в отличие 
	от <span class="pscm">.#</span>, указывать только одно имя метки, перечислять 
	их через запятую нельзя. В записанной последовательности псевдооператоров недопустимы 
	пробелы и прочие символы, разрывающие её. Такой символ либо ведёт к ошибке, 
	либо считается концом строки - и всё, следующее за ним, транслятор игнорирует.</p>
	<ul>
		<li><span class="pscm">.A</span>: - <b>запись строки символов в коде КОИ-8</b>. 
		Код КОИ-8 (а точнее, одна из его модификаций) - это &laquo;<i>родной</i>&raquo; 
		символьный код БК-0010, включающий все знаки и коды управления в диапазоне
		<span class="nmbr">0</span>...<span class="nmbr">377</span>. (Иногда этот 
		код называют &laquo;<i>кодом ASCII</i>&raquo; по аналогии с американским 
		стандартом. Но, строго говоря, код ASCII - это совсем другой стандарт и 
		никакого отношения к БК не имеет. Достаточно сказать, что он, естественно, 
		не содержит русских символов.) Так вот, данный псевдооператор позволяет 
		записать в строку любые символы БК-0010, а при трансляции их коды будут 
		занесены в память начиная с текущего адреса, причём код каждого символа 
		занимает один байт. Поскольку всё, что следует за <span class="pscm">.A</span>:, 
		транслятор интерпретирует как символьный код, то этот псевдооператор может 
		быть в строке только последним - после него недопустимы никакие операторы 
		или комментарии. Во всех версиях &laquo;<i>МИКРО.К</i>&raquo; пробелы заносятся 
		в строку символов в любом месте обычным образом, в версиях же &laquo;<i>МИКРО.С</i>&raquo; 
		занесённые пробелы не всегда транслируются правильно (в частности, игнорируются 
		пробелы в конце строки). Если в строку символов нужно ввести управляющие 
		коды (перевод строки, сброс экрана и т.п.). их можно задать с помощью псевдооператора
		<span class="pscm">.B</span>. Для самых распространённых кодов управления 
		в &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> последних версий 
		введена возможность вставлять их в строку в виде символов «<span class="symb">^</span>&raquo; 
		(возведение в степень) и &laquo;<span class="symb">\</span>&raquo; (обратная 
		косая черта), которые обозначают, соответственно, код <span class="nmbr">
		12</span> (перевод строки) и код <span class="nmbr">0</span>. Этот псевдооператор 
		очень широко применяется для ввода в состав программ меню, текстовых сообщений, 
		инструкций, таблиц кодов и т.п. Примеры его использования будут приведены 
		чуть позже.</li>
		<li><span class="pscm">.R</span>: - <b>запись строки символов в коде RADIX-50</b>. 
		Как уже было сказано, при кодировании текста в коде КОИ-8 каждый символ 
		занимает один байт. Это и понятно, ведь используются все коды в диапазоне
		<span class="nmbr">0</span>...<span class="nmbr">377</span>. Но иногда достаточно 
		и меньшего количества кодов, например только цифр и латинских символов. 
		Простой расчёт показывает, что если ограничиться только
		<span class="nmbr">40</span><sub>д</sub> символами, то в каждом машинном 
		слове теоретически можно разместить до трёх символов (если не верите, извлеките 
		корень третьей степени из числа <span class="nmbr">65536</span><sub>д</sub>). 
		Но такое размещение явно не пройдёт &laquo;<i>напрямую</i>&raquo;. В самом 
		деле, если разделить <span class="nmbr">16</span> на <span class="nmbr">
		3</span>, получится <span class="nmbr">5</span> и <span class="nmbr">1</span> 
		в остатке. А в пяти битах можно закодировать не более <span class="nmbr">
		32</span><sub>д</sub> символов. Чтобы можно было полностью использовать 
		информационную ёмкость машинного слова, прибегают к следующему приёму. Весь 
		кодируемый текст делят на триады символов, а затем в каждое слово записывают 
		одну из триад по правилу: <b>значение</b> = ((<span class="var">C1</span> 
		* <span class="nmbr">50</span>) + <span class="var">С2</span>) *
		<span class="nmbr">50</span> + <span class="var">С3</span>, где
		<span class="var">C1</span>, <span class="var">С2</span> и
		<span class="var">С3</span> - первый, второй и третий коды символов (все 
		числа и вычисления - в восьмеричной системе). Десятичное число
		<span class="nmbr">40</span> равно восьмеричному <span class="nmbr">50</span>, 
		отсюда и название кода. Всё это позволяет при ограниченном наборе символов 
		достичь повышения плотности упаковки текста в полтора раза и применяется, 
		когда необходимо упаковать длинный текст при максимальной экономии памяти. 
		Упаковка и распаковка кода RADIX-50 не слишком простая задача, требующая 
		заметного времени по сравнению с обработкой текстов в формате КОИ-8, что 
		наряду с ограниченным набором символов является препятствием для широкого 
		применения RADIX-формата. Приведём таблицу восьмеричных значений кода RADIX-50:</li>
	</ul>
	<table id="mcmd" class="border3">
		<tr>
			<th>
			<p>Символ</p>
			</th>
			<th>
			<p>Код RADIX-50</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="symb">ПРОБЕЛ</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="symb">A</span>...<span class="symb">Z</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span>...<span class="nmbr">32</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="symb">$</span></p>
			</td>
			<td>
			<p><span class="nmbr">33</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="symb">.</span></p>
			</td>
			<td>
			<p><span class="nmbr">34</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Резерв</p>
			</td>
			<td>
			<p><span class="nmbr">35</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="nmbr">0</span>...<span class="nmbr">9</span></p>
			</td>
			<td>
			<p><span class="nmbr">36</span>...<span class="nmbr">47</span></p>
			</td>
		</tr>
	</table>
	<p>Код <span class="nmbr">35</span> не используется, а код
	<span class="nmbr">34</span> не задействован в &laquo;МИКРО&raquo;, что называется &laquo;<i>по 
	техническим причинам</i>&raquo;. Символ, не входящий в состав кода RADIX, считается 
	концом строки. Если количество преобразуемых символов не кратно
	<span class="nmbr">3</span>, то последние один или два символа автоматически 
	дополняются до полной триады пробелами. Псевдооператор <span class="pscm">.R</span>, 
	как и <span class="pscm">.A</span>, должен быть последним в строке.</p>
	<p class="centr">★ ★ ★</p>
	<p>Осталось рассмотреть последний оператор - <span class="pscm">END</span>. 
	Он вполне может быть отнесён к псевдооператорам, так как не транслируется, а 
	только сообщает транслятору о конце текста программы. Весь текст, следующий 
	за ним, транслятор игнорирует. Хотя этот оператор не обязателен в &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	и в некоторых иных версиях ассемблера, всё же лучше писать его в конце программы 
	во всех случаях. Помимо основного назначения, он может применяться, если нужно 
	оттранслировать только часть программы, в этом случае оператор
	<span class="pscm">END</span> временно ставится в конце транслируемой части.</p>
	<p>А теперь приведём примеры использования разобранных выше псевдооператоров.</p>
	<pre>1)     <span class="cmmnt">; Вывод на экран текста с предварительным сбросом экрана</span>
       <span class="cmmnt">; и переключением формата</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Конец текста - нулевой байт</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Вывод текста</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Останов</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.B</span>:<span class="nmbr">14</span>,<span class="nmbr">233</span> <span class="pscm">.A</span>:<span class="strn">^ Привет от БК-0010,</span>
        <span class="pscm">.A</span>:<span class="strn">^ лучшего в мире компьютера!\</span>
        <span class="pscm">END</span>
        
2)     <span class="cmmnt"> ; Программа &quot;мигания&quot; экрана с выдачей звуковых сигналов</span>
<span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="cmds">COM</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала команд</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Признак конца команд - 0</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдача команд звука и мигания</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ждать нажатия клавиши</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl"><span class="cmds">COM</span></span>:    <span class="pscm">.B</span>:<span class="nmbr">7</span>,<span class="nmbr">7</span>,<span class="nmbr">7</span>,<span class="nmbr">235</span>,<span class="nmbr">7</span>,<span class="nmbr">7</span>,<span class="nmbr">7</span>,<span class="nmbr">235</span><span class="pscm">.E</span>
        <span class="pscm">END</span>

3)      <span class="cmmnt">; Перемещаемая программа вывода текста</span>
<span class="locl">0</span>:      <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R1</span>               <span class="cmmnt">; Занесение физического</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R1</span>            <span class="cmmnt">; адреса метки ТЕХ</span>
        <span class="pscm">.@</span><span class="labl">ТЕХ</span>+<span class="nmbr">2</span>                     <span class="cmmnt">; в R1</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Конец текста - нулевой байт</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Вывод текста</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ожидание нажатия клавиши</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.A</span>:<span class="strn">^ Эта программа может работать по любому адресу,</span>
        <span class="pscm">.A</span>:<span class="strn">^ и не нуждается в компоновке!\</span>
        <span class="pscm">END</span>

4)      <span class="cmmnt">; Программа ввода текста в буфер с его последующим выводом</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес буфера текста</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">5377</span>,<span class="regn">R2</span>            <span class="cmmnt">; Конец текста - 377 байт или &quot;ВВОД&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">10</span>                  <span class="cmmnt">; Ввод текста с клавиатуры</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">5377</span>,<span class="regn">R2</span>            <span class="cmmnt">; Ограничители текста</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Вывод текста</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Конец</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.+</span><span class="nmbr">377</span>                       <span class="cmmnt">; Буфер текста 377 байт</span>
        <span class="pscm">END</span>

5)      <span class="cmmnt">; Программа выдачи нескольких последовательных</span>
        <span class="cmmnt">; фрагментов текста</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес начала текста</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Признак конца - нулевой байт</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдать первый текст</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ждать нажатия клавиши</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдать второй текст</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдать третий текст</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдать четвёртый текст</span>
        <span class="cmds">HALT</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.A</span>:<span class="strn">^ Нажимайте клавиши!\</span>
        <span class="pscm">.A</span>:<span class="strn">^ Вы нажали первую клавишу.\</span>
        <span class="pscm">.A</span>:<span class="strn">^ А теперь - вторую!\</span>
        <span class="pscm">.A</span>:<span class="strn">^ Наконец-то, последняя клавиша! До свидания.</span>
        <span class="pscm">.E</span>
        <span class="pscm">END</span></pre>
	<p>Заметим, что в последнем примере при вызове <span class="cmds">EMT</span>
	<span class="nmbr">20</span> используется не только входная информация, но и 
	выходная - для выдачи последующих фрагментов текста их адрес в
	<span class="regn">R1</span> уже не заносится, так как там содержится адрес 
	байта, следующего за концом предыдущего текста.</p>
	<p>Нельзя не упомянуть и о чрезвычайно оригинальном и очень полезном на практике 
	способе вывода текстовых сообщений, также использующем выходную информацию
	<span class="cmds">EMT</span> <span class="nmbr">20</span>. Этот способ предложен 
	учеником X класса Денисом Батранковым (Московская обл.). Поясним его смысл на 
	примере:</p>
	<pre>        <span class="cmds">JSR</span>     <span class="regn">R1</span>,<span class="labl">PRI</span>              <span class="cmmnt">; Печать текста</span>
<span class="labl">ТЕ1</span>:    <span class="pscm">.A</span>:<span class="strn">Привет!^</span>
        <span class="pscm">.E</span>
        <span class="cmds">JSR</span>     <span class="regn">R1</span>,<span class="labl">PRI</span>              <span class="cmmnt">; Печать текста</span>
<span class="labl">ТЕ2</span>:    <span class="pscm">.A</span>:<span class="strn">Два привета!^</span>
        <span class="pscm">.E</span>
        <span class="cmds">JSR</span>     <span class="regn">R1</span>,<span class="labl">PRI</span>              <span class="cmmnt">; Печать текста</span>
<span class="labl">ТЕЗ</span>:    <span class="pscm">.A</span>:<span class="strn">Три привета!^</span>
        <span class="pscm">.E</span>
        <span class="cmmnt">;...............</span>
       <span class="cmmnt"> ; Подпрограмма печати</span>
<span class="labl">PRI</span>:    <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Признак конца текста</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Вывод текст?</span>
        <span class="cmds">INC</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Привести содержимое R1</span>
        <span class="cmds">BIC</span>     #<span class="nmbr">1</span>,<span class="regn">R1</span>               <span class="cmmnt">; к чётному значению</span>
        <span class="cmds">RTS</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Выход</span>
        <span class="cmmnt">;...............</span></pre>
	<p>Здесь используется та особенность, что при обращении к подпрограмме
	<span class="cmds">JSR</span> <span class="regn">RN</span>,<span class="labl">MET</span> 
	в регистр <span class="regn">RN</span> заносится адрес возврата, т.е. адрес 
	следующей после оператора <span class="cmds">JSR</span> команды, а там у нас 
	- начало текста. В подпрограмме выполняется <span class="cmds">EMT</span>
	<span class="nmbr">20</span> по содержимому <span class="regn">R1</span> (с 
	предварительной установкой признака окончания по нулевому байту или слову), 
	а затем содержимое <span class="regn">R1</span> (в котором после выполнения
	<span class="cmds">EMT</span> <span class="nmbr">20</span> хранится адрес следующего 
	байта после текста) приводится к ближайшему большему чётному адресу, т.е. в
	<span class="regn">R1</span> оказывается адрес возврата из подпрограммы на следующую 
	после текста команду. Данный способ даёт заметную экономию памяти, если текстовых 
	сообщений в программе много, и при этом обеспечивает её перемещаемость. К его 
	недостаткам можно отнести необходимость помещать текстовые сообщения в программе
	<b>только</b> по ходу обращений к ним (хотя в большинстве случаев это как раз 
	и требуется) и недопустимость использования в качестве ограничителя текста символа &laquo;<span class="symb">\</span>&raquo; 
	(допускается только оператор <span class="pscm">.E</span>). В остальном же этот 
	способ имеет неоспоримые преимущества перед всеми остальными, включая и то, 
	что после вывода текста содержимое <span class="regn">R1</span> восстанавливается, 
	как при всяком выходе из подпрограммы по <span class="cmds">RTS</span>
	<span class="regn">RN</span> (Кстати, обозначать метками начала текстовых сообщений, 
	как это сделано в нашем примере для наглядности, совсем не обязательно. Это 
	может пригодиться, только если потребуется ещё раз вывести то же сообщение в 
	другом месте программы).</p>
	<h3><a name="toc_39"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Напишите программу, которая бы &laquo;<i>отслеживала</i>&raquo; положение 
		символьного курсора по горизонтали, перемещая наравне с ним стрелку в служебной 
		строке.
		<ul id="ctrla">
			<li>
			<pre><span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ввод символа (команды)</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Вывод символа на экран</span>
        <span class="cmds">EMT</span>     <span class="nmbr">26</span>                  <span class="cmmnt">; Позиция курсора (R1 = X)</span>
        <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Очистка</span>
        <span class="cmds">EMT</span>     <span class="nmbr">22</span>                  <span class="cmmnt">; служебной строки</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">33</span>,<span class="regn">R0</span>              <span class="cmmnt">; Код &quot;стрелка вниз&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">22</span>                  <span class="cmmnt">; Символ в служебную строку (позиция - в R1)</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
        <span class="pscm">END</span>                         <span class="cmmnt">; Конец</span></pre>
			</li>
		</ul>
		</li>
		<li>Напишите программу, которая бы, определяя установленный режим дисплея, &laquo;<i>приказывала</i>&raquo; 
		пользователю печатать символы только в русском регистре.
		<ul id="ctrla">
			<li>
			<pre><span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ввод символа</span>
        <span class="cmds">TSTB</span>    @#<span class="nmbr">43</span>                <span class="cmmnt">; Регистр &quot;РУС&quot;?</span>
        <span class="cmds">BNE</span>     <span class="locl">1</span>                   <span class="cmmnt">; Да - печать символа,</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; иначе – выдать</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; предупреждение</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; о вводе не русского символа</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; К началу</span>
<span class="locl">1</span>:      <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Символ на экран</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.A</span>:<span class="strn">^ Нажмите клавишу &quot;РУС&quot;!^</span>
        <span class="pscm">.E</span>
        <span class="pscm">END</span>                         <span class="cmmnt">; Конец</span></pre>
			</li>
		</ul>
		</li>
		<li>Напишите простейший копировщик - программу, которая бы после запуска 
		позволяла скопировать последний загруженный с магнитной ленты по &laquo;<i>естественному</i>&raquo; 
		адресу файл без задания его имени, адреса и длины с клавиатуры. Программа 
		должна быть перемещаемой, с целью размещения её в зоне ОЗУ, не занимаемой 
		копируемым файлом.
		<ul id="ctrla">
			<li>
			<p>Подсказка: блок параметров <span class="cmds">EMT</span>
			<span class="nmbr">36</span> для записи не обязательно начинается с 
			адреса <span class="nmbr">320</span> а программа должна получиться
			<b>очень</b> короткой - всего несколько операторов.</p>
			<pre>        <span class="cmds">MOV</span>     #<span class="nmbr">344</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес блока параметров послед-</span>
                                    <span class="cmmnt">; него загруженного файла минус 2</span>
                                    <span class="cmmnt">; используем как блок параметров файла</span>
                                    <span class="cmmnt">; для записи</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">2</span>,@<span class="regn">R1</span>              <span class="cmmnt">; Команда &quot;Запись&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">36</span>                  <span class="cmmnt">; Запись файла</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Конец</span>
        <span class="pscm">END</span></pre>
			</li>
		</ul>
		</li>
		<li>Что произойдёт, если после запуска следующей программы нажать любую 
		символьную клавишу:
		<pre>        <span class="cmds">MTPS</span>    #<span class="nmbr">340</span>
        <span class="cmds">WAIT</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span></pre>
		<ul id="ctrla">
			<li>
			<p>- Ничего, так как приоритет ЦП установлен равным
			<span class="nmbr">7</span>, а приоритет клавиатуры -
			<span class="nmbr">4</span>. Программа остановится на команде
			<span class="cmds">WAIT</span>, и её работа будет продолжена после нажатия 
			на клавишу &laquo;<i>СТОП</i>&raquo;.</p>
			</li>
		</ul>
		</li>
	</ol>
	<p>Как известно, основное преимущество ассемблера перед прочими языками - скорость 
	исполнения программ. Согласно технической документации, для БК-0010 она равна
	<span class="nmbr">300</span> тыс. операций в секунду. Но это не более чем абстрактная 
	цифра, имеющая очень мало общего с фактическим быстродействием ЭВМ. Скорость 
	исполнения, программы, состоящей из реальных команд, зависит от многих факторов, 
	из которых главными являются <b>тип команд</b> и <b>способы адресации</b>. С 
	помощью специального устройства (электронного измерителя длительностей) в сочетании 
	со специально написанными для этой цели программами скорость исполнения отдельных 
	команд может быть непосредственно измерена, а затем путём логических рассуждений 
	и расчётов можно найти правила для вычисления времени исполнения любых команд 
	БК-0010 с любыми методами адресации. Автор проделал это исследование, результаты 
	которого изложены ниже. Следует заметить, что правила вычисления времени исполнения 
	команд для БК-0010 оказались заметно отличающимися от аналогичных для &laquo;<i>прародителя</i>&raquo; 
	БК - компьютера PDP-11. Это естественно, так как эти ЭВМ, несмотря на одинаковую 
	систему машинных команд, заметно различаются по внутренней структуре. Приступим 
	к рассмотрению результатов, полученных на БК-0010.</p>
	<p>Заметим сразу, что способы измерения времени исполнения команд могут быть 
	различными и в зависимости от этого получаются заметно отличающиеся результаты. 
	В частности, <em>Б.Ф. Фролкин</em> совершенно правильно обратил внимание автора 
	на тот факт, что на время исполнения команд сильно влияет время отклика ОЗУ 
	БК-0010 из-за особенностей работы контроллера ОЗУ К1801ВП1-<span class="nmbr">037</span>. 
	Поэтому в конкретной программе время исполнения может несколько отличаться от 
	вычисленного (в том числе это зависит и от типа предшествующей команды). Программы 
	в ПЗУ БК-0010 исполняются несколько быстрее, чем в ОЗУ (по данным автора, увеличение 
	скорости в ПЗУ может составлять от <span class="nmbr">10</span> до
	<span class="nmbr">30</span>%, что в основном совпадает с цифрами, предоставленными
	<em>Б.Ф. Фролкиным</em>). При использовании приведённых ниже таблиц необходимо 
	также учитывать следующее:</p>
	<ul>
		<li>полученные автором данные эмпирические и приближенные;</li>
		<li>данные относятся к программам, работающим в ОЗУ пользователя БК-0010.</li>
	</ul>
	<h2><a name="toc_40"></a>Временные характеристики команд БК-0010</h2>
	<p>Прежде всего необходимо отметить, что тактовая частота процессора, установленного 
	в БК-0010, в совокупности с особенностями этой ЭВМ обеспечивает реальное быстродействие 
	примерно <span class="nmbr">250</span> тыс. операций в секунду. Но что это за 
	операции? Речь идёт об операциях типа &laquo;регистр-регистр&raquo;, т.е. об 
	адресации <span class="regn">RN</span> (с кодом <span class="nmbr">0</span>). 
	При всех прочих способах адресации скорость исполнения команд уменьшается. Время 
	исполнения команд с кодом адресации <span class="nmbr">0</span> или безоперандных 
	носит название <b>основного времени</b> команды, для БК-0010 оно равно
	<span class="nmbr">4</span>.<span class="nmbr">0</span>&nbsp;мкс (<span class="nmbr">1</span>&nbsp;мкс 
	= <span class="nmbr">0</span>.<span class="nmbr">000001</span> с). Таким образом, 
	за <span class="nmbr">4</span>.<span class="nmbr">0</span>&nbsp;мкс исполняются 
	операторы <span class="cmds">NOP</span>, <span class="cmds">CLC</span>,
	<span class="cmds">CLV</span>, <span class="cmds">CLZ</span>,
	<span class="cmds">CLN</span>, <span class="cmds">CCC</span>,
	<span class="cmds">SEC</span>, <span class="cmds">SEV</span>,
	<span class="cmds">SEZ</span>, <span class="cmds">SEN</span>,
	<span class="cmds">SCC</span>, а также все одно- и двухоперандные команды, т.е.
	<span class="cmds">CLR</span>, <span class="cmds">INC</span>,
	<span class="cmds">ASL</span>, <span class="cmds">ASR</span>,
	<span class="cmds">MTPS</span>, <span class="cmds">SWAB</span>,
	<span class="cmds">MOV</span>, <span class="cmds">CMP</span>,
	<span class="cmds">XOR</span>, и прочие, если способ адресации операндов в них 
	- <span class="regn">RN</span> (код <span class="nmbr">0</span>).</p>
	<p>Сложнее определить время исполнения команд при иных способах адресации. Вспомним, 
	как мы обозначали операнды при описании операторов. Буквой
	<span class="oprt">А</span> обозначался операнд-источник, а
	<span class="oprt">В</span> - операнд-приёмник в двухоперандных командах, например
	<span class="cmds">MOV</span> <span class="oprt">А</span>,<span class="oprt">В</span>. 
	Пара букв <span class="oprt">АВ</span> означала источник (он же и приёмник) 
	в однооперандных командах, например <span class="cmds">COM</span>
	<span class="oprt">AB</span>. Как <span class="oprt">A1</span>,
	<span class="oprt">А2</span> обозначались источник и приёмник, не изменяющиеся 
	в процессе исполнения команды, например <span class="cmds">CMP</span>
	<span class="oprt">А1</span>,<span class="oprt">А2</span>. И наконец, операнд 
	- адрес перехода обозначался как <span class="oprt">N</span>. Используя те же 
	обозначения, приводим таблицу <b>времени адресации операндов</b> для БК-0010.</p>
	<center>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">1</span> </caption>
		<tr>
			<th colspan="2">
			<p>Адресация</p>
			</th>
			<th colspan="5">
			<p>Тип операнда и добавочное время,&nbsp;мкс</p>
			</th>
		</tr>
		<tr>
			<th>
			<p>способ</p>
			</th>
			<th>
			<p>код</p>
			</th>
			<th>
			<p><span class="oprt">А</span>,<span class="oprt">А1</span></p>
			</th>
			<th>
			<p><span class="oprt">АВ</span></p>
			</th>
			<th>
			<p><span class="oprt">В</span></p>
			</th>
			<th>
			<p><span class="oprt">А2</span>, <span class="oprt">Nj</span></p>
			</th>
			<th>
			<p><span class="oprt">Ns</span></p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="regn">RN</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>, -</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>@<span class="regn">RN</span>, (<span class="regn">RN</span>)+, -(<span class="regn">RN</span>), 
			#<span class="var">Х</span>, #<span class="labl">MET</span></p>
			</td>
			<td nowrap="nowrap">
			<p><span class="nmbr">1</span>, <span class="nmbr">2</span>,
			<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">5</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>@(<span class="regn">RN</span>)+, @-(<span class="regn">RN</span>),
			<span class="var">X</span>(<span class="regn">RN</span>),
			<span class="labl">MET</span>(<span class="regn">RN</span>), @#<span class="var">X</span>,
			<span class="labl">MET</span></p>
			</td>
			<td>
			<p><span class="nmbr">3</span>, <span class="nmbr">5</span>,
			<span class="nmbr">6</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">9</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>@X(<span class="regn">RN</span>), @<span class="labl">MET</span>(<span class="regn">RN</span>), 
			@<span class="labl">MET</span></p>
			</td>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p><span class="nmbr">9</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">12</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">16</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
	</table>
	</center>
	<p>Как пользоваться таблицей? Мы уже говорили, что <b>основное время</b> для 
	всех команд равно <span class="nmbr">4</span>.<span class="nmbr">0</span>&nbsp;мкс. 
	Для вычисления времени исполнения однооперандной команды к основному времени 
	необходимо прибавить время адресации операнда из таблицы. Для примера вычислим 
	время исполнения ряда команд:</p>
	<center>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">2</span> </caption>
		<tr>
			<th>
			<p>Команда</p>
			</th>
			<th colspan="2">
			<p>Тип операнда, <br>код адресации</p>
			</th>
			<th>
			<p>Время исполнения осн.<br>+ добавочное,&nbsp;мкс</p>
			</th>
			<th>
			<p>Сумма,&nbsp;мкс</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">TST</span> <span class="regn">R2</span></p>
			</td>
			<td>
			<p><span class="oprt">A1</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">TST</span> @<span class="regn">R4</span></p>
			</td>
			<td>
			<p><span class="oprt">A1</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">4</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">COM</span> @<span class="regn">R2</span></p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">5</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">9</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">MTPS</span> #<span class="nmbr">340</span></p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">5</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">9</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">CLR</span> @#<span class="nmbr">256</span></p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">3</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">12</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">INC</span> @-(<span class="regn">R4</span>)</p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">5</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">12</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">ROR</span> <span class="labl">MET</span></p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">12</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">NEG</span> @<span class="nmbr">10</span>(<span class="regn">R5</span>)</p>
			</td>
			<td>
			<p><span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">7</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">14</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
	</table>
	</center>
	<p>С двухоперандными командами дело обстоит значительно сложнее, и для приближенного 
	вычисления их времени исполнения можно предложить следующие правила. Для операнда-источника 
	время берётся из таблицы без всяких оговорок, тип операнда -
	<span class="oprt">А</span> или <span class="oprt">А1</span> (в зависимости 
	от конкретного оператора). А вот для операнда-приёмника принимается тип
	<span class="oprt">В</span> только тогда, когда источник -
	<span class="regn">RN</span>, в противном же случае тип приёмника берётся
	<span class="oprt">АВ</span>. Для операторов <span class="cmds">CMP</span> и
	<span class="cmds">BIT</span>, которые не меняют операнды, естественно, время 
	адресации второго операнда короче: если источником является
	<span class="regn">RN</span>, то для приёмника берётся тип
	<span class="oprt">А2</span>, при ином же способе адресации источника тип приёмника 
	принимается <span class="oprt">А1</span>. При работе с оператором
	<span class="cmds">XOR</span> для второго операнда принимается тип
	<span class="oprt">А2</span>. Все эти сложности объясняются порядком, в котором 
	процессор обрабатывает операнды на микропрограммном уровне, и уже отмеченными 
	особенностями самой ЭВМ. Примеры:</p>
	<center>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">3</span></caption>
		<tr>
			<th>
			<p>Команда</p>
			</th>
			<th colspan="2">
			<p>Тип операнда,<br>коды адресации</p>
			</th>
			<th>
			<p>Время исполнения, осн.<br>+ добавочное,&nbsp;мкс</p>
			</th>
			<th>
			<p>Сумма,&nbsp;мкс</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">MOV</span> <span class="regn">R2</span>,<span class="regn">R4</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">В</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>, <span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">MOV</span> <span class="regn">R2</span>,@<span class="regn">R4</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">В</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>, <span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span> +
			<span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">MOV</span> @<span class="regn">R2</span>,<span class="regn">R4</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span>, <span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">MOV</span> @<span class="regn">R2</span>,@<span class="regn">R4</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span>, <span class="nmbr">1</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">5</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">SUB</span> @<span class="labl">MET</span>,<span class="regn">R5</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">7</span>, <span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">9</span>.<span class="nmbr">4</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">ADD</span> <span class="labl">MET</span>,<span class="labl">MET</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">АВ</span></p>
			</td>
			<td>
			<p><span class="nmbr">6</span>, <span class="nmbr">6</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">6</span>.<span class="nmbr">8</span> +
			<span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">18</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">CMP</span> #<span class="nmbr">100</span>,<span class="regn">R5</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">А1</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span>, <span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span></p>
			</td>
			<td>
			<p><span class="nmbr">8</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">CMP</span> <span class="regn">R5</span>,#<span class="nmbr">100</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">А2</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>, <span class="nmbr">2</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span> +
			<span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BIT</span> <span class="labl">TV</span>,@#<span class="nmbr">256</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">А1</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span>, <span class="nmbr">3</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
			<td>
			<p><span class="nmbr">14</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">XOR</span> <span class="regn">R3</span>,<span class="labl">MET</span></p>
			</td>
			<td>
			<p><span class="oprt">А</span>, <span class="oprt">А2</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>, <span class="nmbr">6</span></p>
			</td>
			<td>
			<p><span class="nmbr">4</span>.<span class="nmbr">0</span> +
			<span class="nmbr">0</span>.<span class="nmbr">0</span> +
			<span class="nmbr">9</span>.<span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
	</table>
	</center>
	<p>Отметим, что время исполнения команд на БК-0010 не зависит от того, работает 
	ли команда с байтом или со словом.</p>
	<p>Ещё ряд операторов имеет время исполнения, которое должно быть оговорено 
	особо.</p>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">4</span> </caption>
		<tr>
			<th>
			<p>Оператор или группа операторов</p>
			</th>
			<th>
			<p>Общее время исполнения,&nbsp;мкс</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">JMP</span> <span class="oprt">N</span></p>
			</td>
			<td>
			<p>см. табл. <span class="nmbr">1</span>, столбец <span class="oprt">
			Nj</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">JSR</span> <span class="regn">RN</span>,<span class="oprt">N</span> 
			(или <span class="cmds">CALL</span> <span class="oprt">N</span>)</p>
			</td>
			<td>
			<p>см. табл. <span class="nmbr">1</span>, столбец <span class="oprt">
			Ns</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">RTS</span> <span class="regn">RN</span> (или
			<span class="cmds">RET</span>)</p>
			</td>
			<td>
			<p><span class="nmbr">10</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">BR</span> <span class="labl">MET</span>,
			<span class="cmds">BEQ</span> <span class="labl">MET</span> и все прочие 
			операторы ветвления независимо от того, выполняется ли переход по условию</p>
			</td>
			<td>
			<p><span class="nmbr">5</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">SOB</span> <span class="regn">RN</span>,<span class="labl">MET</span> 
			независимо от того, выполняется ли ветвление</p>
			</td>
			<td>
			<p><span class="nmbr">6</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span>, <span class="cmds">TRAP</span>,
			<span class="cmds">BPT</span>, <span class="cmds">IOT</span></p>
			</td>
			<td>
			<p><span class="nmbr">22</span>.<span class="nmbr">8</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">HALT</span></p>
			</td>
			<td>
			<p><span class="nmbr">48</span>.<span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Прерывания от внешних устройств</p>
			</td>
			<td>
			<p>~<span class="nmbr">20</span>&nbsp;мкс + время завершения исполнения 
			текущей команды</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">RTI</span>, <span class="cmds">RTT</span></p>
			</td>
			<td>
			<p><span class="nmbr">13</span>.<span class="nmbr">4</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">RESET</span></p>
			</td>
			<td>
			<p>~<span class="nmbr">380</span>&nbsp;мкс</p>
			</td>
		</tr>
	</table>
	<p>Приведём также время отработки некоторых часто используемых прерываний
	<span class="cmds">EMT</span> БК-0010, что представляет интерес с практической 
	точки зрения. Время приводится в миллисекундах (<span class="nmbr">1</span>&nbsp;мс 
	= <span class="nmbr">1000</span>&nbsp;мкс).</p>
	<table id="mcmd" class="border3">
		<caption class="right">Таблица <span class="nmbr">5</span> </caption>
		<tr>
			<th>
			<p>Прерывание <span class="cmds">EMT</span></p>
			</th>
			<th>
			<p>Общее время исполнения (приближённо)</p>
			</th>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">4</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>.<span class="nmbr">2</span>&nbsp;мс</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">14</span></p>
			</td>
			<td>
			<p><span class="nmbr">240</span>&nbsp;мс</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">16</span></p>
			</td>
			<td>
			<p>от <span class="nmbr">0</span>.<span class="nmbr">4</span> (<span class="regn">R0</span> 
			= <span class="nmbr">0</span>) до <span class="nmbr">1</span>.<span class="nmbr">7</span>&nbsp;мс 
			(в <span class="regn">R0</span> код символа); с погашенным курсором 
			вывод символа - <span class="nmbr">1</span>.<span class="nmbr">1</span>&nbsp;мс; 
			в режиме &laquo;ИНВ.С&raquo; время вывода больше на
			<span class="nmbr">100</span>&nbsp;мкс, в режиме &laquo;<i>ПОДЧ.</i>&raquo; 
			- на <span class="nmbr">20</span>&nbsp;мкс; в режиме &laquo;<i><span class="nmbr">32</span> 
			символа в строке</i>&raquo; все значения возрастают примерно вдвое; 
			сброс экрана - <span class="nmbr">200</span>&nbsp;мс; перевод строки 
			- <span class="nmbr">1</span>.<span class="nmbr">8</span>&nbsp;мс (с 
			рулонным сдвигом - <span class="nmbr">18</span>&nbsp;мс)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">20</span></p>
			</td>
			<td>
			<p>(<span class="nmbr">1</span>.<span class="nmbr">6</span> *
			<span class="var">N</span>) + <span class="nmbr">0</span>.<span class="nmbr">5</span>&nbsp;мс, 
			где <span class="var">N</span> - число выводимых символов; в спецрежимах 
			(инверсия, подчёркивание, <span class="nmbr">32</span> символа) - поправка 
			на каждый символ как для <span class="cmds">EMT</span>
			<span class="nmbr">16</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">22</span></p>
			</td>
			<td>
			<p>от <span class="nmbr">1</span>.<span class="nmbr">1</span> (вывод 
			символа) до <span class="nmbr">34</span>&nbsp;мс (сброс строки); в спецрежимах 
			- поправка аналогично <span class="cmds">EMT</span>
			<span class="nmbr">16</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">24</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span>.<span class="nmbr">8</span>&nbsp;мс (в 
			символьном режиме); <span class="nmbr">2</span>.<span class="nmbr">4</span>&nbsp;мс 
			(в графическом режиме)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">26</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>.<span class="nmbr">25</span>&nbsp;мс 
			(в символьном режиме); <span class="nmbr">0</span>.<span class="nmbr">27</span>&nbsp;мс 
			(в графическом режиме)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">30</span></p>
			</td>
			<td>
			<p><span class="nmbr">0</span>.<span class="nmbr">5</span>&nbsp;мс независимо 
			от кода операции</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="cmds">EMT</span> <span class="nmbr">32</span></p>
			</td>
			<td>
			<p>(<span class="nmbr">0</span>.<span class="nmbr">5</span> *
			<span class="var">N</span>) + <span class="nmbr">0</span>.<span class="nmbr">5</span>&nbsp;мс, 
			где <span class="var">N</span> - число точек вектора (независимо от 
			кода операции); время несколько варьирует в зависимости от направления 
			черчения (наименьшее время - для горизонтальных и вертикальных векторов)</p>
			</td>
		</tr>
	</table>
	<h3><a name="toc_41"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Что выгоднее с точки зрения скорости работы ЭВМ ставить на первое место 
		в двухоперандных командах с разными способами адресации: &laquo;быстрый&raquo; 
		или &laquo;медленный&raquo; операнд? Подсчитайте время исполнения команд
		<span class="cmds">CMP</span> @<span class="labl">MET</span>,<span class="regn">RN</span> 
		и <span class="cmds">CMP</span> <span class="regn">RN</span>,@<span class="labl">MET</span>.
		<ul id="ctrla">
			<li>
			<p>Медленный, при этом общая скорость исполнения команд заметно возрастает. 
			Время - <span class="nmbr">13</span>.<span class="nmbr">4</span> и
			<span class="nmbr">16</span>&nbsp;мкс соответственно.</p>
			</li>
		</ul>
		</li>
		<li>Что исполняется быстрее: обращение к подпрограмме или переход к обработке 
		командного прерывания?
		<ul id="ctrla">
			<li>
			<p>Обращение к подпрограмме намного быстрее: <span class="cmds">JSR</span>
			<span class="regn">RN</span>,<span class="oprt">N</span> +
			<span class="cmds">RTS</span> <span class="regn">RN</span> даже в самом 
			худшем случае (код адресации <span class="nmbr">7</span>) требует
			<span class="nmbr">26</span>.<span class="nmbr">8</span>&nbsp;мкс, а, 
			например, <span class="cmds">EMT</span> + <span class="cmds">RTI</span> 
			- <span class="nmbr">36</span>.<span class="nmbr">2</span>&nbsp;мкс. 
			Это не говоря уже о том, что для обращения по <span class="cmds">EMT</span> 
			или <span class="cmds">TRAP</span> необходимо потратить значительное 
			время ещё и на извлечение и обработку команды программой-диспетчером 
			.</p>
			</li>
		</ul>
		</li>
		<li>Подсчитайте, сколько времени займёт исполнение команд:
		<pre><span class="cmds">MOV</span> #<span class="nmbr">12</span>,<span class="regn">R0</span>
<span class="cmds">EMT</span> <span class="nmbr">16</span></pre>
		<ul id="ctrla">
			<li>
			<p>Первая команда - <span class="nmbr">8</span>&nbsp;мкс, вторая, если 
			не происходит рулонный сдвиг экрана, - <span class="nmbr">1</span>.<span class="nmbr">8</span>&nbsp;мс 
			(при сдвиге - <span class="nmbr">18</span>&nbsp;мс). Очевидно, что по 
			сравнению со второй командой время исполнения первой практически равно 
			нулю.</p>
			</li>
		</ul>
		</li>
		<li>Как лучше (с точки зрения быстродействия ЭВМ) организовать ввод чисел-констант 
		в программе:
		<ul>
			<li>... каждый раз вписывая в нужное место программы операнд #<span class="var">Х</span> 
			(например, <span class="cmds">MOV</span> #<span class="nmbr">1000</span>,<span class="regn">R0</span>),</li>
			<li>... составив таблицу констант и обращаясь к ней косвенно через регистр 
			(например, <span class="cmds">MOV</span> (<span class="regn">R1</span>)+,<span class="regn">R0</span>),</li>
			<li>... составив таблицу констант, обозначив их метками и обращаясь 
			к ним по меткам (например, <span class="cmds">MOV</span>
			<span class="labl">MET</span>,<span class="regn">R0</span>)?</li>
		</ul>
		<ul id="ctrla">
			<li>
			<p>Первым или вторым способом: они равнозначны по времени адресации, 
			тогда как третий способ медленнее примерно в <span class="nmbr">1</span>.<span class="nmbr">5</span> 
			раза. Но нужно учесть, что для обращения к таблице по второму способу 
			необходимо ещё, как правило, предварительно занести в
			<span class="regn">RN</span> адрес константы в таблице. Поэтому явно 
			предпочтительнее, если констант не слишком много, просто напрямую указывать 
			их в качестве операндов, например <span class="cmds">MOV</span> #<span class="nmbr">1250</span>.R0, 
			а не составлять из них таблицы.</p>
			</li>
		</ul>
		</li>
		<li>Пусть нужно вывести текст из <span class="var">N</span> символов. Известно, 
		что текст при убранном курсоре выводится быстрее. Начиная с какого значения
		<span class="var">N</span> становится выгодно по времени убрать курсор, 
		а потом его восстановить? Считайте, что команда гашения или восстановления 
		курсора исполняется за <span class="nmbr">1</span>.<span class="nmbr">1</span>&nbsp;мс.
		<ul id="ctrla">
			<li>
			<p>Составим уравнение <span class="nmbr">1</span>.<span class="nmbr">7</span>*<span class="var">N</span> 
			= <span class="nmbr">2</span> *<span class="nmbr">1</span>.<span class="nmbr">1
			</span>+ <span class="nmbr">1</span>.<span class="nmbr">1</span>*<span class="var">N</span> 
			и решим его относительно <span class="var">N</span>. Получается, что
			<span class="var">N</span> примерно равно <span class="nmbr">3</span>.<span class="nmbr">67</span>. 
			Ответ: выгодно убирать и затем восстанавливать курсор, если текст состоит 
			из <span class="nmbr">4</span> и более символов, т.е. практически всегда.</p>
			</li>
		</ul>
		</li>
	</ol>
	<p class="centr">★ ★ ★</p>
	<p>Итак, можно считать, что мы изучили в общих чертах архитектуру и ассемблер 
	БК-0010. Что же дальше? Можно ли считать художником человека, который изучил 
	химический состав красок, правила нанесения грунта на холст, способы изготовления 
	рам для картин? Ясно, что нет. Пора, наверное, перейти к самим картинам, то 
	бишь, к программам... И начнём мы с вопроса, которого уже касались, - с векторов 
	прерывания, но теперь посмотрим на них не как теоретики, а с практической точки 
	зрения: что можно сделать с их помощью (что делает ЭВМ - мы уже знаем).</p>
	<h2><a name="toc_42"></a>Векторы прерывания и программирование</h2>
	<p>Большинство случаев практического использования сведений о векторах прерывания 
	сводится к изменению этих векторов и созданию новых программ обработки прерываний. 
	Например, таким путём можно запретить останов программы клавишей &laquo;<i>СТОП</i>&raquo;, 
	ввести дополнительные команды процессора, дополнительные символы клавиатуры, 
	да и мало ли что ещё.</p>
	<p>Перейдём сразу к конкретным примерам. Предположим, что нам необходимо запретить 
	остановку программы клавишей &laquo;<i>СТОП</i>&raquo;, - это бывает необходимо 
	во многих случаях, когда останов может привести к нежелательным последствиям. 
	Поскольку клавиша &laquo;<i>СТОП</i>&raquo; внеприоритетная и просто запретить 
	прерывание по вектору @#<span class="nmbr">4</span> мы не можем, нам остаётся 
	только изменить его содержимое и написать новую программу обслуживания прерывания. 
	Включим в основную программу (где-нибудь в её начале) такую команду:
	<span class="cmds">MOV</span> #<span class="labl">V4</span>,@#<span class="nmbr">4</span>. 
	С её помощью сразу же после запуска мы перепишем вектор @#<span class="nmbr">4</span>. 
	Теперь при нажатии на клавишу &laquo;<i>СТОП</i>&raquo; (и, равным образом, 
	при отработке команды <span class="cmds">HALT</span>) управление будет передаваться 
	не по прежнему адресу, а на метку <span class="labl">V4</span>. Какую же программу 
	там разместить? Это зависит от наших целей.</p>
	<p>Если нужно только, чтобы клавиша &laquo;<i>СТОП</i>&raquo; вообще &laquo;<i>не 
	работала</i>&raquo;, достаточно, как может показаться, единственной команды 
	возврата из прерывания <span class="cmds">RTI</span>, её выполнением обработка 
	прерывания по вектору @#<span class="nmbr">4</span> и закончится:</p>
	<pre><span class="labl">V4</span>:     <span class="cmds">RTI</span></pre>
	<p>Но не всё так просто. Необходимо учитывать, что клавиша &laquo;<i>СТОП</i>&raquo; 
	может быть нажата в совершенно произвольный момент и прерывает она программу 
	не совсем так, как, скажем, команда <span class="cmds">EMT</span> или нажатие 
	клавиши на клавиатуре. При прерывании по клавише &laquo;<i>СТОП</i>&raquo; процессор 
	может не закончить выполнение очередной команды, но при этом в стеке будет сохранено 
	значение <span class="regn">PC</span>, соответствующее адресу следующей, с неё-то 
	и продолжится выполнение программы после отработки нашего <span class="cmds">
	RTI</span>. В зависимости от конкретных команд такой &laquo;<i>финт</i>&raquo; 
	может привести к самым неприятным последствиям, вплоть до зависания системы. 
	Как же тогда быть? Надо поступить хитрее. Необходимо предусмотреть в программе 
	специальный, так называемый &laquo;<i>холодный</i>&raquo; вход (т.е. адрес, 
	при передаче управления на который не произойдёт нарушения работы программы). 
	Впрочем, правильнее всего было бы называть его <b>повторным</b> входом в программу 
	На этот вход и надлежит передать управление по клавише &laquo;<i>СТОП</i>&raquo;, 
	для чего его адрес указывается в качестве вектора прерывания. Пусть повторный 
	вход в нашей программе (например, игре) - по метке <span class="labl">RBG</span>. 
	Напишем:</p>
	<pre><span class="labl">V4</span>:     <span class="cmds">MOV</span>     #<span class="nmbr">1000</span>,<span class="regn">SP</span>
        <span class="cmds">JMP</span>     <span class="labl">RBG</span></pre>
	<p>Вот и всё. Вторая команда ясна - это просто передача управления на повторный 
	вход. А зачем первая, что мы записываем в регистр <span class="regn">SP</span> 
	и для чего? Вспомним, как выполняется прерывание: в стек заносятся для сохранения 
	ССП и <span class="regn">PC</span>. При этом, конечно, изменяется и указатель 
	стека <span class="regn">SP</span> - его значение уменьшается на
	<span class="nmbr">4</span>. Команда <span class="cmds">RTI</span> в конце программы 
	обработки прерывания не только восстанавливает ССП и <span class="regn">PC</span>, 
	но и &laquo;<i>очищает</i>&raquo; стек, приводя его указатель в исходное состояние. 
	Но в нашей программе её нет! Это значит, что при каждом нажатии &laquo;<i>СТОП</i>&raquo; 
	стек будет &laquo;<i>засоряться</i>&raquo; всё новыми значениями ССП и
	<span class="regn">PC</span>, а он не безграничен. Рано или поздно стек будет 
	исчерпан, и тогда... Вот для предотвращения этого и служит первая команда - 
	она восстанавливает вершину стека, &laquo;<i>чистит</i>&raquo; его. Число же
	<span class="nmbr">1000</span> - это начальное содержимое <span class="regn">
	SP</span> в мониторе, но ничего страшного обычно не происходит, если такая вершина 
	стека будет установлена в любом режиме.</p>
	<p>А теперь предположим, что нам нужно кроме перезапуска программы по &laquo;<i>СТОП</i>&raquo; 
	сохранить и возможность выхода из неё. Как быть? Напишем такую программу обработки 
	прерывания:</p>
	<pre><span class="labl">V4</span>:     <span class="cmds">MOV</span>     #<span class="nmbr">1000</span>,<span class="regn">SP</span>            <span class="cmmnt">; Восстановить SP</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ожидание нажатия клавиши</span>
        <span class="cmds">CMPB</span>    #<span class="nmbr">40</span>,<span class="regn">R0</span>              <span class="cmmnt">; Код ПРОБЕЛ ?</span>
        <span class="cmds">BEQ</span>     <span class="locl">0</span>                   <span class="cmmnt">; Да - к метке 0</span>
        <span class="cmds">JMP</span>     <span class="labl">RBG</span>                 <span class="cmmnt">; Иначе - повторный вход</span>
<span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">14</span>                  <span class="cmmnt">; Восстановить векторы</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Останов и выход в ПМ</span></pre>
	<p>Первым делом мы &laquo;<i>чистим</i>&raquo; стек. Затем следует команда
	<span class="cmds">EMT</span> <span class="nmbr">6</span> - ожидание ввода символа 
	с клавиатуры, его код будет записан в регистр <span class="regn">R0</span>. 
	Если это код <span class="nmbr">40</span> - &laquo;<em>ПРОБЕЛ</em>&raquo;, то 
	должен последовать останов, для чего выполняется переход к метке
	<span class="nmbr">0</span>. А что делает команда <span class="cmds">EMT</span>
	<span class="nmbr">14</span>? Она устанавливает состояние ЭВМ в &laquo;<i>исходное 
	положение</i>&raquo;, в том числе переписывает все векторы прерывания на стандартные 
	адреса монитора. После этого команда <span class="cmds">HALT</span> приводит 
	к обычному результату - останову программы. Если же нажат не &laquo;<em>ПРОБЕЛ</em>&raquo;, 
	а иная клавиша, тогда перехода к метке <span class="nmbr">0</span> не будет 
	и обработка прерывания закончится как предыдущая - перезапуском программы по 
	метке <span class="labl">RBG</span>.</p>
	<p class="centr">★ ★ ★</p>
	<p>Довольно интересное применение может найти вектор @#<span class="nmbr">10</span> 
	- прерывание по резервному коду. Да что там может - уже нашёл! В Фокале он использован 
	для обработки псевдокоманд и функций. Эти псевдокоманды имеют коды в диапазоне
	<span class="nmbr">7000</span>...<span class="nmbr">7377</span>. Такие коды 
	отсутствуют в наборе команд ЦП, и при их обнаружении происходит прерывание по 
	вектору @#<span class="nmbr">10</span>. А этот вектор в Фокале &laquo;<i>направлен</i>&raquo; 
	на специальную программу интерпретатора этого языка, которая выделяет код, вызвавший 
	прерывание, и в зависимости от него передаёт управление подпрограммам реализации 
	команд Фокала. Совершенно аналогично можно организовать и выполнение специальных 
	дополнительных команд в программе пользователя, лишь бы выбранные коды отсутствовали 
	в наборе команд ЦП БК-0010. Так, в литературе (см. Микропроцессорные средства 
	и системы. <span class="nmbr">1988</span>. №<span class="nmbr">4</span>. с.
	<span class="nmbr">47</span>) описан <b>эмулятор</b> (эмуляция - имитация функционирования 
	одной системы средствами другой) команд расширенной арифметики для ЭВМ <i>ДВК-2</i>, 
	основанный как раз на этом принципе. Он позволяет исполнять на <i>ДВК-<span class="nmbr">2</span></i> 
	программы. написанные для <i>СМ-<span class="nmbr">4</span></i> и &laquo;<i>Электроники-60</i>&raquo;, 
	не прибегая к их <b>адаптации</b> (переделке под другую систему команд)<a href="#_ftn1" name="_ftnref1" title=""><sup>[1]</sup></a>.</p>
	<p class="centr">★ ★ ★</p>
	<p>А теперь займёмся довольно сложным, но весьма интересным вектором @#<span class="nmbr">14</span>. 
	Вам, наверное, приходилось отлаживать программы, и при этом, конечно, были случаи, 
	когда вы никак не могли найти ошибку, а программа так и не желала работать как 
	надо. При этом у вас возникало острое желание &laquo;<i>заглянуть внутрь</i>&raquo; 
	работающей программы, посмотреть, в каком порядке выполняются команды и каковы 
	результаты их действий. В большинстве языков высокого уровня такой <b>трассировочный 
	режим</b> предусмотрен. А для программ в кодах существуют специальные программы 
	- <b>отладчики</b>, позволяющие выполнять команды по одной. Как же они работают?</p>
	<p>Если вы помните, при рассмотрении ССП (или <span class="regn">PS</span>) 
	мы упоминали так называемый <span class="symb">T</span>-разряд (бит
	<span class="nmbr">04</span> ССП). Если записать туда &laquo;<i>1</i>&raquo;, 
	то работа программы будет прерываться после выполнения каждой команды, по вектору 
	@#<span class="nmbr">14</span>. Но ведь это как раз то, что нужно для отладки, 
	тот самый трассировочный режим! Перепишем вектор @#<span class="nmbr">14</span> 
	и разместим по указанному в нём адресу программу, которая, например, будет выдавать 
	на экран адреса и коды выполняемых команд, а также содержимое регистров, значение 
	ССП и пр. Прекрасно, давайте попробуем:</p>
	<pre>        <span class="cmds">MTPS</span>    #<span class="nmbr">20</span></pre>
	<p>Что получается? Ничего - этой командой <span class="symb">T</span>-разряд 
	не изменить! А если бы она записала в <span class="symb">T</span>-разряд &laquo;<i>1</i>&raquo;, 
	что бы произошло? Работа программы сейчас же прервалась бы по вектору @#
	<span class="nmbr">14</span>, а из его второго слова было бы переписано ССП 
	с нулевым <span class="symb">T</span>-разрядом. Но даже если занести и туда 
	код <span class="nmbr">20</span>, всё равно ничего хорошего не получится - нам 
	нужно прерывание не после записи <span class="symb">T</span>-разряда, а после 
	выполнения очередной команды <b>отлаживаемой</b> программы. Нужно найти другой 
	путь, чтобы, как только будет установлен <span class="symb">T</span>-разряд, 
	сразу начала выполняться очередная команда. А как только она будет выполнена 
	- произойдёт прерывание по вектору @#<span class="nmbr">14</span>, и мы сможем 
	узнать о только что выполненной команде то, что хотим. Как это сделать? Как 
	записать <span class="symb">T</span>-разряд в нужный момент, &laquo;<i>на самом 
	краю</i>&raquo; запуска очередной команды?</p>
	<p>Вспомним, как выполняется возврат из прерывания. Из стека восстанавливается 
	сначала <span class="regn">PC</span>, а затем - ССП: то значение
	<span class="regn">PS</span>, которое было занесено в стек при переходе к обработке 
	прерывания, пишется обратно в регистр <span class="regn">PS</span>. А потом? 
	Потом начинается выполнение следующей команды программы... Ага, кажется, именно 
	это нам и нужно! Что если перед возвратом из прерывания &laquo;<i>подменить</i>&raquo; 
	сохранение в стеке значение ССП на такое, в котором установлен
	<span class="symb">T</span>-разряд? Процессор его &laquo;<i>скушает</i>&raquo;, 
	не подозревая &laquo;<i>подвоха</i>&raquo;, и выполнит очередную команду, после 
	чего проверит <span class="symb">T</span>-разряд и обнаружит, что там &laquo;<span class="nmbr">1</span>&raquo;. 
	Ему ничего не останется, кроме как выполнить прерывание по вектору @#<span class="nmbr">14</span>. 
	А тут-то мы его и будем ждать со своей программой, чтобы &laquo;<i>подсмотреть</i>&raquo; 
	то, что нам нужно... Кажется, путь найден! Но сначала нужно организовать прерывание, 
	чтобы при выходе из него &laquo;<i>обмануть</i>&raquo; ЦП. По какой команде 
	это сделать? В принципе, можно по любой, лишь бы это было именно командное прерывание. 
	Но в наборе команд есть специальная операция <span class="cmds">BPT</span>, 
	которая вызывает прерывание по тому же вектору @#<span class="nmbr">14</span> 
	(но не отладочное по <span class="symb">T</span>-разряду, а просто командное, 
	на манер <span class="cmds">EMT</span>). Воспользуемся ею и не будем трогать 
	другие векторы. А что мы будем делать во время &laquo;<i>отладки</i>&raquo;? 
	Что хотим &laquo;<i>подсмотреть</i>&raquo;? Прежде всего, нам нужно определить, 
	какая команда выполняется, а для этого желательно узнать её адрес и код (пока 
	мы не будем замахиваться на то, чтобы дизассемблировать команды - переводить 
	их на язык ассемблера, - это чересчур сложно). И пусть нас ещё интересует, к 
	примеру, содержимое одного из регистров - <span class="regn">R1</span>. А затем 
	напишем какую-нибудь программку, которая будет работать именно с
	<span class="regn">R1</span>, и посмотрим, что получится. Желательно также иметь 
	хотя бы минимальный &laquo;<i>сервис</i>&raquo; - хоть как-то маркировать выводимые 
	данные, чтобы можно было понять, где адрес, где код команды, а где - содержимое 
	регистра. А как переходить к следующей команде? Пусть для простоты &laquo;<i>отлаживаемая</i>&raquo; 
	программа выполняется тогда, когда нажата любая клавиша, а если клавишу отпустить, 
	можно просмотреть данные, выдаваемые &laquo;<i>отладчиком</i>&raquo;. Итак, &laquo;<i>техническое 
	задание</i>&raquo; на программный продукт готово. Осталось написать программу, 
	а &laquo;<i>что нам стоит дом построить</i>&raquo;, да ещё из такого податливого &laquo;<i>материала</i>&raquo; 
	как операторы ассемблера? Вот наш простейший &laquo;<i>отладчик</i>&raquo; и 
	готов:</p>
	<pre><span class="cmmnt">; Запуск отладчика</span>
        <span class="cmds">MOV</span>     #<span class="labl">BPT1</span>,@#<span class="nmbr">14</span>          <span class="cmmnt">; Записать пусковой вектор @#14</span>
        <span class="cmds">BPT</span>                         <span class="cmmnt">; Прерывание по вектору @#14</span>
<span class="cmmnt">; Демонстрационная программа</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">1</span>,<span class="regn">R1</span>               <span class="cmmnt">; Записать в R1 единицу</span>
<span class="locl">0</span>:      <span class="cmds">ASL</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Сдвиг влево R1</span>
        <span class="cmds">ADC</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Прибавить перенос</span>
        <span class="cmds">BR</span>      <span class="nmbr">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="cmmnt">; Трассировка демонстрационной программы</span>
<span class="labl">TRS</span>:    <span class="cmds">MOV</span>     <span class="regn">R0</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить в стеке</span>
        <span class="cmds">MOV</span>     <span class="regn">R3</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; регистры,</span>
        <span class="cmds">MOV</span>     <span class="regn">R4</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; используемые</span>
        <span class="cmds">MOV</span>     <span class="regn">R5</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; в &quot;отладчике&quot;</span>
        <span class="cmds">MOV</span>     '<span class="strn">A=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Сообщение &quot;адрес&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; выдать</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; на</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; экран</span>
        <span class="cmds">MOV</span>     <span class="nmbr">10</span>(<span class="regn">SP</span>),<span class="regn">R3</span>           <span class="cmmnt">; Извлечь из стека PC в R3</span>
        <span class="cmds">MOV</span>     <span class="regn">R3</span>,<span class="regn">R4</span>               <span class="cmmnt">; Печать адреса</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">163220</span>            <span class="cmmnt">; команды</span>
        <span class="cmds">MOV</span>     '<span class="strn">K=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Сообщение &quot;КОД&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; выдать</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; на</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; экран</span>
        <span class="cmds">MOV</span>     @<span class="regn">R3</span>,<span class="regn">R4</span>              <span class="cmmnt">; Печать кода</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">163220</span>            <span class="cmmnt">; команды</span>
        <span class="cmds">MOV</span>     '<span class="strn">R=</span>',<span class="regn">R0</span>             <span class="cmmnt">; Сообщение &quot;регистр&quot;</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; выдать</span>
        <span class="cmds">SWAB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; на</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; экран</span>
        <span class="cmds">MOV</span>     <span class="regn">R1</span>,<span class="regn">R4</span>               <span class="cmmnt">; Печать</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">163220</span>            <span class="cmmnt">; содержимого R1</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">12</span>,<span class="regn">R0</span>              <span class="cmmnt">; Перевод</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; строки</span>
<span class="locl">0</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">100</span>,@#<span class="nmbr">177716</span>       <span class="cmmnt">; Клавиша нажата?</span>
        <span class="cmds">BNE</span>     <span class="locl">0</span>                   <span class="cmmnt">; Нет - ждать, иначе продолжать</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R5</span>            <span class="cmmnt">; Восстановить</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R4</span>            <span class="cmmnt">; регистры</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R3</span>            <span class="cmmnt">; из</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; стека</span>
<span class="cmmnt">; Запись T-разряда, выход из прерывания</span>
<span class="labl">BPT1</span>:   <span class="cmds">BIS</span>     #<span class="nmbr">20</span>,<span class="nmbr">2</span>(<span class="regn">SP</span>)           <span class="cmmnt">; Занести T-разряд в ССП в стеке</span>
        <span class="cmds">MOV</span>     #<span class="labl">TRS</span>,@#<span class="nmbr">14</span>           <span class="cmmnt">; Записать рабочий вектор @#14</span>
        <span class="cmds">RTT</span>                         <span class="cmmnt">; Выход из прерывания</span>
        <span class="pscm">END</span></pre>
	<p>Разберёмся с некоторыми деталями. Сначала мы пишем в качестве вектора @#<span class="nmbr">14</span> 
	адрес метки <span class="labl">BPT1</span> и даём прерывание
	<span class="cmds">BPT</span>. Происходит переход к метке <span class="labl">
	BPT1</span>, а там мы заносим в ССП, хранящееся в стеке (оно на
	<span class="nmbr">2</span> выше вершины, ведь мы в прерывании!), единицу в
	<span class="symb">T</span>-разряд. Затем записываем новый вектор @#<span class="nmbr">14</span> 
	(&laquo;<i>рабочий</i>&raquo;, т.е. тот, по которому будет передаваться управление 
	при прерывании по <span class="symb">T</span>-разряду), после чего следует команда 
	возврата из прерывания, но не <span class="cmds">RTI</span>, a
	<span class="cmds">RTT</span>. Она незначительно отличается от
	<span class="cmds">RTI</span> (мы уже упоминали, чем именно: после её выполнения 
	не происходит прерывания по <span class="symb">T</span>-разряду) и применяется 
	для выхода из отладочного прерывания.</p>
	<p>Теперь запускается наша демонстрационная программа. Она зациклена и делает 
	следующее: сначала в <span class="regn">R1</span> пишется <span class="nmbr">
	1</span>. затем <span class="regn">R1</span> сдвигается влево. Когда &laquo;<span class="nmbr">1</span>&raquo; 
	достигнет старшего разряда <span class="regn">R1</span>, возникает перенос, 
	но бит переноса каждый раз прибавляется к <span class="regn">R1</span>, поэтому 
	единица снова попадёт в младший разряд, опять начнёт сдвигаться, и так до бесконечности.</p>
	<p>После выполнения каждой команды происходит прерывание по
	<span class="symb">T</span>-разряду (ведь наш &laquo;<i>отладчик</i>&raquo; 
	включён!) и управление передаётся на метку <span class="labl">TRS</span> - &laquo;<i>Трассировка</i>&raquo;.</p>
	<p>Вот теперь в работе отладчик. Прежде всего, трассировки в нём самом уже нет 
	- ведь после прерывания в ССП переписалось новое значение из адреса @#<span class="nmbr">16</span> 
	- второго слова вектора. Мы не знаем, что там было, но в данном случае это неважно:
	<span class="symb">T</span>-разряд там равен нулю, будьте уверены! И отлично, 
	иначе отладчик не смог бы работать, а прерывал бы сам себя после каждой команды. 
	В отладчике мы будем использовать часть регистров, а чтобы не возникло потом 
	неприятностей, сохраним их в стеке (в данном случае это не важно, но для других 
	отлаживаемых программ пригодится). Сначала будем выдавать адрес команды. Даём 
	сообщение &laquo;<span class="strn">А=</span>&raquo; - это наш &laquo;<i>сервис</i>&raquo;, 
	а потом. Вспомним, что у нас сейчас хранится в стеке. По порядку туда было записано: 
	ССП, <span class="regn">PC</span>, <span class="regn">R0</span>,
	<span class="regn">R3</span>, <span class="regn">R4</span>,
	<span class="regn">R5</span>. Ага, <span class="regn">PC</span> нам и надо, 
	ведь там адрес. Но какой? Адрес следующей команды. Что же, для простоты давайте 
	индицировать как раз следующую команду, это даже удобнее - мы сначала посмотрим, 
	что &laquo;там, за поворотом&raquo;, а потом уже разрешим ей работать (кстати, 
	именно так обычно и делается в настоящих отладчиках). Итак,
	<span class="regn">PC</span> в стеке на <span class="nmbr">8</span> байт от 
	вершины (после него в стек мы &laquo;<i>загнали</i>&raquo; ещё
	<span class="nmbr">4</span> регистра). Применяем косвенную индексацию:
	<span class="nmbr">10</span>(<span class="regn">SP</span>). Мы &laquo;<i>достали</i>&raquo; 
	значение <span class="regn">PC</span>, теперь надо его выдать на экран. Но нам 
	он ещё пригодится, поэтому не пожалеем для него отдельного регистра
	<span class="nmbr"><span class="regn">R3</span></span>. А как выдать его на 
	экран? В МСД есть подпрограмма, которая делает то, что нам нужно, - выдаёт на 
	экран содержимое регистра <span class="regn">R4</span>. Чтобы не писать её заново, 
	просто обратимся к ней по адресу @#<span class="nmbr">163220</span>. Она не 
	сохраняет регистры <span class="regn">R0</span>, <span class="regn">R4</span> 
	и <span class="regn">R5</span>, вот почему мы их оставили в стеке вместе с
	<span class="nmbr"><span class="regn">R3</span></span>. Итак, число (значение
	<span class="regn">PC</span>) сначала копируется в <span class="regn">R4</span>, 
	потом выводится на экран. Готово, поехали дальше! Сервис &laquo;<span class="strn">К=</span>&raquo;, 
	это будет код команды. Вот теперь нам пригодится <span class="regn">R3</span>, 
	ведь там адрес, а по этому адресу - сама команда. Словом, косвенное обращение 
	через регистр. В <span class="regn">R4</span> его и на экран! Ну, а теперь совсем 
	просто: содержимое <span class="regn">R1</span>, которое мы хотим &laquo;<i>подсмотреть</i>&raquo;, 
	гоним туда же, но сначала опять сервис: &laquo;<span class="strn">R=</span>&raquo;. 
	Выведена строка параметров, адрес, код команды, содержимое
	<span class="regn">R1</span>. Чтобы не запутаться, переведём строку. Что мы 
	ещё хотели? Ах, да! Если клавиша нажата - программа работает, если нет - ждёт. 
	Регистр @#<span class="nmbr">177716</span> дозволяет решить и эту задачу. Вот 
	мы нажали любую клавишу, и программа пошла дальше: восстановлены регистры, и... 
	А дальше мы уже были - снова заносим вектор @#<span class="nmbr">14</span> и
	<span class="symb">T</span>-разряд (можно бы этого и не делать, но лучше перестраховаться) 
	и возвращаемся из прерывания. Вперёд, нас ждёт следующая команда!</p>
	<p>Выглядит не слишком сложно, не правда ли? А ведь наша программа имеет практически 
	все основные черты настоящего отладчика. Конечно, есть масса деталей, которых 
	мы ещё не учли. Например, если команда отлаживаемой программы состоит из двух 
	или трёх слов, то будет выдано только её первое слово. А если в отлаживаемой 
	программе встретится <span class="cmds">EMT</span> <span class="nmbr">14</span>, 
	то перепишутся все векторы (и <span class="nmbr">14</span>-й в том числе), и 
	прощай отладочный режим! И не всё, что надо, мы видим на экране, и нет точки 
	останова, и нет дизассемблера, и наш отладчик неперемещаемый, и... Ну ясно, 
	а что же вы хотели? Чтобы, едва освоив ассемблер, сделать настоящий отладчик? 
	Но главное - понять, как он работает, и эта цель достигнута. А дальше дело за 
	вами.</p>
	<p>Но прежде чем окончательно проститься с вектором @#<span class="nmbr">14</span>, 
	рассмотрим ещё один вопрос. При пользовании отладчиком (простейшим или самым 
	сложным) любое командное прерывание, будь то <span class="cmds">EMT</span>,
	<span class="cmds">TRAP</span>, <span class="cmds">IOT</span> или другое, отрабатывается 
	в пошаговом режиме как одна команда. Это естественно - ведь при обращении к 
	прерыванию переписывается ССП и <span class="symb">T</span>-разряд сбрасывается, 
	а с ним на время обработки прерывания отключается и трассировочный режим. Поэтому 
	мы видим на экране просто &laquo;<span class="cmds">EMT</span>
	<span class="nmbr">32</span>&raquo; или &laquo;<span class="cmds">TRAP</span>
	<span class="nmbr">114</span>&raquo;, не более. Но мы-то теперь знаем, что за 
	такой скромной &laquo;<i>вывеской</i>&raquo; могут скрываться сотни команд... 
	Как бы их &laquo;<i>подсмотреть</i>&raquo;, увидеть, как работает
	<span class="cmds">EMT</span>-диспетчер, где находится и что делает программа 
	обработки команды <span class="cmds">IOT</span>? Неужели ничего нельзя сделать? 
	Можно. Достаточно переписать второе слово интересующего нас вектора прерывания, 
	занеся туда <span class="symb">T</span>-разряд, и прерывание это станет &laquo;<i>видимым</i>&raquo; 
	для отладчика, т.е. и внутри него будет обеспечиваться пошаговый режим и индикация 
	всего, что нас интересует.</p>
	<p class="centr">★ ★ ★</p>
	<p>Следующий по порядку вектор прерывания - @#<span class="nmbr">20</span>. 
	Прерывание по нему возникает по команде <span class="cmds">IOT</span> и аналогично 
	командным прерываниям <span class="cmds">BPT</span>, <span class="cmds">EMT</span> 
	и <span class="cmds">TRAP</span>, только, в отличие от двух последних, не имеет 
	аргументов. Оно может быть использовано для выполнения каких-нибудь действий. 
	Допустим, нам нужно подать в определённый момент звуковой сигнал. В начале программы 
	запишем: <span class="cmds">MOV</span> #<span class="labl">IOT</span>,@#<span class="nmbr">20</span> 
	- это мы переписали вектор @#<span class="nmbr">20</span>. Напишем теперь программу 
	обработки прерывания:</p>
	<pre><span class="labl">IOT</span>:    <span class="cmds">MOV</span>     #<span class="nmbr">7</span>,<span class="regn">R0</span>               <span class="cmmnt">; Код звукового сигнала</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">100</span>,<span class="regn">R1</span>             <span class="cmmnt">; 100 повторов (64д)</span>
<span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Выдать звук (щелчок)</span>
        <span class="cmds">SOB</span>     <span class="regn">R1</span>,<span class="locl">0</span>                <span class="cmmnt">; Цикл по R1</span>
        <span class="cmds">RTI</span>                         <span class="cmmnt">; Выход из прерывания</span></pre>
	<p>Теперь в любой момент можно вызвать звуковой сигнал одной командой
	<span class="cmds">IOT</span>. С равным успехом она же может применяться и для 
	любых других целей. Вообще же команда <span class="cmds">IOT</span> предназначена 
	для вызова процедур и обработки ошибок в операционных системах, и по этой причине 
	её лучше не трогать &laquo;<i>по мелочам</i>&raquo;, иначе при работе ваших 
	программ с дисководом (если он у вас имеется) могут возникнуть проблемы. Впрочем, 
	то же может быть отнесено к командам <span class="cmds">TRAP</span>,
	<span class="cmds">EMT</span>, <span class="cmds">BPT</span>, к использованию 
	свободных ячеек в системной области... Вообще, лучше ничего не трогать! И не 
	писать программы - тогда и проблем не будет... А если серьёзно, то в каждом 
	конкретном случае нужно точно знать, что &laquo;<i>трогать</i>&raquo;, а что 
	- нет. (Обычно такие сведения - об используемых ячейках и ограничениях на изменение 
	их содержимого - приводятся в документации к операционным системам, отладчикам, 
	мониторам и т.д. - <em>Прим. ред.</em>)</p>
	<p class="centr">★ ★ ★</p>
	<p>Вектор @#<span class="nmbr">24</span> для нас практически бесполезен. так 
	как на БК-0010 он не имеет так называемой <b>аппаратной поддержки</b>. Но можно 
	убедиться, что программа его обработки в ПЗУ имеется. Дайте в МСД команду
	<span class="nmbr">160714</span><span class="var">G</span> - и вы получите ответ &laquo;<b>сбой 
	питания</b>&raquo;. Ну а если всё-таки вспомнить, что прерывание по вектору 
	@#<span class="nmbr">24</span> возникает при подаче сигнала на вход ACLO ЦП? 
	Если не побояться залезть в БК с паяльником? Да, кое-чего мы можем достигнуть. 
	Если подать на вывод <span class="nmbr">13</span> микросхемы D<span class="nmbr">6</span>.<span class="nmbr">4</span> 
	(К<span class="nmbr">561</span>ЛЕ5) положительный импульс, то произойдёт прерывание 
	по вектору @#<span class="nmbr">24</span>! Подать такой импульс можно, если 
	сначала зарядить конденсатор небольшой ёмкости (<span class="nmbr">0</span>.<span class="nmbr">03</span>...<span class="nmbr">0</span>.<span class="nmbr">05</span> 
	мкФ) до напряжения +<span class="nmbr">5</span> В, а затем разрядить его на 
	вывод <span class="nmbr">13</span> D<span class="nmbr">6</span>.<span class="nmbr">4</span> 
	(есть, впрочем, и другие способы). Чего мы достигнем? Прерывание ACLO - внеприоритетное, 
	аналогично клавише &laquo;<i>СТОП</i>&raquo;, и, переписав вектор @#<span class="nmbr">24</span>, 
	мы можем нажатием дополнительной кнопки обратиться по этому вектору. А там, 
	например, может быть программа графического копирования экрана. Или программа 
	инициализации принтера. Или что-нибудь ещё... Но тут пора сказать, что автор 
	категорически не рекомендует лезть в БК с паяльником тем читателям, которые 
	берут его в руки не чаще, чем раз в месяц, да и то, чтобы напаять &laquo;<i>жучок</i>&raquo; 
	на предохранитель. И никакой ответственности за их действия автор (как и редакция) 
	на себя брать не собирается.</p>
	<p class="centr">★ ★ ★</p>
	<p>Теперь рассмотрим последний из оставшихся векторов прерывания - @#<span class="nmbr">100</span>. 
	Это, как уже было сказано, прерывание по таймеру. Таймер имеется в виду <b>внешний</b> 
	- это подключаемое к БК устройство, выдающее импульсы строго определённой частоты, 
	например <span class="nmbr">10</span> импульсов в секунду. Импульсы, подаваемые 
	на вход таймера (контакт В1 порта ввода-вывода), должны иметь уровень ТТЛ-логики 
	(&laquo;<i class="nmbr">0</i>&raquo;, или <b>низкий уровень</b> - от
	<span class="nmbr">0</span> до <span class="nmbr">0</span>.<span class="nmbr">4</span> 
	В; &laquo;<i class="nmbr">1</i>&raquo;, или <b>высокий уровень</b> - от
	<span class="nmbr">2</span>.<span class="nmbr">4</span> до
	<span class="nmbr">5</span> В). При прохождении на вход таймера <b>заднего фронта</b> 
	импульса (т.е. когда &laquo;<i>единица</i>&raquo; сменяется &laquo;<i>нулём</i>&raquo;) 
	возникает прерывание по вектору @#<span class="nmbr">100</span> (если, конечно, 
	его разрешает приоритет ЦП). Как можно использовать этот вектор? Можно по прямому 
	назначению, для отсчёта времени. Но, кроме того, это дополнительный канал связи 
	БК с внешним миром, и его применения могут быть различными. Если, допустим, 
	у вас есть магнитофон, в котором имеется счётчик, выдающий импульсы при вращении 
	кассеты, можно подать эти импульсы (конечно, преобразовав их к нужному уровню!) 
	на вход таймера и, подсчитывая их, получить программный счётчик расхода ленты. 
	Правда, тут есть одна неприятность - при записи на магнитофон или чтении прерывания 
	должны быть запрещены, иначе информация будет искажена. Но можно сделать счётчик, 
	работающий только при перемотке, и таким образом автоматизировать хотя бы поиск 
	файлов (разумеется, для этого магнитофон должен иметь полное дистанционное управление, 
	и вообще это не так просто). А можно подключить ко входу таймера, например,
	<b>аналого</b>-<b>цифровой преобразователь</b> (АЦП) типа ПНЧ - преобразователь 
	напряжения в частоту и, пользуясь системным (встроенным) таймером, измерять 
	число поступивших импульсов в единицу времени, а затем вычислять измеренное 
	напряжение (или иной параметр) Или можно сделать так, чтобы ЭВМ при поступлении 
	на вход В1 сигнала считывала информацию с внешних устройств (например, с микрокалькулятора 
	или с цифрового измерительного прибора) или, наоборот, выдавала информацию на 
	порт ввода-вывода либо на ТЛГ-канал. Приведём элементарный пример обработки 
	прерывания по вектору @#<span class="nmbr">100</span>
	<a href="#_ftn2" name="_ftnref2" title=""><sup>[2]</sup></a>.</p>
	<pre><span class="cmmnt">; Инициализация программы</span>
        <span class="cmds">CLR</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Очистить счётчик</span>
        <span class="cmds">MOV</span>     #<span class="labl">ТIМ</span>,@#<span class="nmbr">100</span>          <span class="cmmnt">; Записать вектор @#100</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Конец</span>
<span class="cmmnt">; Счёт импульсов с индикацией</span>
<span class="labl">TIM</span>:    <span class="cmds">INC</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Счётчик увеличить на 1</span>
        <span class="cmds">MOV</span>     <span class="regn">R1</span>,<span class="regn">R4</span>               <span class="cmmnt">; Выдать текущие</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">163220</span>            <span class="cmmnt">; показания на экран</span>
        <span class="cmds">RTI</span>                         <span class="cmmnt">; Возврат из прерывания</span>
        <span class="pscm">END</span></pre>
	<p>Разумеется, в зависимости от наших целей программа обработки прерывания может 
	быть и другой. Максимальная частота подаваемых на вход таймера импульсов ограничена 
	временем, затрачиваемым на обработку каждого прерывания, и может при простейших 
	подпрограммах обработки достигать <span class="nmbr">20</span>-<span class="nmbr">30</span> 
	кГц. Только надо учитывать, что при этом скорость обработки компьютером текущей 
	задачи резко снижается, ибо почти всё время уходит на обработку прерываний.</p>
	<h3><a name="toc_43"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Придумайте способ, который бы позволил обращаться с помощью команды
		<span class="cmds">IOT</span> не к одной программе обработки, а к нескольким, 
		как <span class="cmds">EMT</span>.
		<ul id="ctrla">
			<li>
			<p>Нужно после <span class="cmds">IOT</span> записать в программу аргумент, 
			например, так:</p>
			<pre><span class="cmds">IOT</span>
<span class="pscm">.#</span><span class="nmbr">122</span></pre>
			<p>Программа же обработки прерывания должна содержать своеобразный диспетчер, 
			который прочитает аргумент из памяти, выполнит по нему нужную программу, 
			а перед возвратом из прерывания увеличит в стеке содержимое
			<span class="regn">PC</span> на <span class="nmbr">2</span>, чтобы &laquo;<i>обойти</i>&raquo; 
			аргумент и не передать на него управление. Про то, что команду
			<span class="cmds">IOT</span> лучше вообще не трогать, уже говорилось, 
			но это не причина чтобы лишить читателя удовольствия поломать голову.</p>
			</li>
		</ul>
		</li>
		<li>Каково &laquo;<i>нормальное</i>&raquo; содержимое вектора прерывания 
		@#<span class="nmbr">4</span> в ПМ, МСД, Фокале и Бейсике? Предложите способы, 
		которые бы позволили это узнать.
		<ul id="ctrla">
			<li>
			<p>Содержимое вектора @#<span class="nmbr">4</span>:
			<span class="nmbr">100442</span>, <span class="nmbr">160722</span>,
			<span class="nmbr">121110</span>, <span class="nmbr">120234</span>. 
			Узнать его можно, если прочитать ячейку @#<span class="nmbr">4</span>. 
			В МСД это делается непосредственно, в Бейсике и Фокале - с помощью средств 
			этих языков (функции <span class="cmdf">PEEK</span> и
			<span class="cmdf">FX</span> соответственно), а в ПМ придётся написать 
			и запустить программу:</p>
			<pre>        <span class="cmds">MOV</span>     @#<span class="nmbr">4</span>,<span class="regn">R4</span>
        <span class="cmds">CALL</span>    @#<span class="nmbr">163220</span>
        <span class="cmds">HALT</span>
        <span class="pscm">END</span></pre>
			</li>
		</ul>
		</li>
	</ol>
	<p>А что же векторы прерываний, &laquo;<i>жизненно необходимые</i>&raquo; самой 
	ЭВМ, - прерывания от клавиатуры @#<span class="nmbr">60</span> и @#<span class="nmbr">274</span>, 
	а также уже не раз рассмотренные векторы командных прерываний @#<span class="nmbr">30</span> 
	и @#<span class="nmbr">34</span>? Не забыл ли о них автор? Нет, просто эти векторы 
	недостаточно рассмотреть на отдельных примерах, как другие. Работа с ними может 
	привести к таким последствиям, к таким ошеломляющим на первый взгляд возможностям 
	и результатам, что их лучше оставить для отдельной темы, к рассмотрению которой 
	мы теперь и переходим.</p>
	<h2><a name="toc_44"></a>Концепция системных драйверов</h2>
	<p>Жил-был... нет, не серенький козлик. И не у бабушки. Был у пользователя редактор 
	текста. Неплохой, в общем, редактор <i>EDASP</i>. И был к нему принтер, для 
	которого в редакторе был драйвер. И всё было хорошо, пока пользователю не встретился 
	новый редактор, скажем <i>МИКРО.<span class="nmbr">10</span>К</i>. Он ему понравился, 
	но вот беда - в этом редакторе нет драйвера принтера! Что делать - лезть в
	<i>МИКРО.<span class="nmbr">10</span>К</i> и пытаться &laquo;<i>вставить</i>&raquo; 
	в него драйвер? На этот &laquo;<i>подвиг</i>&raquo;, прямо скажем, способны 
	немногие. Перекодировать тексты, написанные в <i>МИКРО</i> (благо программы &laquo;<i>конверторов</i>&raquo; 
	текста есть), и печатать через <i>EDASP</i>? Ужасно неудобно. А если завтра 
	понравится ещё один редактор? Все проблемы решать заново?</p>
	<p>Или вот на БК-0010 есть язык Фокал. Многие его любят, несмотря на низкую 
	скорость и точность, - он очень гибок. (Попробуйте-ка в Бейсике обратиться к 
	строке, задав её номер в виде переменной или выражения, - а в Фокале это самая 
	заурядная процедура. Или попытайтесь записать на МЛ саму программу программным 
	путём, а не в диалоговом режиме. А Фокал это может!) К тому же этот язык очень 
	экономно расходует память. Например, на Фокале есть программа, которая... сочиняет 
	рассказы о Штирлице! (На полном серьёзе, автор нисколько не шутит.) И причём 
	довольно смешные рассказы! О возможности таких программ (но только о возможности!) 
	пишет <em>Д. Кнут</em> в своей знаменитой трёхтомной книге &laquo;<i>Искусство 
	программирования на ЭВМ</i>&raquo;, а на БК - пожалуйста, вот она, эта программа. 
	Вот бы распечатать &laquo;<i>сочинённый</i>&raquo; рассказ на бумаге! Но увы, 
	в Фокале не предусмотрено выхода на принтер...</p>
	<p>Или у вас есть принтер и есть Бейсик. В Бейсике, конечно, есть специальные 
	операторы для вывода на печать. Но, к сожалению, ваш принтер и Бейсик взаимно 
	несовместимы - формат выдачи Бейсика &laquo;<i>не нравится</i>&raquo; принтеру 
	или наоборот. Причём принтер этот, как ни странно, работает с некоторыми редакторами 
	текста, но, как назло, с теми, с которыми не любите работать вы... Что делать 
	- покупать за большие деньги электронную &laquo;<i>приставку</i>&raquo; к принтеру 
	для перевода его протокола обмена в стандартный формат? А для редактора текста 
	ещё одну приставку? А для того, чтобы распечатать красивую заставку к игре, 
	что купить? Фотоаппарат?!</p>
	<p>Или вот вы живете в &laquo;<i>некотором царстве</i>&raquo; (попросту говоря, 
	в республике). Сейчас все вдруг вспомнили, что раз республика суверенная, то 
	надо пользоваться национальным языком. Но вот беда - в школах, институтах и 
	прочих заведениях &laquo;<i>компьютерное население</i>&raquo; сплошь &laquo;<i>русскоязычное</i>&raquo; 
	(ну, конечно, ещё и англоязычное, но ведь мы не в Лондоне или Брайтоне!). Как 
	научить компьютер работать с национальным алфавитом, буквы которого зачастую 
	отличаются от русского и английского по начертанию? Вы скажете, есть специальные 
	редакторы текста, в которых предусмотрен спецалфавит? Но как быть с Бейсиком 
	и Фокалом? Писать текстовые сообщения в программах по-русски? Или не использовать 
	компьютер для этих целей?</p>
	<p>Вот какие могут быть разные задачи. А решаются они, как ни странно, в принципе, 
	всё одинаково - с помощью <b>системных драйверов</b>. Что же это такое - драйвер 
	и чем отличается системный драйвер от обычного?</p>
	<p><b>Драйвер</b> (от английского &laquo;<i>driver</i>&raquo; - &laquo;<i>водитель</i>&raquo;) 
	- это программа, управляющая другими программами или взаимодействующая с внешними 
	устройствами ЭВМ. А что мы понимаем под системным драйвером?</p>
	<p>Пусть нам нужно ввести в редактор текста возможность печати на принтере. 
	Обычный путь таков: мы включаем в редактор дополнительную директиву, например &laquo;<i>печать 
	от метки до курсора</i>&raquo;, и по ней редактор, вместо того чтобы выдать, 
	как обычно, текст на экран, выдаёт заданную часть текста в виде символьного 
	кода на принтер (соблюдая формат обмена с принтером, разумеется). Но возможен 
	и другой путь. Как выводится информация в редакторе текста на экран? Очевидно, 
	через <span class="cmds">EMT</span> <span class="nmbr">16</span> (может быть, 
	и через <span class="cmds">EMT</span> <span class="nmbr">20</span>, но это менее 
	вероятно). Заменим вектор @#<span class="nmbr">30</span> и напишем свою программу 
	его обработки (&laquo;<i>супервизор</i>&raquo;):</p>
	<pre><span class="cmmnt">; Инициализация драйвера</span>
        <span class="cmds">MOV</span>     <span class="regn">PC</span>,R0               <span class="cmmnt">; Вычислить адрес супервизора</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; в перемещаемом</span>
        <span class="pscm">.@</span><span class="cmds">EMT</span>+<span class="nmbr">2</span>                     <span class="cmmnt">; формате</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@#<span class="nmbr">30</span>             <span class="cmmnt">; Записать новый вектор @#30</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Стоп</span>
<span class="cmmnt">; Супервизорная программа</span>
<span class="cmds">EMT</span>:    <span class="cmds">MOV</span>     <span class="regn">R5</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить R5 в стеке</span>
        <span class="cmds">MOV</span>     <span class="nmbr">2</span>(<span class="regn">SP</span>),<span class="regn">R5</span>            <span class="cmmnt">; Адрес следующей команды</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">104016</span>,-(<span class="regn">R5</span>)       <span class="cmmnt">; Текущая команда - EMT 16?</span>
        <span class="cmds">BNE</span>     <span class="locl">3</span>                   <span class="cmmnt">; Нет - выход</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохранить R0</span>
<span class="locl">1</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">400</span>,@#<span class="nmbr">177714</span>       <span class="cmmnt">; Принтер готов?</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; Нет - ждать</span>
        <span class="cmds">BIS</span>     #<span class="nmbr">400</span>,<span class="regn">R0</span>             <span class="cmmnt">; Строб-бит</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@#<span class="nmbr">177714</span>         <span class="cmmnt">; Код символа и строб - в порт</span>
<span class="locl">2</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">400</span>,@#<span class="nmbr">177714</span>       <span class="cmmnt">; Код принят?</span>
        <span class="cmds">BNE</span>     <span class="locl">2</span>                   <span class="cmmnt">; Нет - ждать</span>
        <span class="cmds">BIC</span>     #<span class="nmbr">400</span>,<span class="regn">R0</span>             <span class="cmmnt">; Очистить строб-бит</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@#<span class="nmbr">177714</span>         <span class="cmmnt">; Код в порт</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; Восстановить R0</span>
<span class="locl">3</span>:      <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R5</span>            <span class="cmmnt">; Восстановить R5</span>
        <span class="cmds">JMP</span>     @#<span class="nmbr">100112</span>            <span class="cmmnt">; Выход в EMT-диспетчер</span></pre>
	<p>Что делает эта программа? Сначала она проверяет, какая команда вызвала прерывание 
	по вектору @#<span class="nmbr">30</span>. Если это <span class="cmds">EMT</span>
	<span class="nmbr">16</span>, то надо с ней работать. А если другая -
	<span class="cmds">EMT</span> <span class="nmbr">20</span>,
	<span class="cmds">EMT</span> <span class="nmbr">22</span>,
	<span class="cmds">EMT</span> <span class="nmbr">36</span>? Тогда просто восстановим 
	регистр <span class="regn">R5</span>, который использовался нами для служебных 
	целей, и скатертью дорога в стандартный <span class="cmds">EMT</span>-диспетчер 
	БК-0010, пусть он сам с ней разбирается. А как опознать <span class="cmds">EMT</span>
	<span class="nmbr">16</span>? Конечно, по её коду - <span class="nmbr">104016</span>. 
	А как найти код? Очень просто - мы в прерывании, адрес следующей команды - в 
	стеке (за <span class="nmbr">2</span> байта от вершины), а код предыдущей - 
	в памяти, за <span class="nmbr">2</span> от следующей...</p>
	<p>Когда же команда <span class="cmds">EMT</span> <span class="nmbr">16</span> 
	опознана, мы вспоминаем, что у нас сейчас в младшем байте <span class="regn">
	R0</span> записан код символа, выводимого на экран. А мы вместо экрана выдадим 
	его на принтер! Понятно, что надо соблюдать протокол обмена - сначала дождаться 
	сигнала готовности принтера (стандартно он подключён к разряду
	<span class="nmbr">08</span> порта ввода), затем записать строб-бит (сигнал 
	принтеру: &laquo;Печатай!&raquo;, он подаётся на разряд <span class="nmbr">08</span> 
	порта вывода) и сразу же выдать на восемь младших разрядов порта вывода код 
	символа. Теперь - внимание! Принтер должен принять код и начать его печатать. 
	При этом он снимает сигнал готовности, сигнализируя, что занят другим делом 
	и не может принять следующий код. Дождёмся этого момента и снимем бит стробирования, 
	теперь уж ясно, что принтер код принял и нам можно уходить восвояси за следующим 
	кодом. А &laquo;<i>чтобы чего не вышло</i>&raquo;, мы при входе в программу 
	сохраняем регистр <span class="regn">R0</span>, а потом его восстанавливаем 
	- ведь в его старшем байте, в принципе, тоже могла быть информация, которую 
	мы испортили строб-битом. Теперь всё в порядке, &laquo;<i>словно ничего и не 
	было</i>&raquo;, и можно передать управление в <span class="cmds">EMT</span>-диспетчер, 
	пусть он выведет символ на экран как обычно. Вот и всё.</p>
	<p>Конечно, программа печати и протокол обмена с принтером заведомо выбраны 
	самые примитивные. Реальный принтер может принимать данные в прямом коде (а 
	порт у нас - инвертирующий), тогда придётся ввести команду
	<span class="cmds">COM</span> <span class="regn">R0</span>. Или может потребоваться 
	не одновременная подача строба и данных, а последовательная - сначала одно, 
	потом другое. Вполне возможно также, что кодовая таблица принтера не совпадает 
	с принятой на БК-0010 частично или полностью, тогда до подачи кода символа на 
	принтер его надо перекодировать - привести в соответствие с кодом, требуемым 
	принтеру. Но всё это зависит от конкретного принтера и суть дела не меняет. 
	А суть эта в том, что мы, не меняя программу пользователя, &laquo;<i>сели</i>&raquo; 
	на неё своим драйвером и выводим информацию совсем не туда (или не только туда), 
	куда она должна была выводиться. Это и есть (в нашем определении) системный 
	драйвер, иначе называемый <b>супервизорным</b> драйвером или просто супервизором. 
	(Для справки: супервизорная программа - машинная программа, являющаяся частью 
	операционной системы, которая управляет выполнением других машинных программ 
	и регулирует поток работ в системе управления данными.)</p>
	<p>А что если в программе пользователя имеется, например, команда
	<span class="cmds">EMT</span> <span class="nmbr">14</span>? Она ведь перепишет 
	все векторы прерывания и тем самым &laquo;<i>сбросит</i>&raquo; супервизорный 
	драйвер с системы. Нам нетрудно такую команду &laquo;<i>поймать</i>&raquo; до 
	исполнения, ведь код её известен - <span class="nmbr">104014</span> - и мы можем 
	проверить его, как и <span class="nmbr">104016</span>. Но как быть дальше? Если 
	мы её просто проигнорируем, то тем самым можем нарушить работу программы пользователя 
	- ведь <span class="cmds">EMT</span> <span class="nmbr">14</span> там появилась, 
	наверное, не зря! Надо её выполнить, но так, чтобы &laquo;<i>не выпустить вожжи 
	из рук</i>&raquo;. Сделаем это, переписав нашу программу начиная с метки &laquo;<i>3</i>&raquo;:</p>
	<pre><span class="locl">3</span>:       <span class="cmds">CMP</span>     #<span class="nmbr">104014</span>,@<span class="regn">R5</span>         <span class="cmmnt">; Текущая команда - EMT 14?</span>
         <span class="cmds">BNE</span>     <span class="locl">4</span>                   <span class="cmmnt">; Нет - выход в EMT-диспетчер</span>
         <span class="cmds">MOV</span>     @#<span class="nmbr">30</span>,-(<span class="regn">SP</span>)          <span class="cmmnt">; Сохранить вектор @#30 в стеке</span>
         <span class="cmds">MOV</span>     #<span class="nmbr">100112</span>,@#<span class="nmbr">30</span>        <span class="cmmnt">; Записать &quot;нормальный&quot; вектор @#30</span>
         <span class="cmds">EMT</span>     <span class="nmbr">14</span>                  <span class="cmmnt">; Исполнить EMT 14</span>
         <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,@#<span class="nmbr">30</span>          <span class="cmmnt">; Восстановить вектор @#30</span>
         <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R5</span>            <span class="cmmnt">; Восстановить R5</span>
         <span class="cmds">RTI</span>                         <span class="cmmnt">; Выход из прерывания</span>
<span class="locl">4</span>:       <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R5</span>            <span class="cmmnt">; Восстановить R5</span>
         <span class="cmds">JMP</span>     @#<span class="nmbr">100112</span>            <span class="cmmnt">; Выход в EMT-диспетчер</span></pre>
	<p>Вот так! Сначала восстановили обычный вектор @#<span class="nmbr">30</span> 
	(иначе по <span class="cmds">EMT</span> <span class="nmbr">14</span> система 
	снова выйдет на супервизор), а &laquo;<i>супервизорный</i>&raquo; вектор сохранили 
	в стеке, ведь <span class="cmds">EMT</span> <span class="nmbr">14</span> стек &laquo;<i>не 
	трогает</i>&raquo;. Потом выполнили <span class="cmds">EMT</span>
	<span class="nmbr">14</span>, и теперь можно восстановить &laquo;<i>наш</i>&raquo; 
	вектор @#<span class="nmbr">30</span> из стека. Атака отбита, &laquo;<i>сбросить</i>&raquo; 
	драйвер программе пользователя не удалось! Но изменилась наша программа и в 
	другом - мы уже не можем передать управление в <span class="cmds">EMT</span>-диспетчер, 
	ведь тогда он ещё раз выполнит <span class="cmds">EMT</span>
	<span class="nmbr">14</span>, которое мы только что &laquo;<i>обезвредили</i>&raquo; 
	так что закончим прерывание сами командой <span class="cmds">RTI</span><a href="#_ftn3" name="_ftnref3" title=""><sup>[3]</sup></a>.</p>
	<p>Теперь уже легче сообразить, как можно печатать на принтере не только по
	<span class="cmds">EMT</span> <span class="nmbr">16</span>, но и по
	<span class="cmds">EMT</span> <span class="nmbr">20</span>, - вспомним, какая 
	должна быть исходная информация для этого прерывания.</p>
	<p>В <span class="regn">R1</span> - адрес начала строки текста, в
	<span class="regn">R2</span> - признаки конца: длина строки или код последнего 
	её символа (а может быть, и то и другое). Конечно, это задача посложнее - надо 
	не только вывести строку на принтер, но и выдать её посимвольно на экран, а 
	потом привести регистры <span class="regn">R1</span> и <span class="regn">R2</span> 
	в такое состояние, как будто команда <span class="cmds">EMT</span>
	<span class="nmbr">20</span> сработала без всяких фокусов. Выдавать символы 
	придётся через <span class="cmds">EMT</span> <span class="nmbr">16</span>. а 
	весь этот процесс будет называться эмуляцией команды <span class="cmds">EMT</span>
	<span class="nmbr">20</span>. Мы не приводим соответствующую программу, а предоставляем 
	сделать это читателю - ведь наша книга не справочник программ, её задача - научить 
	читателя самостоятельно эти программы писать. Привести готовые программы драйверов, 
	эмуляторов и т.п. было бы куда как просто!</p>
	<p>А как быть, если наш драйвер должен работать с языком высокого уровня, например 
	с Фокалом? Придётся в него ввести &laquo;<i>повторный выход</i>&raquo; в Фокал. 
	Вернитесь в раздел, посвящённый МСД.</p>
	<p>Там сказано, как выйти в Фокал без стирания ОЗУ. Если вы запомнили, что делают 
	директивы МСД, вам не составит труда написать такую же программу на ассемблере. 
	А чтобы в Фокале можно было нормально работать в присутствии драйвера, нужно 
	драйвер защитить - сделать недоступной для Фокала зону памяти, где он будет 
	размещён. Для этого достаточно перед выходом в Фокал записать адрес начала драйвера 
	в ячейку @#<span class="nmbr">1744</span> - эта ячейка в Фокале &laquo;<i>отвечает</i>&raquo; 
	за зону ОЗУ, доступную интерпретатору. Естественно, найти адрес начала нужно 
	с помощью псевдооператора &laquo;<span class="pscm">.@</span>&raquo;, чтобы 
	не нарушить условия перемещаемости нашего драйвера. Вот теперь всё. Разве что 
	надо будет ввести ещё запрос выхода из инсталлятора драйвера. Если в ПМ или 
	МСД, то в системную область не нужно ничего писать, как это делается для выхода 
	в Фокал, чтобы ничего не напортить. Тогда одна и та же программа-драйвер будет 
	одинаково успешно работать в Фокале и в кодах, например в МСД.</p>
	<p>А Бейсик? С ним всё так же, только надо знать, что он выдаёт свои тексты 
	(всё, кроме сообщения &laquo;Ок.&raquo;) не по <span class="cmds">EMT</span>
	<span class="nmbr">16</span>, а по <span class="cmds">EMT</span>
	<span class="nmbr">20</span>, так что без эмуляции этой команды не обойтись. 
	А специальный выход в Бейсик не обязателен - можно ведь загрузить и запустить 
	драйвер прямо в Бейсике, определив его как пользовательскую функцию в кодах, 
	а затем к ней обратиться, например, так (драйвер размещён по адресу
	<span class="nmbr">30000</span>):</p>
	<pre><span class="cmdf">DEF USR</span>=<span class="oprt">&amp;O</span><span class="nmbr">30000</span>
<span class="cmdf">? USR</span>(<span class="var">A</span>)</pre>
	<p>После этого достаточно дать команду на выход в коды - Бейсик выдаст, конечно, 
	сообщение &laquo;<i>СТОП</i>&raquo; и будет работать как ни в чём не бывало 
	дальше, но теперь всё, что выдаётся на экране, будет печататься и на принтере.</p>
	<p>Но постойте! Ведь это совсем не то, что надо! Нам нужно печатать не всё, 
	а только часть, и не всегда, а только тогда, когда это нужно! Как же быть? Мы 
	этого, кажется, не учли? Ну что же, учтём. Ведь у нас много &laquo;<i>свободных</i>&raquo; 
	кодов, а код символа в нашей программе всегда можно проверить. Введём какую-нибудь 
	ячейку-&laquo;<i>переключатель</i>&raquo; (например, &laquo;<i>на самом дне</i>&raquo; 
	стека по адресу @#<span class="nmbr">374</span>) и будем делать следующее:</p>
	<ul>
		<li>инициализируя драйвер, всегда сбрасываем ячейку,</li>
		<li>символ на печать выдаём только тогда, когда в ячейке не нуль,</li>
		<li>независимо от того, печатается ли символ код его всегда проверяем, и 
		если он равен &laquo;<i>ключу</i>&raquo;, инвертируем нашу ячейку-&laquo;<i>переключатель</i>&raquo;.</li>
	</ul>
	<p>Понятно? Пусть наш &laquo;<i>ключевой</i>&raquo; код - <span class="nmbr">
	1</span>, что соответствует клавише &laquo;<span class="symb">СУ/А</span>&raquo; 
	или команде Бейсика <span class="icode"><span class="cmdf">?CHR$</span>(<span class="nmbr">1</span>)</span> 
	(а также команде Фокала <span class="icode"><span class="cmdf">X FCHR</span>(<span class="nmbr">1</span>)</span>). 
	Мы всегда можем выдать этот код как в диалоговом режиме, так и в программном. 
	Содержимое ячейки @#<span class="nmbr">374</span> проинвертируется, станет не 
	нулевым, и символы будут выводиться не только на экран, но и на принтер. А если 
	нам это не нужно - снова дадим тот же ключ, содержимое ячейки станет равным 
	нулю и печать прекратится. (Каждый может придумать такой порядок управления 
	печатью, какой ему больше нравится, и написать программу тоже по своему вкусу. 
	А автор приводить полную программу, как уже было сказано, не собирается, так 
	как считает, что в этом случае незачем было писать книгу - различных драйверов 
	сегодня тиражируется достаточно.)</p>
	<p>Вот теперь наш драйвер как будто полностью готов и можно с ним работать. 
	Каковы его слабые места? Первое - это то, что супервизорная программа может 
	быть &laquo;<i>затёрта</i>&raquo; данными или текстом программы пользователя 
	(ЭВМ тогда &laquo;<i>зависнет</i>&raquo;), поэтому о её присутствии в ОЗУ программист 
	всегда должен помнить. А второе - программа пользователя всё-таки может &laquo;<i>сбросить</i>&raquo; 
	супервизорный драйвер, отключить его, если она перепишет вектор @#<span class="nmbr">30</span> 
	напрямую, без всякого <span class="cmds">EMT</span> <span class="nmbr">14</span> 
	- тут уж ничего не поделаешь. К счастью, программ, изменяющих вектор @#<span class="nmbr">30</span>, 
	не так уж много.</p>
	<p>А как быть, если нам нужна графическая копия экрана? Нужно написать специальную 
	подпрограмму графического копирования. Мы могли бы её привести, но ведь почти 
	для каждого принтера она будет своя, отличная от других, да это и не входит 
	в нашу задачу. В общих чертах подпрограмма эта будет выглядеть так. Сначала 
	нужно перевести принтер в графический режим (в соответствии с его системой команд), 
	а затем выдавать на него и печатать по нескольку (в соответствии с его же графическим 
	форматом) точек экранного ОЗУ. Достигнув конца графической строки экрана, надо 
	перейти к следующей и т.д., а распечатав весь экран - выйти из подпрограммы. 
	Можно построить графическую печать и таким образом, чтобы копия экрана выводилась 
	как в &laquo;<i>нормальном</i>&raquo; положении, так и с поворотом на
	<span class="nmbr">90</span>° - каждый способ имеет свои преимущества. А обращаться 
	к данной подпрограмме можно из того же драйвера, только по иной команде-ключу, 
	например по коду <span class="nmbr">2</span>.</p>
	<p>Здесь есть ещё одна существенная деталь. Если вы хотите графически копировать 
	экран &laquo;<i>из любого исходного положения</i>&raquo;, то следует помнить, 
	что он в БК-0010 организован по типу рулона, и его начало в каждом конкретном 
	случае может быть с любого адреса. Определить адрес начала экрана нетрудно - 
	в этом может помочь, например, регистр @#<span class="nmbr">177664</span> или, 
	ещё лучше, ячейка @#<span class="nmbr">204</span>. Но если пытаться распечатывать 
	фрагмент ОЗУ с начала экрана и длиной <span class="nmbr">40000</span>, то мы 
	рано или поздно &laquo;<i>выскочим</i>&raquo; в область ПЗУ (если только адрес 
	начала рулона также не равен <span class="nmbr">40000</span>). Нужно своевременно 
	зафиксировать этот момент и скорректировать адрес, перейдя от конца ОЗУ экрана 
	к его началу. Похоже, это довольно сложная задача и придётся-таки привести пример 
	листинга. Программа будет рассчитана на довольно распространённый принтер типа 
	МС-<span class="nmbr">6312</span>, на его систему команд и на его формат графического 
	вывода. Копироваться экран будет в &laquo;<i>нормальном</i>&raquo; положении, 
	т.е. горизонтально на листе бумаги, а с целью увеличения размеров изображения 
	и компенсации искажений, возникающих при переходе от формата экрана к формату 
	принтера, высота по вертикали &laquo;<i>удваивается</i>&raquo; - на данном типе 
	принтера это даёт наиболее приемлемые результаты. Кроме того, такой вариант 
	программы можно считать самым сложным из всех возможных, и если вы разберётесь, 
	как работает эта подпрограмма, то сможете написать аналогичную и для другого 
	типа принтера. Понять же, как она работает, вам помогут предшествующие разъяснения 
	и построчные комментарии. Формат подпрограммы - перемещаемый, она сопровождается 
	двумя вспомогательными подпрограммами и двумя строками команд принтера. Система 
	команд МС-<span class="nmbr">6312</span> близка к EPSON-стандарту. Для тех, 
	кто не знаком с описанием этого принтера поясним коды команд:</p>
	<ul>
		<li>строка <span class="labl">К1</span> - <span class="nmbr">30</span>,<span class="nmbr">33</span>,<span class="nmbr">100</span>,<span class="nmbr">7</span>, 
		что означает:</li>
	</ul>
	<p><span class="nmbr">30</span> - отмена строки, т.е. сброс &laquo;<i>мусора</i>&raquo; 
	(CAN);</p>
	<p><span class="nmbr">33</span> - регистровый код (ESCAPE, ESC);</p>
	<p><span class="nmbr">100</span> - &laquo;@&raquo;, ESC-код инициализации принтера;</p>
	<p><span class="nmbr">7</span> - признак конца командной последовательности;</p>
	<ul>
		<li>строка <span class="labl">К2</span> - <span class="nmbr">33</span>,<span class="nmbr">63</span>,<span class="nmbr">30</span>,<span class="nmbr">12</span>,<span class="nmbr">33</span>,<span class="nmbr">113</span>,<span class="nmbr">0</span>,<span class="nmbr">2</span>,<span class="nmbr">7</span>:</li>
	</ul>
	<p><span class="nmbr">33</span> - ESC;</p>
	<p><span class="nmbr">63</span> - символ &laquo;<i>3</i>&raquo;, ESC-код выбора
	<span class="oprt">N</span>/<span class="nmbr">216</span><sub>д</sub>-дюймового 
	интервала между строками;</p>
	<p><span class="nmbr">30</span> - число <span class="oprt">N</span> в обозначении &laquo;<span class="oprt">N</span>/<span class="nmbr">216</span><sub>д</sub>- 
	дюймовый интервал&raquo;, т.е. устанавливается интервал <span class="nmbr">24</span><sub>д</sub>/<span class="nmbr">216</span><sub>д</sub>;</p>
	<p><span class="nmbr">12</span> - перевод строки (LF);</p>
	<p><span class="nmbr">33</span> - ESC;</p>
	<p><span class="nmbr">113</span> - символ &laquo;<i>K</i>&raquo; (лат), выбор 
	графического режима одинарной плотности;</p>
	<p><span class="nmbr">0</span>, <span class="nmbr">2</span> - количество точек 
	в графической строке режима &laquo;<i>K</i>&raquo;, что значит (<span class="nmbr">0</span> 
	+ <span class="nmbr">256</span><sub>д</sub> * <span class="nmbr">2</span>) =
	<span class="nmbr">512</span><sub>д</sub> точек, это формат экрана БК-0010,</p>
	<p><span class="nmbr">7</span> - признак конца командной последовательности.</p>
	<p>А теперь сама подпрограмма <a href="#_ftn4" name="_ftnref4" title="">
	<sup>[4]</sup></a>:</p>
	<pre><span class="cmmnt">; Подпрограмма графического копирования экрана</span>
<span class="labl">GRK</span>:    <span class="cmds">JSR</span>     <span class="regn">R4</span>,@#<span class="nmbr">110346</span>         <span class="cmmnt">; Сохранить</span>
        <span class="cmds">MOV</span>     <span class="regn">R5</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; регистры</span>
        <span class="cmds">CALL</span>    <span class="labl">КМ1</span>                 <span class="cmmnt">; Инициализация принтера</span>
        <span class="cmds">MOV</span>     @#<span class="nmbr">204</span>,<span class="regn">R1</span>            <span class="cmmnt">; Адрес</span>
        <span class="cmds">ADD</span>     #<span class="nmbr">36000</span>,<span class="regn">R1</span>           <span class="cmmnt">; начала экрана</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">100</span>,<span class="regn">R5</span>             <span class="cmmnt">; Цикл из 64д строк по 4 точки</span>
<span class="locl">0</span>:      <span class="cmds">CALL</span>    <span class="labl">КМ2</span>                 <span class="cmmnt">; Перевод строки на 24д/216д дюйма</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">100</span>,<span class="regn">R4</span>             <span class="cmmnt">; Цикл из 64д знакомест</span>
<span class="locl">1</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">10</span>,<span class="regn">R3</span>              <span class="cmmnt">; Цикл из 8 столбцов  точек</span>
<span class="locl">2</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">4</span>,<span class="regn">R2</span>               <span class="cmmnt">; Цикл из 4 вертикальных     точек</span>
        <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Очистить буфер граф.элемента</span>
<span class="locl">3</span>:      <span class="cmds">ASLB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; Сдвиг буфера</span>
        <span class="cmds">ASLB</span>    <span class="regn">R0</span>                  <span class="cmmnt">; на 2 точки</span>
        <span class="cmds">RORB</span>    @<span class="regn">R1</span>                 <span class="cmmnt">; Очередная точка = 0 ?</span>
        <span class="cmds">BCC</span>     <span class="locl">4</span>                   <span class="cmmnt">; Да - следующая точка</span>
        <span class="cmds">BISB</span>    #<span class="nmbr">3</span>,<span class="regn">R0</span>               <span class="cmmnt">; Иначе - 2 точки в буфер</span>
        <span class="cmds">BISB</span>    #<span class="nmbr">200</span>,@<span class="regn">R1</span>            <span class="cmmnt">; Восстановить точку на экране</span>
<span class="locl">4</span>:      <span class="cmds">ADD</span>     #<span class="nmbr">100</span>,<span class="regn">R1</span>             <span class="cmmnt">; Следующая точка по вертикали</span>
        <span class="cmds">BPL</span>     <span class="locl">5</span>                   <span class="cmmnt">; в пределах экрана ?</span>
        <span class="cmds">SUB</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>           <span class="cmmnt">; Нет - коррекция &quot;на рулон&quot;</span>
<span class="locl">5</span>:      <span class="cmds">SOB</span>     <span class="regn">R2</span>,<span class="locl">3</span>                <span class="cmmnt">; Цикл из 4 вертикальных точек</span>
        <span class="cmds">CALL</span>    <span class="labl">TYP</span>                 <span class="cmmnt">; Выдать графический элемент на печать</span>
        <span class="cmds">SUB</span>     #<span class="nmbr">400</span>,<span class="regn">R1</span>             <span class="cmmnt">; Адрес прежний - начало столбца</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>           <span class="cmmnt">; В пределах экрана ?</span>
        <span class="cmds">BLOS</span>    <span class="locl">6</span>                   <span class="cmmnt">; Да, иначе</span>
        <span class="cmds">ADD</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>           <span class="cmmnt">; коррекция</span>
<span class="locl">6</span>:      <span class="cmds">SOB</span>     <span class="regn">R3</span>,<span class="locl">2</span>                <span class="cmmnt">; Цикл из 8 столбцов точек</span>
        <span class="cmds">INC</span>     <span class="regn">R1</span>                  <span class="cmmnt">; Следующий байт</span>
        <span class="cmds">SOB</span>     <span class="regn">R4</span>,<span class="locl">1</span>                <span class="cmmnt">; Цикл из 64д знакомест (байт)</span>
        <span class="cmds">ADD</span>     #<span class="nmbr">300</span>,<span class="regn">R1</span>             <span class="cmmnt">; Следующая строка печати</span>
        <span class="cmds">BPL</span>     <span class="locl">7</span>                   <span class="cmmnt">; в пределах экрана ?</span>
        <span class="cmds">SUB</span>     #<span class="nmbr">40000</span>,<span class="regn">R1</span>           <span class="cmmnt">; Нет - коррекция</span>
<span class="locl">7</span>:      <span class="cmds">SOB</span>     <span class="regn">R5</span>,<span class="locl">0</span>                <span class="cmmnt">; Цикл строк</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">12</span>,<span class="regn">R0</span>              <span class="cmmnt">; Перевод</span>
        <span class="cmds">CALL</span>    <span class="labl">TYP</span>                 <span class="cmmnt">; строки</span>
        <span class="cmds">CALL</span>    <span class="labl">КМ1</span>                 <span class="cmmnt">; Инициализация принтера</span>
        <span class="cmds">MOV</span>     (<span class="regn">SP</span>)+,<span class="regn">R5</span>            <span class="cmmnt">; Восстановить</span>
        <span class="cmds">JSR</span>     <span class="regn">R4</span>,@#<span class="nmbr">110362</span>         <span class="cmmnt">; регистры</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span>
 
<span class="cmmnt">; Подпрограмма выдачи кодов на принтер</span>
<span class="labl">TYP</span>:    <span class="cmds">JSR</span>     <span class="regn">R4</span>,@#<span class="nmbr">110346</span>         <span class="cmmnt">; Сохранить регистры</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">177714</span>,<span class="regn">R1</span>          <span class="cmmnt">; Адрес порта</span>
        <span class="cmds">BIC</span>     #<span class="nmbr">177400</span>,<span class="regn">R0</span>          <span class="cmmnt">; Выделить младший байт</span>
<span class="locl">1</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">400</span>,@<span class="regn">R1</span>            <span class="cmmnt">; Принтер готов?</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; Нет - ждать</span>
        <span class="cmds">CLR</span>     @<span class="regn">R1</span>                 <span class="cmmnt">; Очистка порта</span>
        <span class="cmds">BIS</span>     #<span class="nmbr">400</span>,<span class="regn">R0</span>             <span class="cmmnt">; Строб - бит</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@<span class="regn">R1</span>              <span class="cmmnt">; Код и строб в порт</span>
<span class="locl">2</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">400</span>,@<span class="regn">R1</span>            <span class="cmmnt">; Код принят?</span>
        <span class="cmds">BNE</span>     <span class="locl">2</span>                   <span class="cmmnt">; Нет - ждать</span>
        <span class="cmds">JSR</span>     <span class="regn">R4</span>,@#<span class="nmbr">110362</span>         <span class="cmmnt">; Восстановить регистры</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span>
 
<span class="cmmnt">; Подпрограмма выдачи команд на принтер</span>
<span class="labl">КМ1</span>:    <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R3</span>               <span class="cmmnt">; Команды: &quot;сброс&quot;,</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R3</span>            <span class="cmmnt">; &quot;инициализация&quot;</span>
        <span class="pscm">.@</span><span class="labl">К1</span>+<span class="nmbr">2</span>
        <span class="cmds">BR</span>      <span class="labl">КОМ</span>                 <span class="cmmnt">; Исполнение</span>
<span class="labl">КМ2</span>:    <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R3</span>               <span class="cmmnt">; Команды: &quot;графика&quot;, &quot;перевод</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R3</span>            <span class="cmmnt">; строки на 24д/216д дюйма&quot;</span>
        <span class="pscm">.@</span><span class="labl">К2</span>+<span class="nmbr">2</span>
<span class="labl">КОМ</span>:    <span class="cmds">MOVB</span>    (<span class="regn">R3</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; Очередной код команды</span>
        <span class="cmds">CMPB</span>    #<span class="nmbr">7</span>,<span class="regn">R0</span>               <span class="cmmnt">; Если 7 -</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; конец</span>
        <span class="cmds">CALL</span>    <span class="labl">TYP</span>                 <span class="cmmnt">; Передать код на принтер</span>
        <span class="cmds">BR</span>      <span class="labl">КОМ</span>                 <span class="cmmnt">; Следующий код</span>
<span class="locl">1</span>:      <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span>
 
<span class="cmmnt">; Командные коды принтера:</span>
<span class="cmmnt">; сброс строки, инициализация принтера</span>
<span class="labl">К1</span>:     <span class="pscm">.B</span>:<span class="nmbr">30</span>,<span class="nmbr">33</span>,<span class="nmbr">100</span>,<span class="nmbr">7</span>
<span class="cmmnt">; перевод строки на 24д</span>/<span class="cmmnt">216д дюйма, задание граф.режима</span>
<span class="labl">К2</span>:     <span class="pscm">.B</span>:<span class="nmbr">33</span>,<span class="nmbr">63</span>,<span class="nmbr">30</span>,<span class="nmbr">12</span>,<span class="nmbr">33</span>,<span class="nmbr">113</span>,<span class="nmbr">0</span>,<span class="nmbr">2</span>,<span class="nmbr">7</span><span class="pscm">.E</span></pre>
	<p>Вот теперь, чтобы получить копию экрана, вам уже не понадобится фотоаппарат...</p>
	<p class="centr">★ ★ ★</p>
	<p>А что ещё можно сделать с помощью вектора @#<span class="nmbr">30</span>? 
	Допустим, вы изобрели свой формат записи на МЛ, который даёт, например, в
	<span class="nmbr">4</span> раза более высокую плотность записи и в
	<span class="nmbr">3</span> раза более высокую надёжность чтения (заметим, что 
	такой формат на БК-0010 уже есть<a href="#_ftn5" name="_ftnref5" title=""><sup>[5]</sup></a>). 
	Этого ещё мало для успеха! Что можно сделать с помощью спецкопировщика? Только 
	организовать надёжный и компактный архив. Вы не сможете загружать в таком формате 
	ни тексты для редакторов, ни программы на Бейсике и Фокале - придётся каждый 
	раз вначале &laquo;<i>распаковывать</i>&raquo; файлы, т.е. перезаписывать их 
	в стандартном формате БК-0010. Есть ли выход? Да, это опять супервизорный драйвер. 
	Пусть он перехватывает прерывание по вектору @#<span class="nmbr">30</span>, 
	но на этот раз выделяет <span class="cmds">EMT</span> <span class="nmbr">36</span>. 
	Затем надо обратиться к блоку параметров <span class="cmds">EMT</span>
	<span class="nmbr">36</span> и проанализировать его в зависимости от результатов 
	анализа выполняется чтение или запись, но только с помощью не стандартного драйвера 
	магнитофона БК, а своего спецдрайвера. Ведь в блоке параметров для
	<span class="cmds">EMT</span> <span class="nmbr">36</span> мы найдём всё: и 
	команду (запись или чтение), и адрес, и длину файла... А после выполнения заданной 
	операции с требуемым файлом нужно установить все системные ячейки ЭВМ, стек 
	и регистры в такое состояние, как будто &laquo;<i>сработала</i>&raquo; стандартная 
	команда <span class="cmds">EMT</span> <span class="nmbr">36</span>. Кажется, 
	эта фраза нам уже встречалась? Ну да, это же эмуляция, но на этот раз не
	<span class="cmds">EMT</span> <span class="nmbr">20</span>, а
	<span class="cmds">EMT</span> <span class="nmbr">36</span>. Конечно, эта задача 
	гораздо сложнее, но и цель ведь куда серьёзнее. Если удастся реализовать такой 
	системный драйвер, то он будет работать со всеми, без исключения, программами 
	пользователя на любых языках и в любых режимах, осуществляя обмен с магнитофоном 
	в спецформате, если только программа пользователя выходит на обмен по стандартному 
	прерыванию <span class="cmds">EMT</span> <span class="nmbr">36</span>. Автору 
	это удалось, и теперь он работает с магнитофоном на скорости
	<span class="nmbr">4000</span> бод вместо стандартных <span class="nmbr">1200</span> 
	(поясним, что бод - это единица скорости обмена информацией, соответствующая 
	одному бит/с).</p>
	<p>Точно так же можно организовать обмен с дисководом (без всякой операционной 
	системы), с квазидиском на базе дополнительного ОЗУ (которое на БК может в принципе 
	иметь объём порядка <span class="nmbr">2</span>-<span class="nmbr">4</span> 
	Мб) и даже с принтером - при этом на принтер будут выдаваться для печати те 
	самые блоки информации, которые мы хотели бы записать на МЛ. Правда, для принтера 
	мы уже знаем более удобный способ. Важно то, что для такого обмена не потребуется 
	опять-таки никакого вмешательства в программу пользователя, лишь бы она была 
	рассчитана на работу с магнитофоном<a href="#_ftn6" name="_ftnref6" title=""><sup>[6]</sup></a>.</p>
	<p>А другие <span class="cmds">EMT</span>? К примеру, вам не нравится алгоритм 
	векторной графики БК-0010 (он, и правда, не самый лучший, прежде всего слишком 
	медленный). Отлично, напишем свою программу, но не станем просить завод, чтобы 
	он выпустил новое ПЗУ, а просто перехватим <span class="cmds">EMT</span>
	<span class="nmbr">32</span> и заменим векторную графику БК на свою.</p>
	<p>Хотите заменить знакогенератор? Нет проблем. Всё то же <span class="cmds">
	EMT</span> <span class="nmbr">16</span> (и эмулированное <span class="cmds">
	EMT</span> 20) позволят решить задачу. Надо только выделять часть символов, 
	которые мы хотим заменять (это могут быть, например, латинские символы или псевдографика), 
	перехватывать их коды и, вместо того чтобы вывод этих символов &laquo;<i>отдать 
	на откуп</i>&raquo; <span class="cmds">EMT</span> <span class="nmbr">16</span>, 
	рисовать их на экране самостоятельно, пользуясь своими масками начертания. Конечно, 
	для этого надо хорошо знать, как это делает драйвер дисплея БК-0010, но это 
	уже дело вашей настойчивости и упорства. Подскажем лишь, что тут &laquo;<i>замешаны</i>&raquo; 
	две подпрограммы по адресам @#<span class="nmbr">102764</span> и @#<span class="nmbr">103222</span>. 
	С их помощью, указав в регистре <span class="regn">R1</span> адрес начала строки 
	маски, можно вывести на экран символ независимо от того, находится его маска 
	в ОЗУ или в ПЗУ, стандартная она или &laquo;<i>самодельная</i>&raquo;.</p>
	<p>А прерывание <span class="cmds">TRAP</span>? Например, в языках высокого 
	уровня по &laquo;<i>трапам</i>&raquo; выполняются многие процедуры. Почему бы 
	их не &laquo;<i>поймать</i>&raquo;, как мы это делали с <span class="cmds">EMT</span>, 
	и не извлечь из этого пользу? Например, ввести свои дополнительные процедуры 
	или изменить алгоритмы имеющихся. Конечно, для этого надо знать структуру интерпретатора 
	языка (например, Фокала) так, как будто это вы его придумали...</p>
	<p>А прерывания от клавиатуры? Векторы @#<span class="nmbr">60</span> и @#<span class="nmbr">274</span> 
	не изменяются почти ни в каких программах пользователя. Этим можно воспользоваться 
	и ввести по ним дополнительные директивы почти в любую программу. Удобнее всего 
	использовать коды в регистре &laquo;<i>АР2</i>&raquo; для клавиш &laquo;<i>РУС</i>&raquo;, &laquo;<i>ЛАТ</i>&raquo; 
	и &laquo;<i>ВВОД</i>&raquo; - эти коды не обрабатываются практически никакими 
	программами и их можно применять для своих целей без помех. Например, нажатием 
	клавиши &laquo;<i>АР2</i>&raquo;/&laquo;<i>ЛАТ</i>&raquo; можно вызвать ту же 
	подпрограмму графического копирования экрана. Покажем, как это можно сделать, 
	на примере:</p>
	<pre><span class="cmmnt">; Инициализация драйвера</span>
        <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R0</span>               <span class="cmmnt">; Вычислить адрес</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; супервизора</span>
        <span class="pscm">.@</span><span class="labl">SQN</span>+<span class="nmbr">2</span>                     <span class="cmmnt">; в перемещаемом формате</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@#<span class="nmbr">274</span>            <span class="cmmnt">; Записать новый вектор @#274</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; Стоп</span>
<span class="cmmnt">; Супервизорная программа - обработка прерывания по &quot;АР2&quot;</span>
<span class="labl">SQN</span>:    <span class="cmds">CMPB</span>    #<span class="nmbr">17</span>,@#<span class="nmbr">177662</span>        <span class="cmmnt">; Клавиша &quot;ЛАТ&quot; по регистру &quot;АР2&quot;? –</span>
        <span class="cmds">BNE</span>     <span class="nmbr">0</span>                   <span class="cmmnt">; Нет - выход</span>
        <span class="cmds">CALL</span>    <span class="labl">GRK</span>                 <span class="cmmnt">; Графическая копия экрана</span>
<span class="locl">0</span>:      <span class="cmds">JMP</span>     @#<span class="nmbr">101362</span>            <span class="cmmnt">; Передача управления в драйвер</span>
                                    <span class="cmmnt">; клавиатуры БК-0010</span></pre>
	<p>После всех предшествующих примеров можно было бы лишний раз и не повторять, 
	что эту программу можно также использовать в составе общего универсального драйвера 
	принтера, что её тоже надо защитить от <span class="cmds">EMT</span>
	<span class="nmbr">14</span>, и т.д.</p>
	<p>Ясно, что тем же путём можно ввести дополнительные директивы в любую программу 
	пользователя, например, не выходя из редактора <i>МИКРО.<span class="nmbr">10</span>К</i>, 
	вызвать программу печати &laquo;<i>от метки до курсора</i>&raquo;, надо лишь 
	знать, что в <i>МИКРО</i> адрес метки хранится в ячейке @#<span class="nmbr">426</span>, 
	а адрес курсора - в ячейке @#<span class="nmbr">432</span>. Удобно, не правда 
	ли? И программа получится очень простой, всего в несколько десятков команд.</p>
	<p>Итак, теперь вы знаете, что такое системные драйверы. А почему автор назвал 
	это &laquo;<i>концепцией</i>&raquo;? Потому что, как было сказано в начале раздела, 
	есть два пути - либо приспосабливать <b>каждую</b> программу пользователя для 
	данной цели, например для печати на конкретном принтере, либо сделать это сразу
	<b>для всех</b> программ, написав резидентный драйвер. Это именно <b>концепция</b>, 
	или, как сказано в словаре иностранных слов, &laquo;<i>система взглядов на те 
	или иные явления</i>&raquo;. До сего дня мало кто из программирующих на БК решает 
	указанные проблемы с системных позиций, вследствие чего и множится необоснованно 
	число версий редакторов и языков, например варианты <i>EDASP</i> для печати 
	на &laquo;<i>Роботроне</i>&raquo;, на <i>МС-<span class="nmbr">6312</span></i>, 
	на <i>МС-<span class="nmbr">6313</span></i>, на телетайпе... И всё это - самостоятельные 
	программы, а что в них &laquo;<i>самостоятельного</i>&raquo;? Только драйвер 
	принтера. И ради его изменения нужно &laquo;<i>перепахать</i>&raquo; такую сложную 
	программу, как <i>EDASP</i>. Стоит ли?</p>
	<h3><a name="toc_45"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Предложите способ, который позволит всю информацию, выводимую любой 
		программой на экран, записать в виде файла на МЛ. Какое значение может иметь 
		такой способ, например, для работы с Фокалом? С дизассемблером?
		<ul id="ctrla">
			<li>
			<p>Нужно написать системный драйвер, аналогичный драйверу принтера для 
			печати текста. Но вместо вывода символов на принтер надо выделить свободную 
			область памяти, куда записывать последовательно коды появляющихся на 
			экране символов. Количество байтов получившегося массива надо подсчитывать. 
			Окончание формирования массива может быть по достижении им заданной 
			длины или по специальной директиве, после чего с помощью
			<span class="cmds">EMT</span> <span class="nmbr">36</span>, зная адрес 
			и длину массива, надо записать его на МЛ в виде файла. При работе с 
			Фокалом такой приём даёт возможность, например, записать листинг Фокал-программы 
			на МЛ, а затем загрузить его в редактор текста. Это пригодится, если 
			нужно обработать описание или учебную программу, написанные на Фокале, 
			включить Фокал-программу в текст, написанный с учебными целями, и т.п. 
			При работе с дизассемблером это позволит дизассемблированный текст программы 
			в кодах прокомментировать в редакторе, а отредактировав его и приведя 
			к формату, например, <i>МИКРО.<span class="nmbr">10</span>К</i>, даже 
			оттранслировать в ассемблер-системе или включить в качестве блока в 
			свою программу<a href="#_ftn7" name="_ftnref7" title=""><sup>[7]</sup></a>.</p>
			</li>
		</ul>
		</li>
		<li>Напишите блок для &laquo;<i>повторного</i>&raquo;, без разрушения памяти, 
		выхода из МСД в Фокал, пользуясь указаниями о порядке такого выхода, приведёнными 
		в конце раздела о директивах МСД. Предусмотрите защиту блока выхода в Фокале.
		<ul id="ctrla">
			<li>
			<p>Для выхода из МСД в Фокал надо проделать следующее.</p>
			<pre><span class="var">Щ</span><span class="nmbr">120020</span><span class="var">А</span><span class="nmbr">26</span><span class="var">Д</span><span class="nmbr">0</span><span class="var">П</span><span class="nmbr">262</span><span class="var">А</span><span class="nmbr">177777</span><span class="var">И</span> «<i>СТОП</i>»</pre>
			<p>Реализуем это в виде программного блока:</p>
			<pre><span class="labl">BEG</span>:    <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Адрес пересылки информации</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">120020</span>,<span class="regn">R1</span>          <span class="cmmnt">; Адрес информации в ПЗУ-Фокал</span>
<span class="locl">1</span>:      <span class="cmds">MOV</span>     (<span class="regn">R1</span>)+,(<span class="regn">R0</span>)+         <span class="cmmnt">; Пересылка блока</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">120046</span>,<span class="regn">R1</span>          <span class="cmmnt">; информации длиной 26</span>
        <span class="cmds">BGE</span>     <span class="nmbr">1</span>                   <span class="cmmnt">; в системную область</span>
        <span class="cmds">MOV</span>     #-<span class="nmbr">1</span>,@#<span class="nmbr">262</span>           <span class="cmmnt">; Запись признака кода &quot;ВВОД&quot;</span>
        <span class="cmds">MOV</span>     <span class="regn">PC</span>,<span class="regn">R0</span>               <span class="cmmnt">; Вычисление адреса</span>
        <span class="cmds">ADD</span>     (<span class="regn">PC</span>)+,<span class="regn">R0</span>            <span class="cmmnt">; начала блока в,</span>
        .@<span class="labl">BEG</span>+<span class="nmbr">2</span>                     <span class="cmmnt">; перемещаемом формате</span>
        <span class="cmds">MOV</span>     <span class="regn">R0</span>,@#<span class="nmbr">1744</span>           <span class="cmmnt">; Ограничить доступную Фокалу</span>
                                    <span class="cmmnt">; область памяти началом </span>
                                    <span class="cmmnt">; блока выхода в Фокал</span>
        <span class="cmds">HALT</span>                        <span class="cmmnt">; &quot;СТОП&quot; - выход в Фокал</span></pre>
			<p>Конечно, реализовать эту программу можно и по-другому, это только 
			один из возможных вариантов.</p>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_46"></a>Системная область БК-0010</h2>
	<p>Мы уже неоднократно упоминали этот термин - системная область. Пора, наконец, 
	рассказать подробно, что это такое. Для БК-0010 системной областью называется 
	область адресов от <span class="nmbr">0</span> до <span class="nmbr">777</span>. 
	В ней помимо уже известных нам векторов прерывания размещаются <b>системные 
	переменные</b> и <b>стек</b>. Стек - это область памяти, обычно адресуемая косвенно 
	через регистр <span class="regn">SP</span>, и подробно мы её рассмотрим позже 
	(в приводимых ранее примерах мы её уже использовали). А системные переменные 
	- это специально выделенные ячейки памяти, используемые в качестве буфера для 
	работы драйверов монитора БК-0010. В них запоминаются различные промежуточные 
	данные, признаки режимов ЭВМ и т.п. Часть ячеек свободна и может быть задействована 
	программистом для своих нужд. Однако при выборе таких ячеек надо иметь в виду, 
	что некоторые из них могут использоваться в языках высокого уровня или некоторыми 
	распространёнными программами, в частности ассемблер-системой.</p>
	<p>Приведём сведения о всех ячейках системной области в порядке возрастания 
	их номеров, включая как уже известные нам, так и те, с которыми мы пока не встречались. 
	Для всех ячеек будут даны сведения о хранимой там информации, по возможности 
	с пояснениями, что это такое и как эти ячейки используются системой БК-0010 
	или ЦП. Если информацию, хранящуюся в ячейках, можно как-либо применять в своих 
	программах, постараемся обратить внимание и на это. Для каждой ячейки будет 
	приводиться её адрес. Если используется машинное слово или несколько слов, будет 
	приведён только адрес (адреса) ячеек.</p>
	<p>Если же задействован отдельный байт, это будет оговариваться особо.</p>
	<p>У читателя может возникнуть вопрос, откуда автор получил сведения о системных 
	ячейках. Во-первых, был использован авторский текст драйверного модуля БК-0010 
	(листинг DMBK, автор - <em>М.И. Дябин</em>, Москва, <span class="nmbr">1983</span>-<span class="nmbr">1985</span> 
	гг.). Во-вторых, производилось дизассемблирование содержимого ПЗУ БК-0010. И 
	наконец, со многими ячейками автор проводил эксперименты для определения их 
	функционального назначения и возможного использования.</p>
	<p class="centr">★ ★ ★</p>
	<ul>
		<li><span class="nmbr">0</span>, <span class="nmbr">2</span> - не используется. 
		В эти и некоторые другие неиспользуемые ячейки при включении ЭВМ заносится 
		адрес перезапуска системы - <span class="nmbr">100000</span>. При случайном 
		косвенном обращении по адресу такой ячейки произойдёт инициализация системы.</li>
		<li><span class="nmbr">4</span>, <span class="nmbr">6</span> - вектор прерывания 
		по клавише &laquo;<i>СТОП</i>&raquo; и команде останова
		<span class="cmds">HALT</span>. Прерывание по клавише &laquo;<i>СТОП</i>&raquo; 
		внеприоритетное. Значение первого слова вектора в ПМ -
		<span class="nmbr">100442</span>, в МСД - <span class="nmbr">160722</span>, 
		в Фокале - <span class="nmbr">121110</span>. в Бейсике -
		<span class="nmbr">120234</span> (если это значение не изменено программой 
		пользователя).</li>
		<li><span class="nmbr">10</span>, <span class="nmbr">12</span> - вектор 
		прерывания по резервному коду. ЦП выполняет данное прерывание при получении 
		кода, отсутствующего в его наборе команд.</li>
		<li><span class="nmbr">14</span>, <span class="nmbr">16</span> - вектор 
		прерывания по <span class="symb">T</span>-разряду (при работе в пошаговом 
		режиме).</li>
		<li><span class="nmbr">20</span>, <span class="nmbr">22</span> - вектор 
		прерывания по команде <span class="cmds">IOT</span>.</li>
		<li><span class="nmbr">24</span>, <span class="nmbr">26</span> - вектор 
		прерывания по аварии сетевого питания ЭВМ (по входу ACLO ЦП). Это прерывание 
		внеприоритетное.</li>
		<li><span class="nmbr">30</span>, <span class="nmbr">32</span> - вектор 
		прерывания по команде <span class="cmds">EMT</span>.</li>
		<li><span class="nmbr">34</span>, <span class="nmbr">36</span> - вектор 
		прерывания по команде <span class="cmds">TRAP</span>.</li>
		<li><span class="nmbr">40</span>-<span class="nmbr">56</span> - ячейки (байты) 
		слова состояния дисплея. Они уже были описаны в разделе, посвящённом
		<span class="cmds">EMT</span> <span class="nmbr">34</span>, там же приведена 
		таблица их значений. Напомним, что исходное содержимое всех этих ячеек (при 
		перезапуске ЭВМ) равно нулю, а при включении соответствующего режима дисплея 
		становится равным <span class="nmbr">377</span>, за исключением ячейки
		<span class="nmbr">43</span> - индикатора регистра &laquo;<i>РУС</i>&raquo;, 
		куда заносится число <span class="nmbr">200</span> (маска регистра &laquo;<i>РУС</i>&raquo;). 
		Ячейки могут быть использованы прежде всего для определения включённых в 
		данный момент режимов с целью их изменения и для приведения изображения 
		на экране к желаемому виду и формату. Запись числа <span class="nmbr">377</span> 
		в некоторые из ячеек (<span class="nmbr">44</span>-<span class="nmbr">47</span>,
		<span class="nmbr">54</span>-<span class="nmbr">56</span>) приводит к прямому 
		включению данного режима, иногда - с некоторыми нюансами по сравнению с 
		включением режима подачей кода через <span class="cmds">EMT</span>
		<span class="nmbr">16</span>. Например, при включении таким образом режима &laquo;<i>БЛОКРЕД</i>&raquo; 
		и &laquo;<i>ИНДСУ</i>&raquo; отсутствует индикация в служебной строке; при 
		записи числа <span class="nmbr">377</span> в ячейку <span class="nmbr">56</span> 
		курсор со следующего выводимого символа исчезает, но остаётся его &laquo;<i>призрак</i>&raquo; 
		на экране и т.п. Тем не менее эти ячейки могут в некоторых случаях очень 
		успешно использоваться для переключения режимов, особенно когда это переключение 
		должно выполняться с очень высокой скоростью, на несколько порядков быстрее, 
		чем по <span class="cmds">EMT</span> <span class="nmbr">16</span>. Записав 
		в такие ячейки число, отличное от <span class="nmbr">0</span> и
		<span class="nmbr">377</span>, можно сделать режим &laquo;<i>неотменяемым</i>&raquo; 
		с клавиатуры - никакие нажатия клавиш БК не позволят снять его.</li>
	</ul>
	<p>Другие ячейки (<span class="nmbr">40</span>-<span class="nmbr">43</span>,
	<span class="nmbr">50</span>-<span class="nmbr">53</span>) при записи в них 
	какого-либо числа включают режим частично и &laquo;<i>ненормально</i>&raquo; 
	- дальнейшая работа с дисплеем становится невозможной или затруднительной. Но 
	и эти ячейки могут быть использованы для каких-либо целей. Например, регистр &laquo;<i>РУС</i>&raquo;-&laquo;<i>ЛАТ</i>&raquo; 
	можно переключать через ячейку <span class="nmbr">43</span>. но при этом поменяется 
	на обратную и установка регистра &laquo;<i>СТР</i>&raquo;-&laquo;<i>ЗАГЛ</i>&raquo;. 
	Ячейка <span class="nmbr">41</span> проявляет себя только в отдельных случаях, 
	например после переключения цветов. Ячейка <span class="nmbr">40</span> блокирует 
	выведение на экран каждого второго символа (выводятся широкие символы), а ячейка
	<span class="nmbr">42</span> по достижении края экрана блокирует рулонный сдвиг 
	и как бы организует режим &laquo;<i>РП</i>&raquo; на обычном экране. Ячейки 
	графических режимов <span class="nmbr">50</span>-<span class="nmbr">52</span> 
	хотя и переключают дисплей в режим текстовой графики, но при этом на экране 
	остаётся тень символьного и графического курсоров, резко замедляется отработка 
	команд текстовой графики и т.п.</p>
	<ul>
		<li><span class="nmbr">57</span> (байт) - не используется.</li>
		<li><span class="nmbr">60</span>,&nbsp; <span class="nmbr">62</span> - вектор 
		прерывания от клавиатуры<a href="#_ftn8" name="_ftnref8" title=""><sup>[8]</sup></a> 
		(кроме регистра &laquo;<i>АР2</i>&raquo;, или &laquo;<i>НР</i>&raquo; на 
		старой модели БК-0010 с плёночной клавиатурой). Приоритет данного прерывания 
		- <span class="nmbr">4</span>.</li>
		<li><span class="nmbr">64</span>-<span class="nmbr">76</span> - не используются.</li>
		<li><span class="nmbr">100</span>, <span class="nmbr">102</span> - вектор 
		прерывания от внешнего таймера. Вход данного прерывания выведен на контакт 
		В1 разъёма порта &laquo;<i>УП</i>&raquo; БК-0010. Приоритет прерывания -
		<span class="nmbr">4</span>.</li>
		<li><span class="nmbr">104</span> (байт) - код последнего введённого с клавиатуры 
		символа. Код заносится в ячейку, если разрешено прерывание от клавиатуры 
		(в отличие от регистра <span class="nmbr">177662</span>, где код появляется 
		после нажатия клавиши независимо от того, разрешено ли прерывание). Ячейка 
		широко используется в различных программах для организации режима &laquo;<i>автоповтор</i>&raquo; 
		- многократного выведения символа на экран при удержании клавиши нажатой. 
		Код символа в данной ячейке, в отличие от регистра <span class="nmbr">177662</span>, 
		- уже &laquo;<i>обработанный</i>&raquo;, т.е. соответствующий регистру клавиатуры 
		(&laquo;<i>РУС</i>&raquo;, &laquo;<i>ЛАТ</i>&raquo;, &laquo;<i>СТР</i>&raquo;, &laquo;ЗАГЛ&raquo;),</li>
		<li><span class="nmbr">105</span> (байт) - признак записи кода в ячейку
		<span class="nmbr">104</span><a href="#_ftn9" name="_ftnref9" title=""><sup>[9]</sup></a> 
		Используется командой <span class="cmds">EMT</span> <span class="nmbr">6</span>.</li>
		<li><span class="nmbr">106</span> - буфер константы повтора (количество 
		повторов &laquo;<i>пустого</i>&raquo; цикла <span class="cmds">SOB</span> 
		при нажатии клавиши &laquo;<i>ПОВТ</i>&raquo; перед выводом каждого следующего 
		символа). В символьном режиме число в ячейке <span class="nmbr">106</span> 
		равно <span class="nmbr">20000</span>, в графическом -
		<span class="nmbr">2000</span>, благодаря чему работа клавиши &laquo;<i>ПОВТ</i>&raquo; 
		замедляется до приемлемого уровня. Перезадав содержимое ячейки
		<span class="nmbr">106</span>, можно изменить скорость работы в режиме &laquo;<i>повтор</i>&raquo; 
		(минимальной скорости соответствует число <span class="nmbr">0</span><a href="#_ftn10" name="_ftnref10" title=""><sup>[10]</sup></a>. 
		максимальной - <span class="nmbr">1</span>).</li>
		<li><span class="nmbr">110</span> (байт) - признак повтора кода. Если значение 
		в ячейке <span class="nmbr">110</span> не равно нулю, то код последнего 
		введённого символа выводится повторно, после чего ячейка сбрасывается.</li>
		<li><span class="nmbr">111</span> (байт) - счётчик табуляции. В соответствии 
		с содержимым ячейки устанавливается количество пробелов, выводимых на экран. 
		Используется для отработки табуляции по клавише &laquo;<i>ТАБ</i>&raquo;.</li>
		<li><span class="nmbr">112</span>-<span class="nmbr">120</span> - позиционный 
		код маски табуляции. В соответствии с содержимым этих четырёх слов (<span class="nmbr">64</span><sub>д</sub> 
		бита) устанавливаются метки табуляции в служебной строке и выполняется табуляция 
		по клавише &laquo;<i>ТАБ</i>&raquo;. Установленной метке табуляции соответствует 
		единичный бит, сброшенной - нулевой. Это можно использовать для &laquo;<i>принудительного</i>&raquo; 
		(программного) задания позиций табуляции, для чего достаточно занести в 
		данные ячейки соответствующую маску. Для того чтобы метки табуляции индицировались 
		в служебной строке, её после записи маски в ячейки <span class="nmbr">112</span>-<span class="nmbr">120</span> 
		необходимо &laquo;<i>обновить</i>&raquo;, дав команду &laquo;<i>установка 
		индекса</i>&raquo; (код <span class="nmbr">236</span>).</li>
		<li><span class="nmbr">122</span> (байт) - счётчик ключа. Количество символов, 
		выводимое на экран при обращении к программируемому &laquo;<i>ключу</i>&raquo; 
		клавиатуры (клавиши &laquo;<i>0</i>&raquo;...&laquo;<i>9</i>&raquo; по регистру &laquo;<i>АР2</i>&raquo;). 
		В эту ячейку заносится длина текста текущего ключа.</li>
		<li><span class="nmbr">123</span> (байт) - не используется.</li>
		<li><span class="nmbr">124</span> - адрес очередного 
		байта текста текущего &laquo;<i>ключа</i>&raquo;.</li>
		<li><span class="nmbr">126</span>-<span class="nmbr">150</span> - адреса 
		(по порядку) начала текстов программируемых &laquo;<i>ключей</i>&raquo;, 
		соответствующих клавишам &laquo;<i>0</i>&raquo;, &laquo;<i>1</i>&raquo;,...&laquo;<i>9</i>&raquo;.</li>
		<li><span class="nmbr">152</span> (байт) - признак нарушения рулона. Используется 
		для организации рулонного сдвига экрана вверх и вниз.</li>
		<li><span class="nmbr">153</span> (байт) - признак записи точки. Используется 
		в программах командных прерываний <span class="cmds">EMT</span>
		<span class="nmbr">30</span> и <span class="cmds">EMT</span>
		<span class="nmbr">32</span>.</li>
		<li><span class="nmbr">154</span> (байт) - маска позиции графической точки 
		(ГТ). Чтобы адресовать ГТ на экране в режиме текстовой графики, ёмкость 
		машинного слова недостаточна, требуется ещё как минимум три бита. Данная 
		ячейка и является дополнением к машинному слову - адресу ГТ. Маска ГТ устанавливает 
		положение графической точки в пределах выбранного байта экранного ОЗУ и 
		может принимать значения <span class="nmbr">1</span>, <span class="nmbr">
		2</span>, <span class="nmbr">4</span>, <span class="nmbr">10</span>,
		<span class="nmbr">20</span>, <span class="nmbr">40</span>,
		<span class="nmbr">100</span>, <span class="nmbr">200</span> (для черно-белого 
		режима <span class="nmbr">512</span> точек) - единичный бит маски соответствует 
		положению ГТ в пределах байта. В цветном режиме маска состоит не из одного, 
		а из пары битов: <span class="nmbr">3</span>, <span class="nmbr">14</span>,
		<span class="nmbr">60</span>, <span class="nmbr">300</span>. Положение пары 
		единичных битов кратно двум, т.е. в качестве маски используются попарно 
		биты <span class="nmbr">00</span> и <span class="nmbr">01</span>,
		<span class="nmbr">02</span> и <span class="nmbr">03</span> и т.д.</li>
		<li><span class="nmbr">155</span> (байт) - начальная маска ГТ. Используется 
		для задания начального значения маски в ячейке <span class="nmbr">154</span>, 
		которое может быть равно <span class="nmbr">1</span> или
		<span class="nmbr">3</span>, в зависимости от режима (чёрно-белого или цветного).</li>
		<li><span class="nmbr">156</span> - номер символа на экране. Номер первого 
		символа (в верхнем левом углу) равен <span class="nmbr">0</span>, последнего 
		(в правом нижнем) - <span class="nmbr">2777</span> (для режима &laquo;<i>64 
		символа в строке</i>&raquo;). Нумерация позиций символов от сдвига рулона 
		не зависит и всегда одинакова. Последний символ любой строки имеет номер, 
		оканчивающийся на <span class="nmbr">77</span>, первый - на
		<span class="nmbr">00</span>. При переходе номера через нуль в двух младших 
		разрядах драйвер дисплея организует перевод строки на экране. Проиллюстрировать 
		эту функцию ячейки можно следующими программами:</li>
	</ul>
	<pre><span class="locl">0</span>:      <span class="cmds">CLR</span>     @#<span class="nmbr">156</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>

<span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">77</span>,@#<span class="nmbr">156</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>
        <span class="cmds">BR</span>      <span class="locl">0</span></pre>
	<p>Функция перевода строк на экране нарушается: при работе первой программы 
	курсор возвращается к левому краю экрана, но всего на одну телевизионную строку 
	экрана ниже, а при работе второй символ вообще печатается только на одном месте 
	в начале строки.</p>
	<p>В цветном режиме содержимое ячейки <span class="nmbr">156</span> кратно двум. 
	Его можно использовать в различных программах, например, для индикации достижения 
	текстом края экрана и организации автоматического перевода строки на принтере<a href="#_ftn11" name="_ftnref11" title=""><sup>[11]</sup></a>.</p>
	<ul>
		<li><span class="nmbr">160</span> - адрес текущего символа. В этой ячейке 
		всегда присутствует абсолютный (с учётом рулонного сдвига) адрес верхнего 
		левого байта формируемого символьного курсора. Если записать в эту ячейку 
		другое значение, то последующие символы, выводимые по <span class="cmds">
		EMT</span> <span class="nmbr">16</span> или по <span class="cmds">EMT</span>
		<span class="nmbr">20</span>, будут формировать строку начиная с этого адреса. 
		Строка прервётся, когда содержимое ячейки <span class="nmbr">156</span> 
		в двух младших разрядах перейдёт через нуль или в строке символов встретится 
		невыполнимая в пределах одной строки команда, например &laquo;<i>ВК</i>&raquo; 
		или &laquo;<i>очистка экрана</i>&raquo;. При этом курсор вернётся на прежнее 
		место экрана (содержимое ячейки восстановится в соответствии с номером символа). 
		Символ по заданному в ячейке <span class="nmbr">160</span> адресу может 
		быть выведен и в ОЗУ пользователя, скажем, по адресу <span class="nmbr">
		30000</span>. Хотя при этом он не виден, но может быть использован, например, 
		для получения на экране его увеличенной &laquo;<i>копии</i>&raquo; (в различных 
		заставках), &laquo;<i>бегущей строки</i>&raquo; и т.п.</li>
		<li><span class="nmbr">162</span> - горизонтальный размер символа на экране, 
		в байтах. В этой ячейке хранится величина горизонтального смещения курсора 
		после формирования очередного символа. В режиме &laquo;<i>64 символа в строке</i>&raquo; 
		она равна <span class="nmbr">1</span>, в режиме &laquo;<i>32</i>&raquo; 
		- <span class="nmbr">2</span>. Меняя содержимое ячейки, можно получить оригинальные 
		эффекты вывода символов &laquo;<i>вразрядку</i>&raquo;, по вертикали, диагонали. 
		назад:</li>
	</ul>
	<pre><span class="locl">0</span>:      <span class="cmds">MOV</span>     #<span class="nmbr">1001</span>,@#<span class="nmbr">162</span>         <span class="cmmnt">; Интервал вывода</span>
        <span class="cmds">MOV</span>     #<span class="labl">TEX</span>,<span class="regn">R1</span>             <span class="cmmnt">; Начало текста</span>
        <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Признак конца</span>
                                    <span class="cmmnt">; текста</span>
        <span class="cmds">EMT</span>     <span class="nmbr">20</span>                  <span class="cmmnt">; Выдать текст</span>
        <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ждать нажатия клавиши</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа зациклена</span>
<span class="labl">ТЕХ</span>:    <span class="pscm">.A</span>:<span class="strn">Привет!</span>
        <span class="pscm">.E</span>
        <span class="pscm">END</span></pre>
	<p>Однако при использовании данного приёма необходимо учитывать, что по достижении &laquo;<i>физического</i>&raquo; 
	конца экрана (который при сдвинутом рулоне может прийтись на любое место) и 
	попытке &laquo;<i>вывода</i>&raquo; символов в область ПЗУ компьютер зависнет, 
	так как соответствие номера символа и рулона нарушается.</p>
	<ul>
		<li><span class="nmbr">164</span> - количество знакомест экрана (<span class="nmbr">3000</span> 
		в обычном режиме и <span class="nmbr">400</span> в режиме &laquo;<i>РП</i>&raquo;).</li>
		<li><span class="nmbr">166</span> - адрес (номер) байта текущей ГТ на экране. 
		Не зависит от сдвига рулона, левый верхний угол экрана всегда
		<span class="nmbr">0</span>, правый нижний - <span class="nmbr">35777</span>. 
		Может использоваться вместе с ячейкой <span class="nmbr">154</span> для 
		вычисления (и, например, индикации) позиции курсора в режиме текстовой графики.</li>
		<li><span class="nmbr">170</span> - абсолютный адрес байта текущей ГТ на 
		экране. При начальном положении рулона меняется от <span class="nmbr">42000</span> 
		до <span class="nmbr">77777</span>. Меняется при сдвиге рулона.</li>
		<li><span class="nmbr">172</span> - длина графического вектора. Используется 
		при исполнении команд текстовой графики.</li>
		<li><span class="nmbr">174</span> - счётчик телевизионных строк. Используется 
		при перемещении графического курсора в пределах одного знакоместа, для организации 
		рулонного сдвига экрана в режиме текстовой графики.</li>
		<li><span class="nmbr">176</span> - буфер координаты <span class="var">X</span> 
		для <span class="cmds">EMT</span> <span class="nmbr">30</span> и
		<span class="cmds">EMT</span> <span class="nmbr">32</span>.</li>
		<li><span class="nmbr">200</span> - буфер координаты <span class="var">Y</span> 
		для <span class="cmds">EMT</span> <span class="nmbr">30</span> и
		<span class="cmds">EMT</span> <span class="nmbr">32</span>.</li>
	</ul>
	<p>Две последние ячейки могут широко использоваться в различных функциях графических 
	редакторов и других программ с применением <span class="cmds">EMT</span>
	<span class="nmbr">30</span> и <span class="cmds">EMT</span>
	<span class="nmbr">32</span> для получения координат последней выведенной точки 
	(конца вектора).</p>
	<ul>
		<li><span class="nmbr">202</span> - адрес начала видеопамяти. Вне зависимости 
		от рулонного сдвига экрана в этой ячейке всегда число <span class="nmbr">
		40000</span> (в режиме &laquo;<i>РП</i>&raquo; - <span class="nmbr">70000</span>). 
		Может использоваться как константа адреса конца ОЗУ пользователя, для определения 
		режима (обычный или &laquo;<i>РП</i>&raquo;) и т.п.</li>
		<li><span class="nmbr">204</span> - относительный адрес начала экрана (или 
		адрес конца служебной строки). В исходном положении рулона -
		<span class="nmbr">2000</span>, меняется со сдвигом рулона. Иначе это число 
		называется базой видеопамяти.</li>
		<li><span class="nmbr">206</span> - длина видеопамяти в байтах,
		<span class="nmbr">40000</span> - в обычном режиме и <span class="nmbr">
		10000</span> - в &laquo;<i>РП</i>&raquo;.</li>
		<li><span class="nmbr">210</span> - длина рабочей области экрана в байтах 
		(равна длине видеопамяти за вычетом длины памяти служебной строки),
		<span class="nmbr">36000</span> - в обычном режиме и <span class="nmbr">
		5000</span> - в режиме &laquo;<i>РП</i>&raquo; (так как в &laquo;<i>РП</i>&raquo; 
		ещё <span class="nmbr">1000</span> байт отводится на нижнюю черту - границу 
		экрана). Все эти константы используются драйверами дисплея для адресации 
		графических точек и символов на экране. В своих программах их можно использовать 
		для автоматического учёта границ экрана при переходе в режим &laquo;<i>РП</i>&raquo; 
		и коррекции выводимых на экран изображений.</li>
		<li><span class="nmbr">212</span> - маска цвета фона экрана. В БК-0010 реализованы 
		четыре цвета - красный, зелёный, синий и чёрный, которым соответствуют маски
		<span class="nmbr">177777</span>, <span class="nmbr">125252</span>,
		<span class="nmbr">52525</span> и <span class="nmbr">0</span>. Например, 
		если фон экрана чёрный, то маска в ячейке <span class="nmbr">212</span> 
		равна <span class="nmbr">0</span>. Если экран инверсный в чёрно-белом режиме 
		(или при красном цвете фона в цветном режиме), маска равна
		<span class="nmbr">177777</span> и т.д. Изменяя содержимое ячейки
		<span class="nmbr">212</span>, можно менять цвет фона<a href="#_ftn12" name="_ftnref12" title=""><sup>[12]</sup></a>, 
		делать экран &laquo;<i>полосатым</i>&raquo; и т.п.</li>
		<li><span class="nmbr">214</span> - маска цвета символа на экране. Маски 
		символов точно такие же, как для фона. Помимо символов, текущая маска в 
		ячейке <span class="nmbr">214</span> &laquo;<i>отвечает</i>&raquo; за цвета 
		графических точек и векторов. Комбинируя различные маски (не только четыре 
		вышеуказанные) по вертикали и горизонтали, можно значительно расширить цветовую 
		па литру БК-0010, а задавая специально подобранные значения (например,
		<span class="nmbr">100001</span> в цветном режиме), можно &laquo;<i>маскировать</i>&raquo; 
		выводимые символы. Вообще же, комбинируя маски фона и символа, можно получить 
		самые разнообразные эффекты.</li>
		<li><span class="nmbr">216</span> - маска цвета фона служебной строки.</li>
		<li><span class="nmbr">220</span> - маска цвета символа служебной строки. 
		Эти две ячейки играют для служебной строки ту же роль, что две предыдущие 
		для всего экрана.</li>
		<li><span class="nmbr">222</span> - счётчик кодов.</li>
		<li><span class="nmbr">224</span> - счётчик установки индикаторов.</li>
	</ul>
	<p>Две последние ячейки используются при выдаче в служебную строку индикаторов 
	- надписей, указывающих на режимы дисплея: &laquo;<i>РУС</i>&raquo;, &laquo;<i>ЛАТ</i>&raquo;, &laquo;<i>ГРАФ</i>&raquo;, &laquo;<i>ЗАП</i>&raquo;, &laquo;<i>СТИР</i>&raquo;, &laquo;<i>БЛР</i>&raquo;, &laquo;<i>ИСУ</i>&raquo;, &laquo;<i>РЕД</i>&raquo;.</p>
	<ul>
		<li><span class="nmbr">226</span>-<span class="nmbr">246</span> - не используются</li>
		<li><span class="nmbr">250</span>-<span class="nmbr">254</span> - буферы 
		служебных констант драйвера телеграфного канала.</li>
		<li><span class="nmbr">256</span> - ячейка, зарезервированная под копию 
		порта вывода (драйверами монитора БК-0010 не используется).</li>
		<li><span class="nmbr">260</span> - адрес дополнительной программы обработки 
		прерывания от клавиатуры. Если занести в эту ячейку какой-либо адрес, то 
		управление будет передаваться на него при нажатии на любую клавишу. При 
		нормальном функционировании ЭВМ код в эту ячейку заносится автоматически 
		драйвером клавиатуры (ячейка обнуляется, что означает отказ от вызова дополнительной 
		программы и продолжение обработки драйвером нажатия клавиши).</li>
		<li><span class="nmbr">262</span> - признак кода &laquo;<i>ВК</i>&raquo;. 
		Если в этой ячейке содержится нуль, то при нажатии клавиши &laquo;<i>ВВОД</i>&raquo; 
		в программу передаётся код <span class="nmbr">12</span> (большинство режимов), 
		иначе - код <span class="nmbr">15</span> (например, в Фокале).</li>
		<li><span class="nmbr">264</span> - буфер стартового адреса. В эту ячейку 
		заносится физический адрес последнего загруженного файла (независимо от 
		адреса, указанного в оглавлении файла) и на него передаётся управление по 
		директиве пускового монитора &laquo;<i>S</i>&raquo; (без указания адреса 
		в явном виде).</li>
		<li><span class="nmbr">266</span> - буфер длины массива. В эту ячейку заносится 
		длина последнего считанного файла.</li>
		<li><span class="nmbr">270</span>, <span class="nmbr">272</span> - не используются 
		(это адрес вектора прерывания IRQ3 ЦП, не задействованного на БК аппаратно).</li>
		<li><span class="nmbr">274</span>, <span class="nmbr">276</span> - вектор 
		прерывания от клавиатуры по нижнему регистру<a href="#_ftn13" name="_ftnref13" title=""><sup>[13]</sup></a> 
		(&laquo;<i>АР2</i>&raquo; на БК-0010.01).</li>
		<li><span class="nmbr">300</span> (байт) - &laquo;<i>флаг</i>&raquo; фазы 
		читаемого с МЛ сигнала, устанавливается при чтении равным
		<span class="nmbr">0</span> или <span class="nmbr">377</span> (прямой или 
		инверсный сигнал).</li>
		<li><span class="nmbr">301</span> (байт) - признак ошибки при работе драйвера 
		магнитофона. Данная ячейка дублирует ячейку <span class="nmbr">321</span> 
		блока параметров <span class="cmds">EMT</span> <span class="nmbr">36</span>. 
		причём она является первичной, а ячейка <span class="nmbr">321</span> - 
		вторичной.</li>
		<li><span class="nmbr">302</span> - признак фиктивного чтения файла драйвером 
		магнитофона. При фиктивном чтении эта ячейка не равна <span class="nmbr">
		0</span>.</li>
		<li><span class="nmbr">304</span> - инкремент адреса массива при работе 
		драйвера магнитофона. В БК-0010 содержимое этой ячейки при чтении файлов 
		всегда равно <span class="nmbr">1</span> (при фиктивном чтении -
		<span class="nmbr">0</span>). В случае его изменения в некоторых неграмотно 
		написанных копировщиках возникает характерный дефект при загрузке файла 
		- косая &laquo;<i>сетка</i>&raquo; на экране (отдельные байты, далеко отстоящие 
		друг от друга) и порча отдельных байтов всех массивов, находящихся в памяти 
		дальше начала загружаемого файла<a href="#_ftn14" name="_ftnref14" title=""><sup>[14]</sup></a>.</li>
		<li><span class="nmbr">306</span> - буфер адреса блока параметров
		<span class="cmds">EMT</span> <span class="nmbr">36</span>, дублирует содержимое 
		регистра <span class="regn">R1</span> и используется при работе драйвера 
		магнитофона.</li>
		<li><span class="nmbr">310</span> - буфер указателя стека, сюда заносится 
		и отсюда восстанавливается (по клавише &laquo;<i>СТОП</i>&raquo; или по 
		окончании работы <span class="cmds">EMT</span> 36) адрес вершины стека при 
		работе драйвера магнитофона.</li>
		<li><span class="nmbr">312</span> - буфер контрольной суммы массива (файла). 
		В эту ячейку заносится контрольная сумма при чтении или записи файла на 
		МЛ. Кроме того, она используется как буфер загрузки при фиктивном чтении 
		файлов.</li>
		<li><span class="nmbr">314</span> - константа сравнения при чтении файла. 
		Сюда заносится результат вычислений константы по установочной последовательности. 
		Это число позволяет ЭВМ отличать при чтении файла нулевой бит от единичного. 
		Используется драйвером магнитофона при чтении, может также использоваться 
		для примерной оценки скорости при записи.</li>
		<li><span class="nmbr">316</span> - не используется. Это единственная из 
		неиспользуемых ячеек, содержимое которой не меняется при исполнении
		<span class="cmds">EMT</span> <span class="nmbr">14</span> (не считая ячеек 
		стека)<a href="#_ftn15" name="_ftnref15" title=""><sup>[15]</sup></a>. Особая 
		просьба: не использовать эту ячейку в пользовательских программах, а оставить 
		для системных драйверов, которые пишет автор этой статьи (драйвер спецформата 
		магнитофона, драйвер дисковода и т.п.), иначе ваши программы просто будут 
		несовместимы с этими системными программами и вам же будет хуже.</li>
		<li><span class="nmbr">320</span>-<span class="nmbr">371</span> - блок параметров 
		драйвера магнитофона. Назначение этих ячеек было подробно изложено при описании
		<span class="cmds">EMT</span> <span class="nmbr">36</span>.</li>
		<li><span class="nmbr">372</span>-<span class="nmbr">777</span> - стек.</li>
	</ul>
	<p class="centr">★ ★ ★</p>
	<p>Наше повествование о системной области подходит к завершению. Осталось сказать 
	несколько слов о стеке.</p>
	<p>Как вы уже знаете, стек - это специально выделенная область памяти, куда 
	сама ЭВМ или программы пользователя заносят данные, которые нужно сохранить 
	(обычно временно). Адресуется стек чаще всего через специальный регистр
	<span class="regn">R6</span>, или <span class="regn">SP</span>, отличающийся 
	от остальных регистров процессора тем, что его автоинкремент или автодекремент 
	выполняется всегда на <span class="nmbr">2</span>, независимо от того, работает 
	команда со словом или с байтом.</p>
	<p>Отсчёт ячеек стека, в отличие от всех прочих участков памяти, ведётся &laquo;<i>сверху 
	вниз</i>&raquo;, т.е. началом считается адрес <span class="nmbr">777</span> 
	(или, в чётных адресах, <span class="nmbr">776</span>), а концом (или &laquo;<i>дном</i>&raquo;) 
	- адрес <span class="nmbr">372</span>. Если программа, использующая стек, не 
	работает с магнитофоном или организует блок параметров для него начиная не с 
	адреса <span class="nmbr">320</span>, а в другом месте ОЗУ, то стек может быть &laquo;<i>продлён</i>&raquo; 
	до адреса <span class="nmbr">320</span>.</p>
	<p>Ячейка, адрес которой соответствует текущему содержимому
	<span class="regn">SP</span>, называется <b>вершиной</b> стека. Адрес вершины 
	при работе со стеком не остаётся постоянным, а всё время меняется. Но этот адрес 
	всегда должен восстанавливаться при работе отдельных ветвей программы. Таким 
	образом, если мы в начале программы заносим что-либо в стек, изменяя адрес его 
	вершины, а затем программа ветвится. то мы должны восстановить адрес вершины 
	до ветвления или предусмотреть одинаковый порядок его восстановления в каждой 
	из ветвей (либо после выхода из них). Нарушение этого правила может привести 
	к тому, что стек будет постоянно засоряться всё новыми данными и рано или поздно 
	затрёт ячейки системной области. К чему это приведёт, ясно без лишних комментариев<a href="#_ftn16" name="_ftnref16" title=""><sup>[16]</sup></a>.</p>
	<p>Стек в БК-0010 организуется по типу магазина для автоматического оружия, 
	а обмен данных в нём - по принципу &laquo;первым вошёл - последним вышел&raquo;. 
	Данные, введённые раньше, оказываются в стеке дальше от вершины (и &laquo;<i>выше</i>&raquo; 
	в памяти), чем введённые позже, и данные, введённые последними, извлекаются 
	из стека прежде всего. Но это всего лишь традиция и удобный приём обращения 
	к стеку. Не составляет большого труда организовать хранение данных и по другому 
	принципу, например &laquo;первым вошёл - первым вышел&raquo; (&laquo;<i>очередь</i>&raquo;), 
	но это, как правило, менее удобно.</p>
	<p>Обычно данные сохраняются в стеке с помощью стандартного приёма - последовательной 
	засылкой операторами <span class="cmds">MOV</span> с автодекрементной адресацией 
	регистра <span class="regn">R6</span> (последовательное извлечение с помощью 
	автоинкрементной адресации). По ходу изучения ассемблера приводилось столько 
	примеров с использованием стека, что повторять их нет необходимости. Мы познакомились 
	также ещё с двумя возможностями сохранения и использования данных в стеке: с 
	помощью косвенной индексации (чтобы &laquo;<i>достать</i>&raquo; данные, лежащие 
	не на вершине) и малоупотребительной команды <span class="cmds">MARK</span>. 
	Но есть ещё один способ использования стека для хранения данных - с помощью 
	абсолютной адресации.</p>
	<p>При реализации этого способа исходят из того, что для работы подавляющего 
	большинства пользовательских программ такая &laquo;<i>глубина</i>&raquo; стека, 
	которая имеется на БК-0010, не нужна. Вполне достаточно иметь &laquo;<i>дно</i>&raquo; 
	стека по адресу <span class="nmbr">600</span>, а иногда даже
	<span class="nmbr">700</span>. При этом всю расположенную ниже область памяти 
	можно рассматривать как системные ячейки, не используемые драйверами монитора 
	БК-0010. Естественно, что любая из этих ячеек может быть использована программистом 
	для своих нужд. Например, этот приём широко применяется в <i>МИКРО.<span class="nmbr">10</span>К:</i> 
	начиная с адреса <span class="nmbr">400</span> по <span class="nmbr">600</span> 
	многие ячейки используются для хранения констант и переменных ассемблер-системы. 
	Перечислим некоторые из них, они могут быть полезными при работе с <i>МИКРО.<span class="nmbr">10</span>К</i>:</p>
	<ul>
		<li><span class="nmbr">402</span> - адрес начала текста редактора,</li>
		<li><span class="nmbr">404</span> - адрес текущего конца текста редактора,</li>
		<li><span class="nmbr">426</span> - текущий адрес метки,</li>
		<li><span class="nmbr">432</span> - текущий адрес курсора,</li>
		<li><span class="nmbr">446</span> - адрес начала текущей страницы текста,</li>
		<li><span class="nmbr">470</span> и далее - буфер маски поиска.</li>
	</ul>
	<p>Разумеется, используются в <i>МИКРО</i> и другие ячейки. Благодаря такой 
	организации системных переменных <i>МИКРО.<span class="nmbr">10</span>К</i> 
	как программа, не имеющая внутри себя буфера переменных может с равным успехом 
	работать и в ОЗУ пользователя, и в дополнительном ОЗУ, и в ПЗУ, что является 
	примером рациональной организации инструментальных программ. Попутно укажем, 
	как можно изменить <i>МИКРО.<span class="nmbr">10</span>К</i> таким образом, 
	чтобы изменились параметры буферов текста и загрузочного модуля, но сначала 
	сделаем одно замечание.</p>
	<p>Многие решительно выступают против того, чтобы использовать выделенные ячейки 
	стека (и вообще свободные ячейки системной области) для хранения переменных 
	в программах пользователя, и не без оснований: если в памяти должны работать 
	две программы и обе используют по роковому стечению обстоятельств одни и те 
	же ячейки, то они будут мешать друг другу, и, скорее всего, ни одна из них нормально 
	работать не сможет. Что можно на это возразить? Во-первых, вариант, когда в 
	памяти БК-0010 работает сразу несколько программ, встречается не так уж часто. 
	А во-вторых, где прикажете размещать переменные, если программа должна быть 
	рассчитана на работу в ПЗУ? А этот вариант становится всё более распространённым<a href="#_ftn17" name="_ftnref17" title=""><sup>[17]</sup></a>. 
	Словом, как уже было сказано раньше, вам самим решать, что и каким образом использовать. 
	Автор же, придерживаясь демократических взглядов, от категорических рекомендаций 
	и запретов предпочитает воздерживаться.</p>
	<p>Но вернёмся к обещанным рекомендациям по изменению <i>МИКРО</i>. В исходной 
	версии <i>МИКРО.<span class="nmbr">10</span>К-РП</i> (или, равным образом.
	<i>МИКРО.<span class="nmbr">10</span>-<span class="nmbr">01</span>К</i>) адрес 
	начала текста равен <span class="nmbr">17001</span>, адрес загрузочного модуля 
	(программы в кодах, получаемой в результате трансляции или трансляции и компоновки) 
	- <span class="nmbr">13000</span>. Таким образом, для текста программы выделено
	<span class="nmbr">20000</span> байт (последние <span class="nmbr">1000</span> 
	байт ОЗУ ассемблер использует под таблицу меток), а под загрузочный модуль -
	<span class="nmbr">4000</span>. Это достаточно рациональное распределение памяти, 
	если ассемблер-система расположена в ОЗУ по адресу <span class="nmbr">1000</span>. 
	А если ассемблер размещается в ПЗУ (или дополнительном ОЗУ), например, по адресу
	<span class="nmbr">140000</span>? Ясно, что первые <span class="nmbr">12000</span> 
	байт ОЗУ пользователя при этом будут потеряны. Как перераспределить память?</p>
	<p>В <i>МИКРО.<span class="nmbr">10</span>К</i> для этого есть три ячейки. Если 
	обозначить адрес загрузки ассемблер- системы за <span class="nmbr">0</span>, 
	то в ячейке <span class="nmbr">6</span> содержится адрес начала текста редактора, 
	в ячейке <span class="nmbr">32</span> - адрес начала загрузочного модуля, а 
	в ячейке <span class="nmbr">36</span> - тот же адрес минус
	<span class="nmbr">1000</span> (используемый при вычислении адресов меток). 
	При размещении <i>МИКРО.<span class="nmbr">10</span>К</i> в области ПЗУ целесообразно 
	задать адрес текста равным <span class="nmbr">10001</span>, адрес загрузочного 
	модуля - <span class="nmbr">1000</span>, а третью константу -
	<span class="nmbr">0</span>. Разумеется, распределение памяти может быть и иным, 
	в зависимости от целей применения <i>МИКРО.<span class="nmbr">10</span>К</i>. 
	Например, если <i>МИКРО</i> используется только как текстовый редактор, можно 
	задать адрес начали текста <span class="nmbr">1001</span>, а две другие константы 
	не изменять. При размещении <i>МИКРО.<span class="nmbr">10</span>К</i> в ОЗУ 
	пользователя и применении его в качестве текстового редактора также можно увеличить 
	буфер текста, задав адрес его начала (в ячейке <span class="nmbr">6</span>), 
	например, равным <span class="nmbr">13001</span>. Кстати, единица в адресе начала 
	текста <i>МИКРО.<span class="nmbr">10</span>К</i> совсем не обязательна, он 
	может быть любым, просто такой адрес - опознавательный признак текстового файла
	<i>МИКРО.<span class="nmbr">10</span>К</i> и, кроме того, для нормальной работы 
	текстового редактора желательно иметь перед буфером текста свободный байт, куда 
	при запуске записывается код <span class="nmbr">12</span>. После изменения параметров 
	буферов МИКРО надо помнить, что для их реализации необходимо перезапустить
	<i>МИКРО.<span class="nmbr">10</span>К</i> с адреса загрузки.</p>
	<p class="centr">★ ★ ★</p>
	<p>Бывают случаи, когда стек, расположенный по адресам <span class="nmbr">372</span>...<span class="nmbr">777</span>, 
	начинает мешать работе. Допустим, нам надо скопировать файл длиной
	<span class="nmbr">77400</span> с адресом загрузки, равным
	<span class="nmbr">400</span> (такие игровые программы есть, в них подобный 
	адрес и длина файла - своеобразный, но очень &laquo;<i>слабый</i>&raquo; способ 
	защиты от копирования). Сделать это обычным копировщиком, размещаемым в ОЗУ, 
	нельзя - всё ОЗУ занимает копируемый файл. Но и обычный копировщик, размещённый 
	в дополнительном ОЗУ или ПЗУ, тоже непригоден - мешает стек. Как быть? Нужен 
	копировщик, размещаемый в дополнительном ОЗУ (например, с адреса
	<span class="nmbr">140000</span>) и переносящий стек в эту же зону. А для переноса 
	стека достаточно изменить содержимое регистра <span class="regn">SP</span>.</p>
	<p>Ещё один случай, когда надо представлять, что хранится в стеке, - это создание 
	программ с автозапуском. Такие программы обычно имеют адрес загрузки меньше
	<span class="nmbr">1000</span> и после загрузки самозапускаются. Как это происходит? 
	Довольно просто. При обращении к драйверу магнитофона по прерыванию
	<span class="cmds">EMT</span> <span class="nmbr">36</span> в стек заносится 
	адрес команды, следующей за вызвавшей прерывание. Если теперь мы загрузим программу, 
	в начале которой (до адреса <span class="nmbr">1000</span>) записан блок, состоящий 
	из слов, содержащих адрес запуска, то адрес команды, следующей после вызова
	<span class="cmds">EMT</span> <span class="nmbr">36</span>, будет в стеке подменен. 
	После возврата из прерывания (после загрузки файла) этот адрес по команде
	<span class="cmds">RTI</span> попадает в <span class="regn">PC</span> и управление 
	передаётся на запуск загруженного файла. В МСД исходный адрес вершины стека 
	- <span class="nmbr">732</span>, сюда обычно и заносят адрес запуска программы 
	с автозапуском. В ПМ исходный адрес вершины стека - <span class="nmbr">1000</span> 
	и адрес автозапуска обычно заносят по адресу <span class="nmbr">776</span> или
	<span class="nmbr">766</span> - в обоих случаях автозапуск &laquo;<i>сработает</i>&raquo;. 
	Автозапуск по ячейке <span class="nmbr">766</span> можно задать прямо в МСД, 
	записав затем на МЛ файл с адреса, например, <span class="nmbr">760</span>. 
	Для задания автозапуска по другим ячейкам необходимы особые программные средства, 
	например специальный копировщик<a href="#_ftn18" name="_ftnref18" title=""><sup>[18]</sup></a>. 
	Обычно такие средства заносят адрес запуска программы начиная с ячейки
	<span class="nmbr">732</span> (или даже с ещё более &laquo;<i>низких</i>&raquo; 
	адресов) до <span class="nmbr">1000</span>, что обеспечивает автозапуск из любого 
	режима.</p>
	<p>Однако у автозапуска есть недостатки. Во-первых, после загрузки программа 
	запускается без проверки на наличие ошибок чтения, а во-вторых,
	<span class="cmds">EMT</span> <span class="nmbr">36</span>, как правило, заканчивает 
	при этом работу &laquo;<i>нештатным</i>&raquo; образом и дистанционное управление 
	магнитофона не отключается, если только в запущенной программе пользователя 
	не присутствует команда, делающая это взамен неоконченного
	<span class="cmds">EMT</span> <span class="nmbr">36</span> (например, команда
	<span class="cmds">EMT</span> <span class="nmbr">14</span>). Разработаны (в 
	том числе автором) несколько способов автозапуска, позволяющих устранить указанные 
	недостатки, но на этом мы останавливаться не будем. Отметим только, что основаны 
	они на том, что в начале программы помещается блок (при загрузке размещаемый 
	ещё &laquo;<i>глубже</i>&raquo; в стеке), на который автозапуск и передаёт управление, 
	а уже этот блок делает всё необходимое, в том числе и перемещение загруженной 
	программы по рабочему адресу (что очень важно, если автозапуском снабжена программа, 
	начинающаяся не с адреса <span class="nmbr">1000</span>), а уже потом запускает 
	её.</p>
	<p>В заключение следует сказать, что автозапуск довольно коварный приём и снабжать 
	им все программы подряд не рекомендуется. Особенно это относится к системным 
	и инструментальным программам, которые автозапуск может даже иногда сделать 
	неработоспособными (например, если для этого требуется обязательный &laquo;<i>штатный</i>&raquo; 
	выход из режима загрузки: запись в нужные ячейки всех переменных, байта ответа
	<span class="cmds">EMT</span> <span class="nmbr">36</span>. восстановление стека 
	и т.п.).</p>
	<h2><a name="toc_48"></a>Для чего предназначен ассемблер?</h2>
	<p>&laquo;Вот это да! - скажет иной читатель. - Сначала мы изучили язык, а потом 
	задаём вопрос, зачем он нужен?!&raquo; Но вопрос этот не праздный. Хотя язык 
	ассемблера относится к машинно-ориентированным языкам, а значит, по сути своей 
	универсален, есть определённые классы задач, для решения которых он подходит 
	больше, а для других - меньше. Что же это за задачи?</p>
	<p>Поскольку программы, написанные на ассемблере, имеют максимальное быстродействие, 
	ясно, что преимущества языка более выражены при операциях с большими массивами 
	информации, а также при работе в реальном времени. Это может быть:</p>
	<ul>
		<li>пересылка массивов, в том числе текстов и изображений, их обработка 
		и модификация;</li>
		<li>сортировка, перекодирование, перевод из одного формата в другой и обратно, 
		упаковка и распаковка текстов и изображений. поиск в массивах заданной информации;</li>
		<li>логическая обработка информации (логические игры и головоломки, логическое 
		моделирование процессов);</li>
		<li>скоростной анализ ситуаций и генерация динамических моделей (в играх 
		и при управлении внешними объектами);</li>
		<li>связь с внешними устройствами в заданных форматах и с заданными скоростями 
		обмена.</li>
	</ul>
	<p>Теперь посмотрим, для решения каких задач ассемблер приспособлен меньше всего. 
	Как известно, система команд процессора БК-0010 содержит только простейшие арифметические 
	операции с целыми числами - сложение и вычитание. Не так уж трудно на их основе 
	построить программы целочисленного умножения и деления, но даже построенные 
	по оптимальным алгоритмам, эти операции будут выполняться на порядок медленнее, 
	чем элементарные, а программы - занимать довольно большой объём памяти. Стоит 
	ли говорить тогда о программах плавающей арифметики, вычисления функций и т.п.? 
	Вряд ли удастся при их написании заметно улучшить алгоритмы аналогичных вычислений, 
	имеющиеся в языках высокого уровня, а занимаемый объём ОЗУ при этом станет так 
	значителен, что оставшаяся для других нужд память заметно сократится. В то же 
	время выигрыш по быстродействию по сравнению с языками высокого уровня будет 
	не так уж велик. Таким образом, ассемблер меньше всего подходит для решения 
	задач вычислительного характера.</p>
	<p>Но иногда включение вычислений в прочие программы на ассемблере бывает совершенно 
	необходимо. Например, нередко в ходе управления объектами (или в играх) приходится 
	вычислять траектории движения по формулам, генерировать псевдослучайные последовательности 
	и т.п. Конечно, в наборе прикладных программ, разработанных для БК-0010, есть 
	математические пакеты, реализующие любые функции плавающей арифметики (например, 
	пакет ARPAC), и даже специальные языки - расширения ассемблер-системы (язык 
	ALMIC, <span class="nmbr">1991</span> г.). Но, как уже отмечалось, программы 
	плавающей арифметики работают относительно медленно (хотя, конечно, гораздо 
	быстрее, чем, например, Фокал) и занимают много памяти. Чтобы не терять присущие 
	ассемблеру преимущества - быстродействие и компактность программ, можно предложить 
	несколько особых приёмов.</p>
	<p>Все вычисления нужно пытаться сводить к целочисленной арифметике в пределах 
	одного машинного слова (однорегистровая арифметика). В самом деле, одно машинное 
	слово может содержать число от <span class="nmbr">0</span> до
	<span class="nmbr">65535</span><sub>д</sub>, при этом его изменение на единицу 
	даёт относительную погрешность всего около <span class="nmbr">0</span>,<span class="nmbr">002</span>% 
	от конечного значения. Такая точность представления чисел (и даже на два порядка 
	худшая) вполне приемлема для подавляющего большинства практических задач. Но 
	тогда остро встаёт вопрос о диапазоне представления чисел и порядке вычислений. 
	Например для целочисленного умножения исходные числа не могут быть больше
	<span class="nmbr">377</span> каждое, а значит, точность их представления будет 
	не выше <span class="nmbr">0</span>.<span class="nmbr">4</span>%. Это пока ещё 
	допустимая точность для большинства задач управления объектами, особенно если 
	учесть, что точность многих датчиков на порядок ниже. Но при операциях с такими 
	числами возможна очень большая потеря точности, особенно при делении. Когда 
	делимое и делитель одного порядка, погрешность результата в целых числах будет 
	не меньше 10%. Поэтому при решении вычислительных задач в целых числах первостепенное 
	внимание надо уделять порядку вычислений: вначале выполнять умножение, а потом 
	деление, заботиться, чтобы не было деления меньшего числа на большее (что приведёт 
	к потере числа в дальнейших вычислениях) и т.п. Общее правило целочисленной 
	арифметики вообще таково: надо стараться, чтобы при умножении и делении как 
	исходные числа, так и результат лежали как можно ближе к границе переполнения 
	(т.е. для двухбайтных чисел без знака - к <span class="nmbr">65536</span><sub>д</sub>), 
	но переноса не происходило. Тем не менее при вычислении таким образом сложных 
	функций, например тригонометрических. число последовательных умножений и делений 
	будет так велико, что потеря точности станет значительной, а время вычислений 
	- соизмеримым с таковым в языках высокого уровня. В этих случаях рекомендуется, 
	когда это возможно, заменять вычисления функций по формулам на их табличное 
	представление. Как это сделать? Предположим, необходимо вычислять значения синуса 
	угла в диапазоне от <span class="nmbr">0</span> до <span class="nmbr">90</span>º. 
	Если точность представления аргумента не выше <span class="nmbr">1</span>º, 
	таблица значений такой функции займёт всего <span class="nmbr">90</span> машинных 
	слов (а если пойти на некоторое снижение точности, то <span class="nmbr">90</span> 
	байт). Зная, что диапазон значений данной функции лежит в пределах от
	<span class="nmbr">0</span> до <span class="nmbr">1</span>, сопоставим максимуму 
	функции число <span class="nmbr">65535</span>, а минимуму -
	<span class="nmbr">0</span>. Промежуточные значения при заданном аргументе легко 
	вычисляются умножением синуса на число <span class="nmbr">65535</span> и подставляются 
	в таблицу. Например, синус <span class="nmbr">30</span>º при таком представлении 
	будет равен <span class="nmbr">0</span>.<span class="nmbr">5</span> *
	<span class="nmbr">65535</span> = <span class="nmbr">32768</span> (округлённо). 
	Вряд ли программа вычисления синуса с точностью до пятого знака уложится в такой 
	же объём памяти, как таблица, а о сравнимом быстродействии не приходится и говорить. 
	Если же необходимо большее число градаций аргумента, то не стоит увеличивать 
	в десятки раз объём таблицы, а лучше всего, особенно для такой функции, как 
	синус, прибегнуть к линейной интерполяции. Таким путём в большинстве случаев 
	удаётся избегнуть громоздких и длительных вычислений по формулам. Если же, как 
	часто бывает, нужен не весь диапазон представления аргумента, а только его часть 
	(например, вычисление радиуса разворота самолёта в зависимости от крена, допустимое 
	значение которого не превышает <span class="nmbr">30</span>º), то таблица станет 
	ещё короче либо может быть повышена точность. Не следует забывать и об элементарных 
	преобразованиях функций, известных ещё из курса средней школы, которые часто 
	позволяют выразить одну функцию через другую и тем самым упростить вычисления 
	или сократить количество функций, вычисляемых таблично.</p>
	<p>Что же касается генерации случайных чисел. то тут есть очень простой и на 
	первый взгляд неочевидный выход. Что представляет собой ПЗУ БК-0010, если не 
	последовательность чисел, с точки зрения пользователя случайную? Специальные 
	исследования показали, что если выбирать последовательные числа из ячеек ПЗУ, 
	то после несложных преобразований их ряд хорошо удовлетворяет равномерному закону 
	распределения (значительно лучше, чем, например, генератор случайных чисел Фокала). 
	О возможностях же использования в качестве генератора случайных чисел системного 
	таймера уже говорилось в разделе, посвящённом системным регистрам.</p>
	<p>Итак, хотя ассемблер - это язык, явно лучше приспособленный для логической, 
	чем для математической, обработки информации, всё же, прибегая к специальным 
	приёмам, вполне можно без потери присущего ему быстродействия выполнять с его 
	помощью и вычисления.</p>
	<h2><a name="toc_49"></a>&laquo;<em>Стандартные</em>&raquo; подпрограммы</h2>
	<p>Рассмотрим несколько подпрограмм на ассемблере, имеющих практическое значение 
	и предназначенных для работы с числами. Для наиболее придирчивых (тех, кто любит 
	искать чужие ошибки и неточности) автор сообщает, что эти программы (как и вообще 
	все, приводимые в тексте) написаны им лично. (Хотя для простейших программ авторство 
	- дело сомнительное и &laquo;<i>скользкое</i>&raquo;: уж больно велика вероятность 
	попасть на проторённый путь, и тебя в два счета обвинят в плагиате... Да и вообще, 
	существует ли авторское право на простейшие приёмы программирования? Автор склонен 
	думать, что нет, так как оно не имеет смысла - каждый легко может &laquo;<i>переоткрыть</i>&raquo; 
	эти приёмы сам, не &laquo;<i>списывая</i>&raquo; у другого. Тем не менее автор 
	охотно выслушает замечания читателей.) Все эти программы тщательно проверены 
	и отлажены на БК-0010, и, если не возникнет ошибок при их перепечатке, а затем 
	при вводе с клавиатуры на ЭВМ читателя, все они должны работать. Как с наиболее 
	простого примера, начнём, пожалуй, с генератора псевдослучайных чисел.</p>
	<pre><span class="cmmnt">; Подпрограмма генератора</span>
<span class="cmmnt">; случайных чисел</span>
<span class="cmmnt">; Первое обращение к программе - RNZ,</span>
<span class="cmmnt">; последующие - RND</span>
<span class="cmmnt">; R4 - выход случайного числа,</span>
<span class="cmmnt">; R5 - счётчик адреса</span>
<span class="labl">RND</span>:    <span class="cmds">ADD</span>     (<span class="regn">R5</span>)+,<span class="regn">R4</span>            <span class="cmmnt">; Получение</span>
        <span class="cmds">SWAB</span>    <span class="regn">R4</span>                  <span class="cmmnt">; очередного</span>
        <span class="cmds">ADD</span>     <span class="nmbr">7</span>(<span class="regn">R5</span>),<span class="regn">R4</span>            <span class="cmmnt">; псевдослучайного</span>
        <span class="cmds">DEC</span>     <span class="regn">R4</span>                  <span class="cmmnt">; числа</span>
        <span class="cmds">ADD</span>     <span class="nmbr">15</span>(<span class="regn">R5</span>),<span class="regn">R4</span>           <span class="cmmnt">; в регистре R4</span>
        <span class="cmds">CMP</span>     #<span class="nmbr">137750</span>,<span class="regn">R5</span>          <span class="cmmnt">; Конец ПЗУ?</span>
        <span class="cmds">BLO</span>     <span class="labl">RNZ</span>                 <span class="cmmnt">; Да - перезапуск</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span>
<span class="labl">RNZ</span>:    <span class="cmds">MOV</span>     #<span class="nmbr">100000</span>,<span class="regn">R5</span>          <span class="cmmnt">; Адрес начала ПЗУ</span>
        <span class="cmds">BR</span>      <span class="labl">RND</span>                 <span class="cmmnt">; Генерация</span></pre>
	<p>Программа извлекает содержимое трёх ячеек ПЗУ, &laquo;<i>перемешивает</i>&raquo; 
	полученные числа и выдаёт результат в регистре <span class="regn">R4</span>. 
	Используемый способ &laquo;<i>перетасовки</i>&raquo; трёх чисел для получения 
	псевдослучайной последовательности выбран в результате опытной проверки полученных 
	рядов чисел на равномерность и случайность распределения. Программа даёт непериодический 
	ряд из примерно <span class="nmbr">8000</span> чисел, распределённых в диапазоне
	<span class="nmbr">0</span>...<span class="nmbr">177777</span>. Обращение по 
	метке RNZ необходимо для задания адреса начала ПЗУ, а также может использоваться 
	при отладке, так как даёт всё время одно число.</p>
	<p>Так же проста и программа умножения:</p>
	<pre><span class="cmmnt">; Подпрограмма умножения</span>
<span class="cmmnt">; 8-разрядных чисел</span>
<span class="cmmnt">; R2-множимое, R3-множитель,</span>
<span class="cmmnt">; R4-результат, R5-счётчик итераций</span>
<span class="labl">MUL</span>:    <span class="cmds">MOV</span>     #<span class="nmbr">10</span>,<span class="regn">R5</span>              <span class="cmmnt">; Цикл из 8 итераций</span>
        <span class="cmds">CLR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Очистить</span>
                                    <span class="cmmnt">; аккумулятор результата</span>
<span class="locl">1</span>:      <span class="cmds">ASR</span>     <span class="regn">R3</span>                  <span class="cmmnt">; Очередной разряд</span>
                                    <span class="cmmnt">; множителя</span>
        <span class="cmds">BCC</span>     <span class="locl">2</span>                   <span class="cmmnt">; Если 0 - дальше</span>
        <span class="cmds">ADD</span>     <span class="regn">R2</span>,<span class="regn">R4</span>               <span class="cmmnt">; Иначе прибавить множимое</span>
<span class="locl">2</span>:      <span class="cmds">ASL</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Сдвиг множимого на</span>
                                    <span class="cmmnt">; один разряд</span>
        <span class="cmds">SOB</span>     <span class="regn">R5</span>,<span class="locl">1</span>                <span class="cmmnt">; Если не конец - в цикл</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span></pre>
	<p>Алгоритм этой программы построен совершенно аналогично правилу умножения &laquo;<i>в 
	столбик</i>&raquo; для двоичных чисел и. видимо, в пояснениях не нуждается.</p>
	<p>Программа деления<a href="#_ftn19" name="_ftnref19" title=""><sup>[19]</sup></a> 
	уже заметно сложнее:</p>
	<pre><span class="cmmnt">; Подпрограмма деления</span>
<span class="cmmnt">; 16-разрядных чисел</span>
<span class="cmmnt">; R2-делимое, R3-делитель, R4-частное,</span>
<span class="cmmnt">; R5-счётчик итераций</span>
<span class="labl">DIV</span>:    <span class="cmds">CLR</span>     <span class="regn">R5</span>                  <span class="cmmnt">; Очистить счётчик</span>
        <span class="cmds">CLR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; и аккумулятор</span>
                                    <span class="cmmnt">; результата</span>
<span class="locl">1</span>:      <span class="cmds">INC</span>     <span class="regn">R5</span>                  <span class="cmmnt">; + итерация</span>
        <span class="cmds">ASL</span>     <span class="regn">R3</span>                  <span class="cmmnt">; Делитель сдвинуть</span>
                                    <span class="cmmnt">; влево</span>
        <span class="cmds">BCC</span>     <span class="locl">1</span>                   <span class="cmmnt">; Если не 1 - продолжать</span>
                                    <span class="cmmnt">; искать начало делителя</span>
<span class="locl">2</span>:      <span class="cmds">ROR</span>     <span class="regn">R3</span>                  <span class="cmmnt">; Возврат старшего</span>
                                    <span class="cmmnt">; разряда</span>
<span class="locl">3</span>:      <span class="cmds">INC</span>     <span class="regn">R4</span>                  <span class="cmmnt">; + 1 в разряд</span>
                                    <span class="cmmnt">; частного</span>
        <span class="cmds">SUB</span>     <span class="regn">R3</span>,<span class="regn">R2</span>               <span class="cmmnt">; Вычитание делителя</span>
        <span class="cmds">BCC</span>     <span class="locl">3</span>                   <span class="cmmnt">; Если не конец -</span>
                                    <span class="cmmnt">; продолжать</span>
        <span class="cmds">ADD</span>     <span class="regn">R3</span>,<span class="regn">R2</span>               <span class="cmmnt">; Возврат к</span>
                                    <span class="cmmnt">; предыдущему</span>
        <span class="cmds">DEC</span>     <span class="regn">R4</span>                  <span class="cmmnt">; значению делимого</span>
        <span class="cmds">ASL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Следующий разряд</span>
                                    <span class="cmmnt">; частного</span>
        <span class="cmds">SOB</span>     <span class="regn">R5</span>,<span class="locl">2</span>                <span class="cmmnt">; В цикл итераций</span>
        <span class="cmds">ROR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Шаг назад на</span>
                                    <span class="cmmnt">; один разряд</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span></pre>
	<p>В строках <span class="nmbr">3</span>...<span class="nmbr">5</span> (имеются 
	в виду номера строк по порядку, а не метки) происходит сдвиг делителя влево 
	до первой единицы (т.е. до начала его значащей части) и одновременно определяется 
	число итераций (последовательных вычитаний и сдвигов), необходимых для деления. 
	Оно равно разности <span class="nmbr">16</span><sub>д</sub> и числа значащих 
	разрядов делителя. Затем производится вычитание делителя из делимого, начиная 
	со старших разрядов последнего, а когда результат становится отрицательным, 
	происходит очередной сдвиг и вычитание продолжается в более младшем разряде. 
	Количество вычитаний, с учётом сдвига по разрядам, и есть частное. Остаток от 
	деления сохраняется в <span class="regn">R2</span>. При желании можно по остатку 
	произвести округление результата до целого, сравнив его с <span class="nmbr">
	1</span>/<span class="nmbr">2</span> делителя. Эту программу можно усовершенствовать 
	и в другом направлении, например ввести защиту от деления на ноль. (Использованный 
	алгоритм деления весьма распространён и носит название способа с восстановлением 
	остатка.)</p>
	<p>Надо отметить, что имеются частные случаи, когда нет нужды прибегать к столь 
	сложным алгоритмам. Например, если заранее известно, что делимое и делитель 
	будут отличаться не более чем на порядок, совсем не требуется производить последовательные 
	вычитания со сдвигом. Вполне достаточно просто организовать вычитание до первого 
	переноса. Программа при этом получится настолько простой, что её нет необходимости 
	здесь приводить. То же относится и к программе умножения, если множитель не 
	превышает <span class="nmbr">10</span>-<span class="nmbr">20</span>. Но необходимо 
	помнить, что в неблагоприятных случаях такие простейшие программы работают очень 
	плохо, например деление числа <span class="nmbr">177777</span> на
	<span class="nmbr">2</span> займёт около <span class="nmbr">0</span>.<span class="nmbr">5</span> 
	с<a href="#_ftn20" name="_ftnref20" title=""><sup>[20]</sup></a>.</p>
	<p>Однако всё это - сами арифметические действия, а как ввести исходные данные 
	с клавиатуры или увидеть результат на экране? Для этого тоже можно предложить 
	ряд программ, например для ввода восьмеричного <span class="nmbr">6</span>-разрядного 
	числа с клавиатуры и вывода такого же числа на экран.</p>
	<pre><span class="cmmnt">; Подпрограмма ввода восьмеричных</span>
<span class="cmmnt">; чисел с клавиатуры</span>
<span class="cmmnt">; Окончание ввода числа - клавиша</span>
<span class="cmmnt">; &quot;ВВОД&quot;, число - в R4</span>
<span class="labl">INP</span>:    <span class="cmds">CLR</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Очистить буфер числа</span>
<span class="locl">1</span>:      <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Ввод очередного</span>
                                    <span class="cmmnt">; символа</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Выдать символ на</span>
                                    <span class="cmmnt">; экран</span>
        <span class="cmds">CMPB</span>    #<span class="nmbr">12</span>,<span class="regn">R0</span>              <span class="cmmnt">; Символ &quot;ВВОД&quot;?</span>
        <span class="cmds">BEQ</span>     <span class="locl">2</span>                   <span class="cmmnt">; Да - выход</span>
        <span class="cmds">ASL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Иначе - продвинуть</span>
        <span class="cmds">ASL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; предыдущее число</span>
        <span class="cmds">ASL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; в старший разряд</span>
        <span class="cmds">SUB</span>     #<span class="nmbr">60</span>,<span class="regn">R0</span>              <span class="cmmnt">; Перевести код</span>
                                    <span class="cmmnt">; символа в число</span>
        <span class="cmds">ADD</span>     <span class="regn">R0</span>,<span class="regn">R4</span>               <span class="cmmnt">; Записать число в</span>
                                    <span class="cmmnt">; буфер</span>
        <span class="cmds">BR</span>      <span class="locl">1</span>                   <span class="cmmnt">; Ввод следующего</span>
                                    <span class="cmmnt">; символа</span>
<span class="locl">2</span>:      <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span></pre>
	<p>Программа эта простейшая и поэтому не лишена недостатков. Например, она не 
	защищена от ввода нецифровых символов, не допускает исправлений, при вводе более 
	чем шести символов действительны только последние шесть и т.д. При желании программу 
	нетрудно дополнить всеми необходимыми сервисными функциями.</p>
	<pre><span class="cmmnt">; Подпрограмма вывода на экран</span>
<span class="cmmnt">; восьмеричных чисел в коде КОИ-8</span>
<span class="cmmnt">; Исходное число - в регистре R4</span>
<span class="labl">OUT</span>:    <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Очистить буфер цифры</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">6</span>,<span class="regn">R5</span>               <span class="cmmnt">; Цикл чтения 6</span>
                                    <span class="cmmnt">; разрядов</span>
        <span class="cmds">BR</span>      <span class="locl">2</span>                   <span class="cmmnt">; Чтение старшего</span>
                                    <span class="cmmnt">; разряда числа</span>
<span class="locl">1</span>:      <span class="cmds">CLR</span>     <span class="regn">R0</span>                  <span class="cmmnt">; Очистить буфер цифры</span>
        <span class="cmds">ROL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; Переслать 3-разрядное</span>
        <span class="cmds">ROL</span>     <span class="regn">R0</span>                  <span class="cmmnt">; двоичное число,</span>
        <span class="cmds">ROL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; определяющее</span>
                                    <span class="cmmnt">; очередную</span>
        <span class="cmds">ROL</span>     <span class="regn">R0</span>                  <span class="cmmnt">; восьмеричную цифру,</span>
<span class="locl">2</span>:      <span class="cmds">ROL</span>     <span class="regn">R4</span>                  <span class="cmmnt">; в буфер</span>
        <span class="cmds">ROL</span>     <span class="regn">R0</span>                  <span class="cmmnt">; цифры</span>
        <span class="cmds">ADD</span>     #<span class="nmbr">60</span>,<span class="regn">R0</span>              <span class="cmmnt">; Перевести число в ;код КОИ-8</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; Выдать цифру на экран</span>
        <span class="cmds">SOB</span>     <span class="regn">R5</span>,<span class="locl">1</span>                <span class="cmmnt">; Цикл чтения разрядов</span>
        <span class="cmds">RET</span>                         <span class="cmmnt">; Выход</span></pre>
	<p>Эта программа также может быть усовершенствована. Например, иногда необходимо 
	вместо незначащих нулей впереди числа выдавать пробелы, вместо числа без знака 
	выводить число со знаком, интерпретируя его код как дополнительный, и т.п. Ценой 
	некоторых (но не слишком больших!) усилий программиста все эти задачи могут 
	быть решены. Часто нужен ввод и вывод не восьмеричных, а десятичных чисел. Реализовать 
	такие программы несколько сложнее, но также вполне возможно. Вообще, как говорится, &laquo;<i>лиха 
	беда начало</i>&raquo;, и автор ничуть не сомневается, что читатели очень быстро 
	добьются в программировании на ассемблере значительно больших успехов, чем он 
	сам.</p>
	<p>Можно отметить, что программы, вполне аналогичные двум последним, имеются 
	в ПЗУ БК-0010. Например, подпрограмма ввода восьмеричного числа с клавиатуры 
	имеется в ПЗУ монитор-драйверной системы, адрес обращения к ней -
	<span class="nmbr">100472</span>. Она заносит число в регистр
	<span class="regn">R5</span> и отличается от приведённой программы
	<span class="labl">INP</span> тем, что ввод любого &laquo;<i>невосьмеричного</i>&raquo; 
	символа сбрасывает набранное число, так что набор нужно повторять. Эту подпрограмму 
	можно применять во всех случаях, ведь ПЗУ МДС в БК-0010 имеется всегда. А вот 
	подпрограмма вывода восьмеричного числа, хранящегося в <span class="regn">R4</span>, 
	имеется только в тест-ПЗУ по адресу <span class="nmbr">163220</span> и при его 
	отсутствии (без блока МСТД на БК-0010.01) программы с её использованием работать 
	не будут. Ясно, что её применение не всегда корректно.</p>
	<p>В результате разработки (обычно по мере необходимости) различных программ 
	у каждого программиста не только появляются свои излюбленные приёмы, &laquo;<i>фокусы</i>&raquo; 
	и прочее, определяющие так называемый &laquo;<i>почерк</i>&raquo; программиста 
	(чего почти лишены программы на языках высокого уровня), но и постепенно накапливаются 
	библиотеки стандартных подпрограмм, подобных приведённым выше. Они могут быть 
	использованы в разных программах по мере надобности, а хранить их лучше на МЛ 
	отдельно, в виде листингов. Возможности ассемблера &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	(других - в меньшей степени) позволяют при необходимости &laquo;<i>догрузить</i>&raquo; 
	нужный программный модуль и &laquo;<i>переставить</i>&raquo; его в требуемое 
	место программы, тем самым избавляя программиста от труда вводить его заново. 
	Поэтому рекомендуется снабжать каждый такой модуль-подпрограмму уникальной меткой-именем, 
	как это и сделано в наших примерах<a href="#_ftn21" name="_ftnref21" title=""><sup>[21]</sup></a>.</p>
	<h3><a name="toc_50"></a>Контрольные вопросы и задания</h3>
	<ol id="ctrlq">
		<li>Принесло ли вам пользу знакомство с ячейками системной области БК-0010?
		<ul id="ctrla">
			<li>
			<p>Каждый отвечает так, как считает нужным.</p>
			</li>
		</ul>
		</li>
		<li>Напишите программу генератора случайных чисел, использующую системный 
		таймер БК-0010. Выдача каждого следующего числа на экран должна происходить 
		при нажатии клавиши, причём использовать <span class="cmds">EMT</span>
		<span class="nmbr">6</span> для ожидания нажатия нельзя - найдите другой 
		приём. Диапазон выдаваемых случайных чисел - от <span class="nmbr">0</span> 
		до <span class="nmbr">377</span><a href="#_ftn22" name="_ftnref22" title=""><sup>[22]</sup></a>.
		<ul id="ctrla">
			<li>
			<pre>        <span class="labl">OUT</span>=<span class="nmbr">163220</span>                  <span class="cmmnt">; Адрес подпрограммы</span>
                                    <span class="cmmnt">; вывода</span>
        <span class="labl">RT1</span>=<span class="nmbr">177706</span>                  <span class="cmmnt">; Регистры</span>
        <span class="labl">RT2</span>=<span class="nmbr">177710</span>                  <span class="cmmnt">; системного</span>
        <span class="labl">RT3</span>=<span class="nmbr">177712</span>                  <span class="cmmnt">; таймера</span>
        <span class="labl">SWU</span>=<span class="nmbr">177716</span>                  <span class="cmmnt">; Регистр системных</span>
                                    <span class="cmmnt">; устройств</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">377</span>,<span class="labl">RT1</span>            <span class="cmmnt">; Исходное</span>
                                    <span class="cmmnt">; число счётчика</span>
        <span class="cmds">MOV</span>     #<span class="nmbr">20</span>,<span class="labl">RT3</span>             <span class="cmmnt">; Множитель &quot;xl&quot;</span>
<span class="locl">0</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">100</span>,<span class="labl">SWU</span>            <span class="cmmnt">; Клавиша</span>
                                    <span class="cmmnt">; нажата?</span>
        <span class="cmds">BNE</span>     <span class="locl">0</span>                   <span class="cmmnt">; Нет - ждать</span>
<span class="locl">1</span>:      <span class="cmds">BIT</span>     #<span class="nmbr">100</span>,<span class="labl">SWU</span>            <span class="cmmnt">; Клавиша</span>
                                    <span class="cmmnt">; отпущена?</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; Нет - ждать</span>
        <span class="cmds">MOV</span>     <span class="labl">RT2</span>,<span class="regn">R4</span>              <span class="cmmnt">; Извлечь число</span>
                                    <span class="cmmnt">; из счётчика</span>
        <span class="cmds">CALL</span>    <span class="labl">OUT</span>                 <span class="cmmnt">; Выдать число</span>
                                    <span class="cmmnt">; на экран</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Программа</span>
                                    <span class="cmmnt">; зациклена</span>
        <span class="pscm">END</span></pre>
			<p>Обратите внимание, что все адреса ПЗУ и системных регистров заданы 
			с помощью операторов прямого присваивания.</p>
			</li>
		</ul>
		</li>
		<li>3 .Какой приём вы можете предложить для перевода восьмеричного числа 
		в десятичное?
		<ul id="ctrla">
			<li>
			<p>Простейший приём такой. Нужно вычислить значения &laquo;<i>круглых</i>&raquo; 
			десятичных чисел - <span class="nmbr">10</span>, <span class="nmbr">
			100</span>, <span class="nmbr">1000</span>, <span class="nmbr">10000</span> 
			в восьмеричном представлении и затем вычитать их из исходного числа, 
			начиная с самого большого для одного регистра - с <span class="nmbr">
			10000</span>, подсчитывая каждый раз количество вычитаний, пока ещё 
			нет переноса. Это количество, переведённое в код КОИ-<span class="nmbr">8</span> 
			(если его нужно выдать на экран), и будет десятичным разрядом. Затем 
			нужно восстановить остаток и продолжить вычитание уже следующего числа, 
			например <span class="nmbr">1000</span>, и так до <span class="nmbr">
			1</span>. (Восьмеричные эквиваленты приведённых десятичных чисел-
			<span class="nmbr">23420</span>, <span class="nmbr">1750</span>,
			<span class="nmbr">144</span>, <span class="nmbr">12</span>.)</p>
			</li>
		</ul>
		</li>
		<li>Написать программу, обеспечивающую перекодирование десятичного числа 
		из его текстовой записи (т.е. строки символов &laquo;<i>0</i>&raquo;..&laquo;<i>9</i>&raquo;, 
		вводимых один за другим с клавиатуры) в числовое содержимое регистра
		<span class="regn">R2</span>.
		<ul id="ctrla">
			<li>
			<pre><span class="labl">PAC</span>:    <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Очистить</span>
                                    <span class="cmmnt">; счётчик</span>
<span class="locl">0</span>:      <span class="cmds">EMT</span>     <span class="nmbr">6</span>                   <span class="cmmnt">; Очередной</span>
        <span class="cmds">EMT</span>     <span class="nmbr">16</span>                  <span class="cmmnt">; символ</span>
        <span class="cmds">CMPB</span>    #<span class="nmbr">12</span>,<span class="regn">R0</span>              <span class="cmmnt">; Окончание</span>
                                    <span class="cmmnt">; ввода?</span>
        <span class="cmds">BEQ</span>     <span class="locl">1</span>                   <span class="cmmnt">; Да!</span>
        <span class="cmds">SUB</span>     #<span class="nmbr">60</span>,<span class="regn">R0</span>              <span class="cmmnt">; ASCII-код -&gt;</span>
                                    <span class="cmmnt">; в цифру</span>
        <span class="cmds">BCS</span>     <span class="locl">2</span>                   <span class="cmmnt">; Код меньше</span>
                                    <span class="cmmnt">; нуля</span>
        <span class="cmds">CMP</span>     <span class="regn">R0</span>,#<span class="nmbr">12</span>              <span class="cmmnt">; Цифра?</span>
        <span class="cmds">BCC</span>     <span class="locl">2</span>                   <span class="cmmnt">; Нет, код</span>
                                    <span class="cmmnt">; больше девяти</span>
        <span class="cmds">ASL</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Число</span>
                                    <span class="cmmnt">; умножаем на 2</span>
        <span class="cmds">MOV</span>     <span class="regn">R2</span>,-(<span class="regn">SP</span>)            <span class="cmmnt">; Сохраняем</span>
        <span class="cmds">ASL</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Умножено на 4</span>
        <span class="cmds">ASL</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Умножено на 8</span>
        <span class="cmds">ADD</span>     (<span class="regn">SP</span>)+,<span class="regn">R2</span>            <span class="cmmnt">; Х*8+Х*2 =Х*10</span>
        <span class="cmds">ADD</span>     <span class="regn">R0</span>,<span class="regn">R2</span>               <span class="cmmnt">; Прибавить к ;счётчику</span>
        <span class="cmds">BR</span>      <span class="locl">0</span>                   <span class="cmmnt">; Продолжать</span>
<span class="locl">2</span>:      <span class="cmds">CLR</span>     <span class="regn">R2</span>                  <span class="cmmnt">; Если</span>
                                    <span class="cmmnt">; некорректно, то 0</span>
<span class="locl">1</span>:      <span class="cmds">RET</span>                         <span class="cmmnt">; и выход</span></pre>
			</li>
		</ul>
		</li>
	</ol>
	<h2><a name="toc_51"></a>Трансляция и компоновка</h2>
	<p>В своё время мы уже кратко познакомились с тем, как подготовить программу 
	к работе - оттранслировать и скомпоновать её, и обещали ещё раз вернуться к 
	этой теме. Так мы и сделаем, но напомним, что наше описание базируется на ассемблер-системе &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	и все приводимые далее адреса и директивы относятся прежде всего к ней. Для 
	прочих версий они могут отличаться от указанных, хотя принципы работы те же 
	самые.</p>
	<p>Пусть у нас написан текст программы на языке ассемблера. В его состав могут 
	входить:</p>
	<ul>
		<li>операторы прямого присваивания,</li>
		<li>метки,</li>
		<li>операторы,</li>
		<li>операнды с различными способами адресации,</li>
		<li>псевдооператоры с наборами символов,</li>
		<li>комментарии.</li>
	</ul>
	<p>Весь этот чрезвычайно разнородный материал (размещённый в памяти по адресам
	<span class="nmbr">17001</span>...<span class="nmbr">37000</span>) ассемблер 
	должен превратить в программу в машинных кодах, готовую к исполнению, - <b>загрузочный 
	модуль</b>, - &laquo;<i>собрать</i>&raquo; из них программу. Отсюда и название 
	системы: &laquo;<i>ассемблер</i>&raquo; означает &laquo;<i>собиратель</i>&raquo;. 
	В общих чертах мы уже знаем, как это делается, но рассмотрим этот процесс подробнее.</p>
	<p>Обычно любой ассемблер выполняет трансляцию за два <b>прохода</b> (или просмотра) 
	исходного листинга программы. Первый проход называется <b>трансляцией</b> и 
	может сам состоять из ряда операций, но проще рассматривать его как одно целое.</p>
	<p>Запуск транслятора осуществляется из его встроенного монитора по директиве &laquo;<i>СО</i>&raquo;. 
	В процессе трансляции производится перевод текста программы в машинные коды 
	и присваивание меткам определённых адресов. По мере перевода текста в машинные 
	коды производится запись последних в память ЭВМ (начиная с адреса
	<span class="nmbr">13000</span>), и встречающиеся по ходу трансляции метки располагаются 
	уже не просто в определённых строках программы, а по определённым физическим 
	адресам. Эти адреса (вместе с именами меток в коде RADIX-50) заносятся в <b>
	таблицу меток</b>, формируемую с адреса <span class="nmbr">40000</span> &laquo;<i>вниз</i>&raquo;, 
	т.е. в сторону меньших адресов. Если меток очень много, таблица может стать 
	слишком длинной и затереть при трансляции конец текста программы раньше, чем 
	он будет прочитан транслятором. Естественно, при этом возникает ошибка и трансляция 
	прекращается. Избежать чрезмерного роста таблицы можно путём широкого использования
	<b>локальных</b> меток, так как таблица локальных меток формируется отдельно 
	и существует в памяти только до появления очередной обычной метки.</p>
	<p>Если всё-таки таблица меток затирает текст (его на всякий случай перед трансляцией 
	нужно всегда записывать на МЛ), то такую программу оттранслировать невозможно, 
	её необходимо либо разделить на части, либо перейти в режим &laquo;<i>РП</i>&raquo;. 
	Любая версия ассемблера &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	рассчитана на работу в этом режиме (кроме редактирования текста), а в последних 
	версиях - &laquo;<i>МИКРО.<span class="nmbr">10</span>К-РП</i>&raquo; и &laquo;<i>МИКРО.<span class="nmbr">10</span>-<span class="nmbr">01</span>К</i>&raquo; 
	в режиме &laquo;<i>РП</i>&raquo; работает и редактор. В этом режиме можно транслировать 
	также тексты программ, составленные из нескольких частей, &laquo;<i>сливая</i>&raquo; 
	их друг с другом путём догрузки директивой &laquo;<i>LF</i>&raquo; Естественно, 
	что при этом оператор <span class="pscm">END</span> должен стоять только в конце 
	последнего блока, а общая длина текста может достигать <span class="nmbr">50000</span>. 
	Во многих случаях такое слияние текстов программ значительно удобнее компоновки 
	через объектные модули, о котором речь пойдёт дальше. Чтобы ассемблер нормально 
	работал в режиме &laquo;<i>РП</i>&raquo;, его необходимо либо запустить в этом 
	режиме с адреса <span class="nmbr">1000</span>. либо, перейдя в режим &laquo;<i>РП</i>&raquo; 
	в мониторе, дать команду &laquo;<i>RS</i>&raquo; (версия &laquo;<i>МИКРО.<span class="nmbr">10</span>К-РП</i>&raquo; 
	в этом не нуждается - достаточно перейти в режим &laquo;<i>РП</i>&raquo; в мониторе 
	ассемблер-системы). Текст программы в памяти при этом, конечно, будет уничтожен. 
	В режиме &laquo;<i>РП</i>&raquo; таблица меток формируется с адреса
	<span class="nmbr">70000</span>.</p>
	<p>В результате трансляции (первого прохода) образуется так называемый <b>объектный 
	модуль</b>. Он представляет собой программу в машинных кодах, в которую занесено 
	всё необходимое, кроме некоторых операндов, под которые ячейки памяти только
	<b>зарезервированы</b>. Дело в том, что при первом проходе транслятор ещё &laquo;<i>не 
	знает</i>&raquo; реальных физических адресов меток, ведь таблица только формируется, 
	поэтому и не может записать операнды, обращение к которым требует знания этих 
	адресов. Такие операнды, ячейки под которые зарезервированы (туда заносятся 
	нули), транслятор отмечает в выдаваемой на экран по окончании трансляции таблице 
	меток инверсией, с указанием адресов зарезервированных ячеек и имён меток, входящих 
	в состав операнда. Наличие в таблице после трансляции инверсных меток однозначно 
	свидетельствует, что программа неперемещаема и нуждается в <b>компоновке</b> 
	- это второй проход транслятора. Объектный модуль. полученный при трансляции, 
	может быть после неё записан на МЛ директивой &laquo;<i>SL</i>&raquo;, при этом 
	вместе с ним записывается и таблица меток. Ассемблер даёт возможность загрузить 
	с МЛ и скомпоновать вместе несколько объектных модулей, что позволяет получить 
	(в режиме &laquo;<i>РП</i>&raquo;, разумеется) загрузочный модуль длиной до
	<span class="nmbr">16</span> кб. Но пока рассмотрим случай, когда у нас один 
	модуль.</p>
	<p>Итак, объектный модуль в памяти, таблица меток - на экране (если таблица 
	меток занимает более <span class="nmbr">24</span> строк в обычном режиме или 
	более четырёх строк в режиме &laquo;<i>РП</i>&raquo;, её выдача на экран производится 
	по частям, с остановками до нажатия любой клавиши). Раз в таблице есть инверсные 
	метки, значит, программа нуждается в компоновке. При компоновке не только производится 
	вычисление и запись в загрузочный модуль недостающих операндов. но и <b>задание 
	адреса загрузки</b>, т.е. того адреса, по которому программа будет загружаться 
	и работать в дальнейшем. Этот адрес может быть задан любым, ассемблер внесёт 
	соответствующие поправки во все адреса меток программы, как бы &laquo;<i>переместив</i>&raquo; 
	её в памяти (в действительности загрузочный модуль остаётся на месте, по адресу
	<span class="nmbr">13000</span>), поэтому наш ассемблер называется <b>перемещающим</b>. 
	Директива &laquo;<i>LL</i>&raquo; задаёт компоновку <b>по умолчанию</b> - по 
	последнему указанному ранее адресу (после запуска ассемблера это адрес
	<span class="nmbr">1000</span>), а директива &laquo;<span class="selc">LS</span>&raquo; 
	запрашивает новый адрес компоновки у пользователя. После окончания компоновки 
	инверсных меток в таблице (она выдаётся на экран заново) не должно остаться, 
	а если они всё же есть, значит, в программе имеются ошибки. Это либо неопределённые 
	метки (т.е. обращение к метке есть, а её самой нет), либо обращение к локальной 
	метке &laquo;<i>через обычную</i>&raquo; (в скобках заметим, что такое обращение &laquo;<i>вперёд</i>&raquo; 
	допустимо, но лучше его избегать. это только запутывает программу).</p>
	<p>После того как получен загрузочный модуль (в таблице меток нет инверсных 
	имён), его можно записать на МЛ директивой &laquo;<i>SA</i>&raquo;. При этом 
	учтите, что располагается он с адреса <span class="nmbr">13000</span> независимо 
	от заданного адреса компоновки, с этим начальным адресом он и будет записан 
	на МЛ. При загрузке такой программы для работы нужно всегда явно задавать адрес 
	загрузки, если он отличается от <span class="nmbr">13000</span>, а так как удобнее 
	грузить программу &laquo;<i>по умолчанию</i>&raquo;, то лучше сразу переслать 
	её директивами МСД по нужному адресу, а потом уже записать на МЛ, для чего надо 
	выйти из ассемблера, нажав клавишу &laquo;<i>СТОП</i>&raquo;. Длина загрузочного 
	модуля выдаётся при трансляции и компоновке вместе с таблицей меток, адрес тоже 
	известен - <span class="nmbr">13000</span>, так что переслать программу по необходимому 
	адресу и затем записать её на МЛ не составит труда, только для этого надо выйти 
	в МСД (значит, блок МСТД должен быть заранее подключён, а способ перехода в 
	МСД, если вы загружали &laquo;МИКРО&raquo; из ПМ, уже приводился).</p>
	<p>Можно также сразу запустить загрузочный модуль на исполнение директивой &laquo;<i>RU</i>&raquo;. 
	при этом управление просто передаётся по адресу <span class="nmbr">13000</span>. 
	Учтите только, что для этого компоновка должна быть произведена именно по этому 
	адресу, а ассемблер в памяти вполне может быть испорчен (&laquo;<i>затёрт</i>&raquo;) 
	работающей программой. Такой приём (прямой запуск) часто используется для отладки, 
	иногда специально для этого даже изменяют некоторые параметры программы, чтобы 
	она могла работать по адресу <span class="nmbr">13000</span> без затирания ассемблер-системы. 
	Это действительно очень удобно: запустив программу по &laquo;<i>RU</i>&raquo; 
	и проверив результаты её работы, можно вернуться в ассемблер-систему по &laquo;<i>повторному 
	входу</i>&raquo; (адрес запуска <span class="nmbr">1002</span>), войти в редактор, 
	внести в текст изменения, снова оттранслировать и скомпоновать, вновь запустить 
	и т.д., пока работа программы не будет удовлетворительной. Затем можно внести 
	в текст программы окончательные изменения для работы по нужному адресу и скомпоновать 
	её, задав этот адрес. Такая методика отладки особенно удобна, если длина загрузочного 
	модуля невелика (до <span class="nmbr">4000</span>) и он не затирает при трансляции 
	начало текста программы, - это не сложнее отладки программ на Бейсике или Фокале.</p>
	<p>А как быть, если программа длиннее и её текст не помещается в памяти ни в 
	обычном режиме, ни в &laquo;<i>РП</i>&raquo;? Тогда её нужно разделить на несколько 
	частей, по возможности таких, чтобы их можно было отладить отдельно. После проверки 
	каждой части её транслируют и записывают объектный модуль на МЛ. Каждая часть 
	при этом должна содержать в начале необходимые операторы прямого присваивания 
	(относящиеся к меткам, используемым в ней), а в конце оператор
	<span class="pscm">END</span>.</p>
	<p>Когда получены и записаны на МЛ все необходимые объектные модули программы, 
	даём директиву &laquo;<i>LA</i>&raquo;, указываем адрес компоновки и загружаем 
	первый модуль. В дальнейшем грузим остальные модули по команде &laquo;<i>LI</i>&raquo;. 
	Каждый вновь загруженный модуль компонуется с уже имеющимися в памяти. После 
	загрузки всех модулей (непременно в том порядке. в котором они должны входить 
	в программу!) загрузочный модуль готов, его можно записать на МЛ или запустить. 
	Перед компоновкой модулей с МЛ нужно перезапустить ассемблер командой &laquo;<i>RS</i>&raquo;.</p>
	<h3><a name="toc_52"></a>Ошибки при программировании на ассемблере</h3>
	<p>Синтаксические ошибки в тексте программы выявляются обычно на этапе трансляции. 
	При этом трансляция прекращается, на экран выдаётся строка с ошибкой и запрос: &laquo;<span class="strn">Е,С?</span>&raquo;, 
	т.е. &laquo;перейти к месту ошибки или продолжить?&raquo;. Команда &laquo;<i>С</i>&raquo; 
	вызывает продолжение трансляции независимо от того, что строка с ошибкой оттранслирована 
	не будет. Это может потребоваться для выявления остальных ошибок или для иных 
	целей. В конце такой трансляции таблица меток не выдаётся. Команда &laquo;<i>Е</i>&raquo; 
	вызывает переход в редактор, при этом курсор указывает на место ошибки. Если 
	это &laquo;<i>ошибка 3</i>&raquo; (велика длина перехода), то указывается не 
	метка, при переходе к которой допущено превышение длины перехода в
	<span class="cmds">SOB</span>, <span class="cmds">BR</span> или другом операторе 
	ветвления, а сам оператор, т.е. источник обращения. В некоторых версиях &laquo;<i>МИКРО.<span class="nmbr">10</span>К&raquo;</i> 
	была введена &laquo;<i>ошибка 15</i>&raquo; (затирание текста программы при 
	трансляции). Но нужно сказать, что эта ошибка только констатирует факт, но не 
	защищает текст от затирания, так как она выдаётся <b>после</b> трансляции последнего 
	оператора и при этом часть текста неизбежно затирается. Но если это был обычный 
	оператор, затёртой окажется небольшая часть текста, которую легко восстановить. 
	Если же последним был, например, оператор <span class="pscm">.+</span><span class="nmbr">10000</span>, 
	то будет утерян текст длиной <span class="nmbr">10000</span>, несмотря на останов 
	по ошибке. Обычная реакция на эту ошибку - команда &laquo;<i>С</i>&raquo;, при 
	этом трансляция идёт нормально до конца. В версиях &laquo;<i>РП</i>&raquo; &laquo;<i>ошибка 
	15</i>&raquo; исключена, зато добавлена &laquo;<i>ошибка 12</i>&raquo; - переопределение 
	локальной метки, которая раньше не индицировалась и доставляла много хлопот.</p>
	<p>Не совсем приятная ошибка - обращение к неопределённой локальной метке. При 
	этом в таблице меток возникает путаница - появляются инверсные метки без имени, 
	а только с адресом, или метки с именами, которых нет в тексте. Но если знать 
	эти характерные признаки данной ошибки, найти её не так сложно.</p>
	<p>Сложнее дело обстоит с логическими ошибками, когда программа формально написана 
	правильно, но работает не так. как ожидалось. В этом случае, если обычный просмотр 
	текста и проверка алгоритма не выявляют ошибок, следует разбить программу на 
	функциональные блоки и проверять их по отдельности. Частая ошибка - неправильное 
	ветвление программы. Она может быть вызвана непониманием логики работы программы, 
	неправильным оператором (например, применение оператора &laquo;<i>со знаком</i>&raquo;, 
	когда нужен &laquo;<i>без знака</i>&raquo;) или ошибками при сравнении операндов. 
	На последнем случае стоит остановиться подробнее.</p>
	<p>Когда ветвление задаётся после оператора сравнения, то оно может происходить 
	неправильно по следующим причинам:</p>
	<ul>
		<li>неправильный порядок записи операндов (нужно помнить, что при сравнении 
		из <b>первого</b> операнда вычитается <b>второй</b>, а при вычитании - наоборот);</li>
		<li>сравнение слов, когда надо сравнивать байты, и наоборот;</li>
		<li>искажение одного из сравниваемых операндов за счет <b>распространения 
		знака</b> после выполнения оператора <span class="cmds">MOVB</span> с одним 
		из регистров;</li>
		<li>использование оператора ветвления с иной, чем нужно, логикой работы, 
		например <span class="cmds">BLO</span> вместо <span class="cmds">BLOS</span>,
		<span class="cmds">BGT</span> вместо <span class="cmds">BGE</span>,
		<span class="cmds">BEQ</span> вместо <span class="cmds">BNE</span> и т.п.;</li>
		<li>недооценка возможного диапазона представления операндов, например когда 
		при возрастании операнда происходит переполнение и изменение знака.</li>
	</ul>
	<p>Кроме перечисленных возможны, конечно, и другие причины, но эти - самые распространённые. 
	Не менее частая причина ошибок ветвления - передача управления &laquo;<i>не 
	туда</i>&raquo;, т.е. когда соответствующая метка находится не на том месте, 
	где должна бы быть. Например в цикле может всё время повторно заноситься исходное 
	значение цикловой переменной, обнуляться регистры или повторно задаваться исходный 
	адрес массива и т.д.</p>
	<p>Уточнить, как именно происходит ветвление и где программа &laquo;<i>зацикливается</i>&raquo;, 
	а также отследить прочие &laquo;<i>сомнительные точки</i>&raquo; можно разными 
	приёмами. Нагляднее и проще всего на время включать в текст программы в точках 
	перехода по ветвлению операторы действие которых сразу заметно:
	<span class="cmds">HALT</span>, звуковой сигнал, выдача на экран каких-либо 
	символов и пр. Можно временно исключать из текста отдельные строки, &laquo;<i>закрывая</i>&raquo; 
	их знаком комментариев (поставив в первой позиции символ &laquo;<span class="symb">;</span>&raquo; 
	или вписав в начале строки оператор <span class="cmds">NOP</span>), можно заменять 
	операторы условного ветвления на безусловные и т.п.</p>
	<p>Можно прибегнуть и к помощи отладчика. При пошаговой работе программы можно 
	наблюдать содержимое регистров и т.д. Особенно интересен &laquo;<i>ОТЛАДЧИК.К</i>&raquo;
	<em>С.А. Кумандина</em>, который позволяет, кроме регистров, задать индикацию 
	ещё до пяти произвольных ячеек памяти, имеет <b>RADIX-дамп</b> и прочие сервисные 
	функции. При работе с любым отладчиком затруднение нередко вызывает то, что 
	командные прерывания <span class="cmds">EMT</span> и <span class="cmds">TRAP</span> 
	отрабатываются как одна команда. Это происходит потому, что при прерывании ССП 
	заменяется и <span class="symb">T</span>-разряд сбрасывается. Как сделать эти 
	команды &laquo;<i>видимыми</i>&raquo; при отладке, мы уже обсуждали ранее: чтобы 
	посмотреть, что делается &laquo;<i>внутри</i>&raquo; прерывания, нужно предварительно 
	записать во втором слове вектора данного прерывания ССП с установленным
	<span class="symb">T</span>-разрядом. Но, вообще говоря, возможности любого 
	отладчика довольно ограниченны и эта &laquo;<i>техника</i>&raquo; (во всяком 
	случае, по мнению автора) более подходит для того, чтобы &laquo;<i>копаться</i>&raquo; 
	в чужих программах, а не для отладки собственных.</p>
	<p>Когда программа в общих чертах отлажена и вроде бы работает так, как хотелось, 
	ещё нельзя считать работу оконченной. Программу необходимо протестировать. Если 
	она не очень сложная, нужно задавать такие исходные данные, чтобы (с учётом 
	логики обработки) были пройдены по возможности все ветви программы, и перебрать 
	все возможные комбинации данных. Сделать это тому, кто сам написал программу, 
	не так уж сложно, как кажется. Если трудно представить себе последовательность 
	обработки данных в сложной программе, можно ограничиться заданием трёх значений 
	для каждого вида входной информации: двух крайних и одного произвольно выбранного 
	в середине диапазона (речь идёт не только о числовых данных, но и, например, 
	о директивах, позициях меню и т.п.). Если диапазон входных данных ограничен, 
	необходимо задать ещё как минимум два их значения за пределами диапазона с обеих 
	сторон. Но, несмотря на все ухищрения, исчерпывающая проверка сложной программы 
	невозможна в принципе и зачастую только после длительной эксплуатации выявляются 
	ошибки, не обнаруженные в процессе отладки. Такая ошибка всегда очень неприятна, 
	прежде всего потому, что программист уже успел забыть детали реализации алгоритма, 
	ему трудно снова &laquo;<i>вжиться</i>&raquo; в программу и сообразить, что 
	именно привело к ошибке. В этих случаях нельзя переоценить значение сохранения 
	листинга с подробными комментариями, особенно если данная программа не единственная 
	разработка программиста. Поэтому лишние пять минут, потраченные на написание 
	комментариев, могут в будущем сберечь вам многие часы и даже дни работы. Вероятность 
	же такой ситуации очень велика, ибо давно известное шуточное правило гласит: &laquo;Всякая 
	отлаженная программа содержит как минимум одну ошибку. Исключением является 
	только программа, состоящая из единственного оператора <span class="pscm">END</span>&raquo;.</p>
	<h3><a name="toc_53"></a>Позиционно-независимое программирование</h3>
	<p>Обычно программа, написанная на языке ассемблера, предназначена для работы 
	в определённой зоне адресов. Но есть программы, которые просто обязаны работать 
	по любым адресам: это отладчики, дизассемблеры, супервизорные драйверы и прочие &laquo;<i>инструменты</i>&raquo;. 
	нужные не сами по себе, а для работы с другими программами. При этом заранее 
	неизвестно, где будет расположена программа, нуждающаяся в отладке или дизассемблировании, 
	поэтому мы вынуждены размещать инструментальную или системную программу &laquo;<i>на 
	свободном месте</i>&raquo;. Как добиться перемещаемости программ? Для этого 
	следует придерживаться ряда принципов, носящих название принципов <b>позиционно</b>-<b>независимого 
	программирования</b><a href="#_ftn23" name="_ftnref23" title=""><sup>[23]</sup></a>.</p>
	<ul>
		<li>Все адреса переходов и обращений к тексту программы надо задавать только 
		путём относительной адресации, в виде меток.</li>
		<li>Все буферы данных внутри программы нужно выделять тоже путём относительной 
		адресации, по меткам, т.е. делать их перемещаемыми.</li>
		<li>Ко всем ячейкам ПЗУ и системной области необходимо обращаться только 
		по абсолютным адресам или по меткам, которые определены оператором прямого 
		присваивания.</li>
		<li>Не выделяйте в ОЗУ (кроме системной области) буферы и ячейки с абсолютными 
		адресами. так как при размещении программы в этой зоне она может быть затёрта 
		собственным буфером.</li>
		<li>Если необходимо определить физический адрес обращения к ОЗУ (или к ячейкам 
		в самой программе), например при задании векторов прерываний, адресов текстовых 
		сообщений и т.п., то вычислять эти адреса нужно пользуясь псевдооператором &laquo;<span class="pscm">.@</span>&raquo;.</li>
		<li>Старайтесь чаще использовать регистры общего назначения, стек и косвенную 
		адресацию через регистры и метки, что обеспечивает независимость от адресов 
		размещения программы.</li>
	</ul>
	<p>Перечень этих принципов читатель может продолжить самостоятельно.</p>
	<p>Признаком <b>перемещаемости</b> является то, что программа не нуждается в 
	компоновке. Т.е. таблица меток, выданная транслятором (после первого прохода), 
	не содержит инверсных имён (хотя это и не абсолютная гарантия перемещаемости!). 
	Перемещаемые программы обычно занимают заметно больше места в ОЗУ, чем неперемещаемые, 
	и несколько сложнее по структуре, поэтому стремление делать перемещаемыми все 
	программы вряд ли оправдано.</p>
	<p>Особый случай - размещение программы в ПЗУ. Обычной перемещаемости здесь 
	недостаточно, нужно ещё позаботиться о том, чтобы внутри программы не было никаких 
	переменных. буферов данных и т.п. Кроме того, если такая программа рассчитана 
	на работу как в ОЗУ, так и в ПЗУ и предназначена для работы в реальном времени, 
	необходимо учитывать, что одна и та же программа при размещении в ПЗУ работает 
	на <span class="nmbr">10</span>-<span class="nmbr">30</span>% <b>быстрее</b>, 
	чем в ОЗУ пользователя. Например, для драйвера магнитофона эта разница может 
	оказаться критической, если не предусмотрены специальные меры, обеспечивающие 
	приемлемый эффект при изменении скорости работы Лучше всего, чтобы после запуска 
	программа сама определяла, где она находится. и в соответствии с этим организовывала 
	свои буферы данных, самозащиту, регулировала скорость работы и т.п.</p>
	<h2><a name="toc_54"></a>Схемотехника БК-0010</h2>
	<p>У определённой части пользователей персональных компьютеров существует устойчивый 
	интерес к схемотехнике и электронике. Оправдан ли этот интерес применительно 
	к БК? Стоит ли изучать схемотехнику этого компьютера, и если да, то для чего?</p>
	<p>Во-первых, любая техника рано или поздно выходит из строя. Хотя сервисная 
	сеть по ремонту БК-0010 и существует, воспользоваться её услугами иной раз довольно 
	сложно (скажем, для пользователей, живущих на периферии). Зная же основы схемотехники 
	БК, можно попытаться сделать это самостоятельно<a href="#_ftn24" name="_ftnref24" title=""><sup>[24]</sup></a>. 
	Однако сразу следует оговориться, что начинающим пользователям не стоит даже 
	пытаться это сделать. Такая возможность открыта лишь для опытных радиолюбителей 
	и для профессионалов в области микросхемотехники. Помимо теоретических знаний, 
	отсутствующих у подавляющего большинства пользователей БК (наивно думать, что 
	эта статья позволит приобрести их в нужном объёме), имеется ещё масса &laquo;<i>тонкостей</i>&raquo; 
	чисто практического свойства, известных лишь тем, кто работал с микропроцессорной 
	техникой. Существует также множество приёмов проверки и отладки микроэлектронных 
	схем, научить которым &laquo;<i>заочно</i>&raquo; вообще невозможно, их каждый 
	приобретает самостоятельно лишь после многих лет практической работы: опытный 
	ремонтник &laquo;<i>чувствует</i>&raquo; неисправность, даже порой не отдавая 
	себе отчёта, каким образом это у него получается. Итак, в смысле возможностей 
	ремонта БК эта часть книги полезна только тем, кто <b>может ею воспользоваться</b>. 
	Всегда помните древнейшую поговорку: &laquo;То, что позволено Юпитеру, не позволено 
	быку&raquo; - и правильно оценивайте свои силы. То же самое замечание в полной 
	мере относится и к случаю подключения к БК-0010 дополнительных устройств (дисковода, 
	принтера, дополнительной памяти и т.п.)<a href="#_ftn25" name="_ftnref25" title=""><sup>[25]</sup></a>.</p>
	<p>Во-вторых, этот материал может оказаться полезным при изучении других ЭВМ 
	с аналогичной организацией (&laquo;<i>Электроника-60</i>&raquo; или <i>ДВК</i>), 
	станков с числовым программным управлением и т.п.</p>
	<p>И наконец, кто знает, не послужит ли для кого-либо этот раздел стимулом, 
	который приведёт в дальнейшем к &laquo;<i>большой электронике</i>&raquo;? Словом, 
	данный материал будет полезен &laquo;<i>для общего развития</i>&raquo;.</p>
	<p>Было бы безнадёжным пытаться изложить схемотехнику БК-0010 &laquo;<i>корректно</i>&raquo;, 
	т.е. с введением и объяснением терминологии, описанием работы отдельных схем, 
	узлов и т.п. - это потребовало бы нескольких книг. Поэтому всех интересующихся 
	подробностями приходится отослать к обширной литературе по радиоэлектронике 
	(список литературы см. в №<span class="nmbr">1</span> за <span class="nmbr">
	1994</span> г.). После всех этих оговорок приступим к описанию схемы БК-0010. 
	Оно будет основано на принципиальной схеме компьютера, опубликованной в журнале &laquo;<i>Информатика 
	и образование</i>&raquo;, №<span class="nmbr">4</span> за <span class="nmbr">
	1990</span> г., с. <span class="nmbr">74</span>-<span class="nmbr">77</span>, 
	а также в журнале &laquo;Персональный компьютер БК-0010 - БК-0011М&raquo;, №2 
	за <span class="nmbr">1994</span> г. Несмотря на наличие в ней значительного 
	количества неточностей и ошибок (впрочем, многие из них исправлены в схеме, 
	опубликованной в №2 за <span class="nmbr">1994</span> г.), это единственная 
	доступная пользователю схема БК-0010. Об отличиях схемы БК-0010.01 мы будем 
	упоминать по мере возможностей, они в основном незначительны и непринципиальны.</p>
	<p>БК-0010 выполнена на основе микропроцессорного набора серии К1801. Перечень 
	микросхем (МС) этого типа, выполненных по так называемой n-МОП технологии, включает 
	помимо нескольких видов ЦП набор специализированных микросхем-контроллеров. 
	Все они изготовлены на базе одной микросхемы, групповое название которой - К1801ВП1, 
	и отличаются связями логических элементов - своего рода &laquo;<i>микропрограммой</i>&raquo;, 
	зашитой в них в процессе изготовления. Каждому контроллеру присвоен свой порядковый 
	номер (например: К1801ВП1-<span class="nmbr">014</span>, К1801ВП1-<span class="nmbr">037</span>, 
	К1801ВП1-<span class="nmbr">128</span> и т.д.). Такая технология помимо узкой 
	специализации и, следовательно, высоких функциональных качеств каждого контроллера 
	(во всяком случае таковы они по мнению разработчиков, пользователи же с этим 
	мнением не всегда согласны) позволяет легко и без больших затрат расширять их 
	набор почти неограниченно.</p>
	<p>Все функциональные узлы (МС, блоки и т.п.) связаны в микро-ЭВМ линиями связи, 
	называемыми в совокупности <b>системной магистралью</b> (СиМ). Системная магистраль 
	имеет <span class="nmbr">16</span> линий &laquo;адрес-данные&raquo; (шина АД) 
	и ещё несколько &laquo;<i>служебных линий</i>&raquo; (СЛ) для передачи специальных 
	сигналов. Обмен по СиМ производится <b>асинхронно</b>. При таком виде обмена 
	каждое из входящих в систему устройств может быть включено в СиМ в произвольном 
	месте и работает самостоятельно, в своём временном режиме (&laquo;<i>ритме</i>&raquo;). 
	Все устройства, подключённые к СиМ, делятся на <b>активные</b> (способные занимать 
	и освобождать магистраль &laquo;<i>по своей воле</i>&raquo;) и <b>пассивные</b> 
	(вынужденные ждать, пока магистраль им будет предоставлена активным устройством). 
	Другими словами, активным считается устройство, способное самостоятельно инициировать 
	и осуществлять обмен по СиМ, а пассивным - устройство, работающее под &laquo;<i>надзором</i>&raquo; 
	активного. Активным устройством (АУс) в нашем компьютере является только ЦП, 
	все остальные устройства в его составе - пассивные. Каждое из пассивных устройств 
	(ПУс) имеет в общем адресном пространстве ЭВМ свой <b>адрес</b> (или группу 
	адресов), по которому к нему может обратиться АУс.</p>
	<p>Как же происходит обмен информацией по СиМ? В начале цикла обмена магистраль &laquo;<i>занята</i>&raquo; 
	АУс, в нашем случае ЦП. Он выставляет на шину АД СиМ адрес того ПУс, к которому 
	хочет обратиться. Если это системный регистр, то этот адрес будет для него единственным, 
	который вызывает реакцию, а если это, например, ОЗУ или ПЗУ, то при обращении 
	ко всей области адресов, обслуживаемой данным ПУс, его реакция будет одинаковой. 
	Выставив адрес, ЦП выдаёт по одной из СЛ специальный сигнал, называемый &laquo;<i>синхроимпульсом 
	активного устройства</i>&raquo; (СИА) или сигналом SYNC (синхронизация обмена). 
	Пассивное устройство, получив сигнал SYNC (он подаётся на все устройства ЭВМ 
	одновременно), фиксирует (обычно в специальном регистре) полученный по шине 
	АД адрес. Дальнейший порядок обмена зависит от того, что нужно сделать: передать 
	данные в ПУс (цикл <b>вывод</b>, или <b>запись</b>) или принять их от него (цикл 
	ВВОД, или <b>чтение</b>). В зависимости от этого ЦП почти одновременно с сигналом 
	SYNC выставляет на других СЛ ещё один из двух сигналов - DIN (ввод) или DOUT 
	(вывод). Рассмотрим сначала цикл ввода.</p>
	<p>Если принятый по сигналу SYNC адрес соответствует адресу данного ПУс, то 
	оно по отдельной СА выдаёт сигнал ответа, называемой синхроимпульсом пассивного 
	устройства (СИП) или сигналом RPLY. Получив его. ЦП уже знает, что вызов получен 
	адресатом. А что случится, если вызываемое ПУс отсутствует в составе ЭВМ или 
	попросту неисправно? Неужели ЦП будет ждать до бесконечности, и работа ЭВМ на 
	этом бесславно завершится? Конечно нет! ЦП будет ждать ровно столько, сколько 
	положено (а именно <span class="nmbr">64</span> такта специальной, подаваемой 
	на него опорной, или тактовой, частоты), а затем выполнит переход по вектору
	<span class="nmbr">4</span>, тем самым констатируя, что вызываемое ПУс на запрос 
	не ответило (произойдёт прерывание по зависанию канала связи).</p>
	<p>Итак, ответ получен. Что дальше? По-прежнему выбор порядка действий за ЦП, 
	ему &laquo;<i>водить</i>&raquo; в этой игре. Вернёмся чуть назад. Выдав сигнал 
	DIN, ЦП освобождает шину АД СиМ (снимает сигналы адреса) и. как уже говорилось, 
	ждёт ответа RPLY. А ПУс одновременно с RPLY (или даже чуть раньше) выставляет 
	на шину АД данные (которые, собственно, и требовал от него ЦП). Получив ответ 
	ПУс, ЦП принимает данные, которые ПУс установило на шине АД (записывает их в 
	один из своих буферных регистров) и снимает сигнал DIN, показывая тем самым 
	ПУс, что данные приняты. ПУс в ответ на это освобождает СиМ, снимая сигнал данных 
	и сигнал ответа RPLY. Теперь ЦП наконец-то снимает сигнал SYNC, тем самым завершая 
	цикл обмена. Пока сигнал SYNC был на СЛ СиМ, он свидетельствовал, что идёт обмен, 
	это было как бы предупреждение всем остальным АУс (если они есть в системе): &laquo;Не 
	мешать!&raquo; При чтении информации ЦП всегда обращается только по чётному 
	адресу (бит <span class="nmbr">00</span> слова адреса всегда равен нулю) и записывает 
	в свой буфер только целое слово. Если же нужен байт, то он выделяется из буфера 
	уже по окончании обмена.</p>
	<p>А что происходит, если нужно записать что-либо по адресу ПУс? Тогда ЦП вместо 
	сигнала DIN выставляет по другой СЛ сигнал DOUT (вывод), причём до подачи этого 
	сигнала он успевает освободить шину АД от адреса и выставить на ней данные, 
	которые нужно передать ПУс. Получив сигнал DOUT, ПУс не занимает магистраль, 
	а принимает выставленные на ней данные и только затем выдаёт ответ RPLY, который 
	в данном случае означает &laquo;<i>данные приняты</i>&raquo;, после чего ЦП 
	снимает сигнал SYNC (и данные), завершая обмен. Для того чтобы можно было по 
	адресу ПУс записать не только слово, но и байт, в цикле &laquo;<i>вывод</i>&raquo; 
	работает ещё одна СЛ. по которой в подобном случае вместе с сигналами SYNC и 
	DOUT передаётся специальный сигнал WTBT, свидетельствующий о передаче байта. 
	Естественно, что при этом передаваемый по сигналу SYNC адрес может быть нечётным 
	(в отличие от цикла ВВОД).</p>
	<p>Все служебные сигналы передаются по СиМ БК-0010 <b>низким уровнем</b>, т.е. 
	о наличии на соответствующих СЛ СиМ сигналов DIN, DOUT, RPLY. WTBT свидетельствует 
	уровень &laquo;<i>логического нуля</i>&raquo;, а уровень &laquo;<i>логической 
	единицы</i>&raquo; означает отсутствие сигнала (как говорят, &laquo;<i>линия 
	не активна</i>&raquo;).</p>
	<p>Существуют и другие виды обмена по СиМ (например, &laquo;ввод-модификация-вывод&raquo;), 
	но мы их рассматривать не будем, как и обмен при наличии других АУс (например, 
	второго процессора или устройства ПДП - прямого доступа к памяти). Не станем 
	мы разбирать и порядок предоставления СиМ процессором по требованию прерывания 
	от ПУс - все эти виды обмена особого интереса для нас не представляют, важно 
	лишь усвоить общие принципы асинхронного обмена. Кроме того, нужно признать, 
	что циклы ВВОД и <b>вывод</b> мы рассмотрели несколько упрощённо, в действительности 
	обмен происходит немного сложнее, но и изложенного будет для неискушённого читателя 
	вполне достаточно.</p>
	<p>Теперь ясно, что такая ЭВМ, как БК-0010, может практически неограниченно 
	расширяться путём подключения новых АУс и ПУс. Важно лишь, чтобы все АУс соблюдали &laquo;<i>правила 
	игры</i>&raquo; и не мешали друг другу во время обмена, а все ПУс имели различные 
	адреса или, если их адреса одинаковы, каким-либо способом включались по очереди. 
	Все необходимые линии СиМ выведены в БК-0010 на специальный разъем МПИ, к которому 
	и могут при необходимости подключаться дополнительные ПУс или АУс. (Это уже 
	используется на практике: к БК-0010.01 подключается дополнительный блок МСТД, 
	причём отключаются установленные на основной плате БК микросхемы ПЗУ интерпретатора 
	языка Бейсик, но зато подключаются установленные в блоке МСТД ПЗУ тестов и интерпретатора 
	языка Фокал.)</p>
	<p class="centr">★ ★ ★</p>
	<p>Теперь приступим непосредственно к рассмотрению схемотехники нашего компьютера. 
	Как уже говорилось, оно будет очень кратким и поверхностным.</p>
	<p>Конструктивно БК-0010 относится к семейству <b>одноплатных ЭВМ</b>. Это означает, 
	что все её основные функциональные узлы размещены на одной печатной плате<a href="#_ftn26" name="_ftnref26" title=""><sup>[26]</sup></a>. 
	Тем не менее схема БК может быть условно разделена на два функциональных блока 
	- процессорный и модуль памяти. Начнём с процессорного модуля.</p>
	<p>Все узлы нашей микро-ЭВМ имеют общий <b>тактовый генератор</b>. Он выполнен 
	на микросхеме D5 типа К555ЛН2. Частота генератора (<span class="nmbr">12</span> 
	МГц) стабилизирована кварцевым резонатором. Тактовая частота после деления на
	<span class="nmbr">2</span> (до <span class="nmbr">6</span> МГц) триггером D<span class="nmbr">8</span>.<span class="nmbr">1</span> 
	подаётся на контроллер ОЗУ и дисплея D<span class="nmbr">19</span> (о котором 
	речь пойдёт дальше), а кроме того, используется для тактирования телевизионного 
	сигнала. Следующий триггер D<span class="nmbr">8</span>.<span class="nmbr">2</span> 
	делит тактовую частоту ещё на <span class="nmbr">2</span>. и полученная частота
	<span class="nmbr">3</span> МГц используется для обеспечения работы ЦП типа 
	К1801ВМ1 (D<span class="nmbr">14</span>).</p>
	<p>Сигналы прерываний от внешних устройств на процессор поступают через промежуточный 
	регистр D<span class="nmbr">11</span> типа К155ИР1. Запись в этот регистр также 
	тактируется частотой <span class="nmbr">3</span> МГц. Порт ввода-вывода выполнен 
	на четырёх <span class="nmbr">8</span>-разрядных регистрах D<span class="nmbr">15</span>-D<span class="nmbr">18</span> 
	типа К589ИР12. Обращение к порту (выбор регистров) ЦП осуществляет специальным 
	сигналом SEL2 через логический элемент D<span class="nmbr">1</span>.<span class="nmbr">6</span>. 
	Такой порядок обращения к внешним устройствам по сравнению с обычным асинхронным 
	обменом значительно упрощает схему (но надо отметить, что внутри ЦП обмен осуществляется 
	как обычно, просто ЦП сам отвечает на свой сигнал, выступая как АУс и ПУс одновременно).</p>
	<p>Регистры системных внешних устройств (ввода и вывода) организованы на МС 
	D<span class="nmbr">12</span>, D<span class="nmbr">13</span> типов К531АП2П 
	и К155ИР1. Обращение к порту системных внешних устройств также производится 
	специальным сигналом ЦП SEL1.</p>
	<p>Клавиатура ЭВМ подключена к общей магистрали через специализированную МС 
	типа К1801ВП1-<span class="nmbr">014</span> - контроллер клавиатуры. Эта МС 
	имеет входы &laquo;<i>X</i>&raquo; и &laquo;<i>Y</i>&raquo; для подключения 
	клавиш, образующие двумерную матрицу. При замыкании контактом клавиши одной 
	из шин &laquo;<i>X</i>&raquo; на одну из шин &laquo;<i>Y</i>&raquo; от контроллера 
	к ЦП поступает запрос на прерывание от клавиатуры, а принятый код клавиши заносится 
	в регистр <span class="nmbr">177662</span>. Переключение режимов &laquo;<i>РУС</i>&raquo;/&laquo;<i>ЛАТ</i>&raquo; 
	осуществляется по кодам соответствующих клавиш, включённых в общее поле клавиатуры 
	(и непосредственно передаваемых в программу), а переключение &laquo;<i>СТР</i>&raquo;/&laquo;<i>ЗАГЛ</i>&raquo; 
	частично организовано аппаратно на триггере D<span class="nmbr">3</span>.<span class="nmbr">1</span>, 
	который выдаёт специальный сигнал на вход ЕС1 контроллера. Клавиши &laquo;<i>АР2</i>&raquo; 
	(&laquo;<i>НР</i>&raquo;), &laquo;<i>СУ</i>&raquo; и &laquo;<i>ПР</i>&raquo; 
	подключены к отдельным входам контроллера, причём &laquo;<i>ПР</i>&raquo; - 
	через логический элемент D<span class="nmbr">2</span>.<span class="nmbr">1</span>. 
	Клавиша &laquo;<em>ПРОБЕЛ</em>&raquo; имеет отдельную аппаратную &laquo;<i>привязку</i>&raquo; 
	к контроллеру на МС D<span class="nmbr">2</span>.<span class="nmbr">2</span>, 
	при её нажатии включается клавиша &laquo;<i>0</i>&raquo; по регистру &laquo;<i>ПР</i>&raquo; 
	(выдающая код пробела). Такое включение позволило выделить для символа &laquo;<em>ПРОБЕЛ</em>&raquo; 
	отдельную клавишу, на что контроллер клавиатуры изначально не был рассчитан, 
	и выдавать код пробела независимо от текущего режима клавиатуры. Контроллер 
	имеет специальные антидребезговые цепи на резисторах R<span class="nmbr">3</span>, 
	R<span class="nmbr">4</span> и конденсаторах С<span class="nmbr">3</span>, С<span class="nmbr">4</span>. 
	К сожалению, работа этих цепей оставляет желать лучшего: на такую ужасную клавиатуру, 
	какая применялась раньше на БК-0010.01, они не рассчитаны<a href="#_ftn27" name="_ftnref27" title=""><sup>[27]</sup></a>.</p>
	<p>Для выдачи сигнала на магнитофон с выхода МС D<span class="nmbr">13</span> 
	(на БК-0010.01 схема этого узла несколько изменена) служит делитель на резисторах 
	R<span class="nmbr">29</span>-R<span class="nmbr">31</span>, а для приёма сигнала 
	с магнитофона - компаратор на транзисторах VT<span class="nmbr">1</span>, VT<span class="nmbr">2</span>. 
	Дистанционное управление магнитофоном осуществляет реле К1 (неправильно обозначенное 
	на схеме как К<span class="nmbr">1</span>.<span class="nmbr">2</span>) типа 
	РЭС-<span class="nmbr">15</span>. Его нормально разомкнутые контакты К<span class="nmbr">1</span>.<span class="nmbr">1</span> 
	подключены непосредственно к разъёму МГ и ни с какими цепями внутри БК не соединяются. 
	Таким образом, на контакты ДУ разъёма МГ можно подавать любое напряжение (по 
	техническим условиям для данного реле оно не должно превышать
	<span class="nmbr">115</span> В), но. учитывая, что цепи, соединяющие реле с 
	разъёмом МГ, проходят по печатной плате компьютера, не следует использовать 
	реле К1 для коммутации цепей с напряжением свыше <span class="nmbr">12</span>-<span class="nmbr">24</span> 
	В и током более нескольких десятков миллиампер.</p>
	<p>Все цепи внутренней магистрали ЭВМ (и некоторые другие) нагружены на буферные 
	резисторы, объединённые в резистивные матрицы (Е1-Е8).</p>
	<p>Цепь запуска микро-ЭВМ выполнена на МС D<span class="nmbr">6</span> типа 
	К561ЛЕ5 и обеспечивает определённый порядок подачи сигналов на входы DCLO и 
	ACLO ЦП после включения питания или срабатывания переключателя ручного перезапуска 
	системы (&laquo;ПУСК-СТОП&raquo;, неправильно обозначенный на схеме как SA2, 
	на БК-0010.01 этот переключатель отсутствует<a href="#_ftn28" name="_ftnref28" title=""><sup>[28]</sup></a>).</p>
	<p>Центральным элементом модуля памяти (показанного на второй части схемы) является 
	контроллер ОЗУ и дисплея на МС К1801ВП1-<span class="nmbr">037</span> (D<span class="nmbr">19</span>). 
	Эта микросхема многофункциональная. Получая по магистрали микро-ЭВМ сигналы 
	чтения, записи и адреса, она преобразует их в обращение к конкретному адресу 
	матрицы ОЗУ, выполненной на МС ОЗУ динамического типа (К565РУ6) DS<span class="nmbr">1</span>-DS<span class="nmbr">16</span> 
	общей ёмкостью <span class="nmbr">32</span> Кб. Для промежуточного хранения 
	данных используется регистр на МС D<span class="nmbr">22</span>, D<span class="nmbr">23</span> 
	типа К589ИР12, а для преобразования содержимого экранного ОЗУ в последовательный 
	растровый код - регистр сдвига на МС D<span class="nmbr">24</span>, D<span class="nmbr">25</span> 
	типа К155ИР13. Контроллер формирует также сигналы регенерации динамического 
	ОЗУ и полный телевизионный (ТВ) сигнал. Дальнейшая обработка ТВ-сигнала осуществляется 
	МС D<span class="nmbr">9</span>.<span class="nmbr">2</span>, D<span class="nmbr">10</span>, 
	D<span class="nmbr">20</span>, D<span class="nmbr">21</span>. Выходной ТВ-сигнал 
	черно-белого изображения снимается с выхода оконечного видеоусилителя на транзисторах 
	VT<span class="nmbr">8</span>, VT<span class="nmbr">9</span>, а цветного (&laquo;<i>R</i>&raquo;, &laquo;<i>G</i>&raquo;, &laquo;<i>В</i>&raquo; 
	и &laquo;<i>Синхро</i>&raquo;) - с выхода повторителей на транзисторах VT<span class="nmbr">4</span>-VT<span class="nmbr">7</span> 
	(последние четыре транзистора, как и RGB-выход вообще, на старых БК-0010 отсутствуют). 
	С выхода Е контроллера снимается сигнал, блокирующий работу ПЗУ в области адресов 
	системных регистров (<span class="nmbr">177600</span>... <span class="nmbr">
	177777</span>). Микросхемы ПЗУ DS<span class="nmbr">17</span>-DS<span class="nmbr">19</span> 
	являются отдельными элементами схемы, связанными с ЦП по системной магистрали 
	асинхронно. На их подключении следует остановиться чуть подробнее.</p>
	<p>Прежде всего, на указанной схеме приведены лишь МС типа К1801РЕ2 с номерами
	<span class="nmbr">017</span>, <span class="nmbr">018</span> и
	<span class="nmbr">019</span>, что соответствует схеме старой БК-0010 (монитор, 
	Фокал и тест-ПЗУ). В БК-0010.01 вместо двух последних МС установлены три ПЗУ 
	Бейсика (номера <span class="nmbr">106</span>, <span class="nmbr">107</span>,
	<span class="nmbr">108</span>). Микросхема типа К1801РЕ2 имеет вход выборки 
	СЕ. Схема БК-0010.01 устроена так, что при подключении блока МСТД микросхемы 
	Бейсика, стоящие на плате, отключаются по этим входам и уже не отвечают на запросы 
	ЦП, а установленные в блоке МСТД микросхемы К1801РЕ2-<span class="nmbr">018</span> 
	и -<span class="nmbr">019</span> включаются в работу. Микросхема, адресное пространство 
	которой приходится на область системных регистров (<span class="nmbr">019</span> 
	- тест-ПЗУ или <span class="nmbr">108</span> - Бейсик), дополнительно блокируется 
	сигналом запрета с выхода Е контроллера D<span class="nmbr">17</span>, если 
	ЦП обратился по адресу какого-либо системного регистра. Чтобы отключить любую 
	из МС ПЗУ. достаточно на её вход СЕ (вывод <span class="nmbr">23</span>) подать &laquo;<i>логическую 
	1</i>&raquo;, при этом МС перестаёт отвечать на запросы ЦП и занимать адресное 
	пространство, она как бы не существует. Таким способом можно почти неограниченно 
	расширять память БК-0010, &laquo;<i>размещая</i>&raquo; новые страницы памяти 
	(ОЗУ или ПЗУ) в адресном пространстве ПЗУ при условии отключения последних. 
	Конечно, ни при каких обычных условиях недопустимо отключение ПЗУ монитора (DS<span class="nmbr">17</span>), 
	иначе ЭВМ просто не будет работать (хотя ЦП будет продолжать функционировать), 
	ибо это ПЗУ выполняет функции виртуального процессора.</p>
	<h3><a name="toc_55"></a>Возможные доработки БК-0010</h3>
	<p>Среди пользователей БК-0010 в последнее время появилась мода на доработки 
	схемы БК. Считается чуть ли не неприличным, если эта схема осталась неизменной 
	и работает так, как это предусмотрено. Нельзя не признать, что многие из доработок 
	весьма рациональны, но есть среди них и сомнительные. Рассмотрим кратко, какие 
	доработки БК-0010 сегодня известны, в чем их преимущества и недостатки, а также 
	насколько велик риск выхода компьютера из строя при их реализации.</p>
	<p>Самой распространённой доработкой является исключение блока МСТД с установкой 
	платы блока (или непосредственно микросхем ПЗУ Фокала и Бейсика) внутрь корпуса 
	компьютера. Один из вариантов этой доработки описан в журнале &laquo;<i>Информатика 
	и образование</i>&raquo; (там же, где приведена схема БК). Доработку надо признать 
	весьма рациональной и при аккуратном исполнении безопасной.</p>
	<p>Одновременно можно установить переключатель перезапуска компьютера, если 
	он отсутствует. Его удобно вынести на левую стенку корпуса, как это показано 
	в журнале &laquo;Персональный компьютер БК-0010 - БК 0011М&raquo;, №<span class="nmbr">1</span> 
	за <span class="nmbr">1994</span> г., с. <span class="nmbr">71</span>. Если 
	использовать кнопку типа П2К, то её выводы точно устанавливаются в отверстия 
	печатной платы, предназначенные для переключателя, остаётся только их распаять 
	и прорезать в левой стенке корпуса окно для кнопки.</p>
	<p>Следующим шагом может быть установка отдельных выключателей для <b>каждой</b> 
	из микросхем ПЗУ. Для включения соответствующей МС достаточно соединить её вывод
	<span class="nmbr">23</span> с общим проводом компьютера (&laquo;<i>логический 
	0</i>&raquo;), а для отключения подать на вывод <span class="nmbr">23</span> &laquo;<i>1</i>&raquo; 
	(соединить вывод с шиной &laquo;+5В&raquo; через резистор <span class="nmbr">
	1</span>...<span class="nmbr">3</span> кОм), что и должны делать переключатели. 
	Такая доработка может быть очень полезной. Например, если при исполнении какой-либо 
	программы компьютер &laquo;<i>завис</i>&raquo; и не реагирует на нажатие клавиш, 
	то после отключения всех МС ПЗУ (кроме ПЗУ монитора) и перезапуска содержимое 
	ОЗУ сохранится (если, конечно, его не уничтожит программа, вызвавшая зависание) 
	и имеющуюся в ОЗУ информацию можно использовать. Зависание системы перестаёт 
	быть &laquo;<i>фатальным</i>&raquo;!<a href="#_ftn29" name="_ftnref29" title=""><sup>[29]</sup></a> 
	И совершенно необходимо выборочное отключение ПЗУ при подключении к ЭВМ дополнительной 
	памяти, дисковода и иных внешних устройств, работающих по адресам
	<span class="nmbr">120000</span>...<span class="nmbr">177577</span>. Но эта 
	доработка уже сложнее, так как требует вмешательства в схему компьютера (в частности, 
	необходимо освободить от печатных проводников выводы <span class="nmbr">23</span> 
	всех ПЗУ, сохранив при этом другие цепи нетронутыми).</p>
	<p>Интересной и несложной доработкой является введение переключателя &laquo;<i>ПДП</i>&raquo; 
	- прямого доступа к памяти. Конечно, настоящий режим ПДП мы получить не сможем: 
	для этого необходимо как минимум специальное устройство - контроллер ПДП, но 
	переход в режим ПДП позволяет обратимо (на время) прервать исполнение <b>любой</b> 
	программы пользователя. Для перехода в этот режим необходимо подать &laquo;<i>0</i>&raquo; 
	на выводы <span class="nmbr">2</span>, <span class="nmbr">3</span> и
	<span class="nmbr">5</span> ЦП, т.е. с помощью специально установленного переключателя 
	соединить эту точку схемы (указанные выводы МС D<span class="nmbr">14</span> 
	в стандартной схеме БК соединены вместе и через резистор R<span class="nmbr">27</span> 
	подключены к шине питания &laquo;+5В&raquo;) с общим проводом. Отключать от 
	этой точки что-либо, как это рекомендовалось в журнале &laquo;<i>Информатика 
	и образование</i>&raquo;. № <span class="nmbr">2</span> за
	<span class="nmbr">1990</span> г. (с. <span class="nmbr">46</span>). не нужно 
	- это только лишний риск вывести компьютер из строя, а останов ЦП будет достигнут 
	и без этого. (В упомянутой статье помимо переключателя ПДП описана схема перевода 
	БК-0010 в так называемый &laquo;турбо-режим&raquo; - удвоение тактовой частоты 
	ЦП. Эта доработка призвана удвоить скорость исполнения программ на БК. При всей 
	своей привлекательности эта доработка относится к числу <b>не рекомендуемых</b>. 
	Во-первых, поскольку обмен в БК асинхронный, удвоения скорости не произойдёт, 
	она увеличится в лучшем случае в <span class="nmbr">1</span>.<span class="nmbr">7</span> 
	- <span class="nmbr">1</span>.<span class="nmbr">9</span> раза (а при работе 
	с ОЗУ - всего в <span class="nmbr">1</span>.<span class="nmbr">2</span> -
	<span class="nmbr">1</span>.<span class="nmbr">6</span> раза). Кроме того, вообще 
	не каждый БК-0010 будет работать при удвоенной тактовой частоте, это зависит 
	от качества применённой в вашей ЭВМ микросхемы ЦП. И наконец, тактовая частота
	<span class="nmbr">6</span> МГц является <b>предельной</b> для ЦП данного типа 
	и значительно увеличивает вероятность сбоев в работе ЭВМ, а также сокращает 
	срок службы ЦП из-за его сильного перегрева<a href="#_ftn30" name="_ftnref30" title=""><sup>[30]</sup></a>.)</p>
	<p>Не составляет труда ввести в компьютер и дополнительное внеприоритетное прерывание 
	ACLO (по вектору <span class="nmbr">24</span>). Для вызова этого прерывания 
	достаточно подать короткий положительный импульс на вывод <span class="nmbr">
	13</span> МС D<span class="nmbr">6</span>.<span class="nmbr">4</span>. Импульс 
	может быть сформирован, если зарядить конденсатор ёмкостью
	<span class="nmbr">0</span>,<span class="nmbr">033</span> мкФ до напряжения 
	+5В, а затем разрядить его на эту точку схемы (с помощью специального переключателя 
	или кнопки). В МСД при этом будет выдано сообщение &laquo;<b>сбой питания</b>&raquo;. 
	Перезадав вектор <span class="nmbr">24</span> и написав свою программу его обработки, 
	можно решать самые различные задачи, например делать графическую копию экрана 
	в любом режиме ЭВМ (надо только учитывать, что вектор <span class="nmbr">24</span> 
	весьма &laquo;<i>уязвим</i>&raquo; - его переписывают команда
	<span class="cmds">EMT</span> <span class="nmbr">14</span> и многие программы 
	пользователя).</p>
	<p>Следующая очень распространённая доработка - расширение памяти компьютера. 
	Предложено множество схем такого расширения. все они сводятся в основном к отключению 
	ПЗУ в области адресов <span class="nmbr">120000</span>...<span class="nmbr">177577</span> 
	и подключению вместо них нового внешнего устройства - контроллера ОЗУ и матрицы-накопителя 
	(попросту говоря, микросхем памяти). Контроллер необходим потому, что не существует 
	микросхем ОЗУ, рассчитанных на непосредственное включение в системную магистраль 
	БК-0010 (кроме сверхдефицитных К1809РУ1, имеющих к тому же ёмкость всего
	<span class="nmbr">2</span> Кб), - все они имеют организацию INTEL, а у нас 
	в компьютере используется организация DEC. Есть, правда, МС ППЗУ типа К573РФЗ 
	(с ультрафиолетовым стиранием) и КМ1801РР1 (с электрическим стиранием), рассчитанные 
	на архитектуру DEC; это перепрограммируемые ПЗУ, по подключению идентичные МС 
	К1801РЕ2. Но эти МС крайне дефицитны, для записи в них информации необходимо 
	специальное оборудование (программатор), а срок хранения информации в них ограничен 
	(в лучшем случае несколько тысяч часов), поэтому всерьёз говорить о их широком 
	применении в БК не приходится.</p>
	<p>Все схемотехнические решения дополнительного ОЗУ распадаются на две ветви 
	- статическое и динамическое ОЗУ. Динамические МС ОЗУ (преимущественно серии 
	К565) относительно дёшевы и обладают значительной ёмкостью (от
	<span class="nmbr">16</span> до <span class="nmbr">64</span> и больше килобит 
	на корпус), но требуют периодической <b>регенерации</b> - восстановления информации, 
	осуществляемого специальным устройством примерно <span class="nmbr">1000</span> 
	раз в секунду. Это усложняет схемотехнику такого типа ОЗУ или требует применения 
	специальных контроллеров (например К1801ВП1-<span class="nmbr">037</span>), 
	а они дефицитны. Кроме того, информация в динамическом ОЗУ хранится, пока включено 
	питание компьютера. Любой сбой питания или выключение ЭВМ приводит к необходимости 
	загружать информацию в ОЗУ заново, а при его значительной ёмкости (порядка
	<span class="nmbr">128</span> Кб) такая загрузка с магнитофона будет длиться 
	десятки минут. Ясно, что применение ОЗУ столь большой ёмкости оправдано в основном 
	для промежуточного хранения и обработки информации (графической или текстовой). 
	Для этого, естественно, требуются специализированные программы, на БК-0010 пока 
	что отсутствующие (их разработка ведётся, но ассортимент вряд ли будет широк 
	- маловато самих дополнительных ОЗУ. не всем они доступны). Ещё один &laquo;<i>минус</i>&raquo; 
	динамических ОЗУ - значительное энергопотребление. Ток потребления, например, 
	ОЗУ ёмкостью <span class="nmbr">128</span> Кб может превышать
	<span class="nmbr">0</span>,<span class="nmbr">5</span> А. На такую дополнительную 
	нагрузку блок питания БК не рассчитан, и требуется его переделка или изготовление 
	дополнительного блока питания. Конечно, можно довериться и &laquo;<i>штатному</i>&raquo; 
	блоку питания БК (по принципу &laquo;<i>авось пронесёт</i>&raquo;) - некоторые 
	резервы имеются, но полагаться на &laquo;<i>авось</i>&raquo; как-то не очень 
	хочется.</p>
	<p>Вторая ветвь - статические ОЗУ. Они конструируются обычно на базе МС со сверхнизким 
	энергопотреблением, чаще всего серии К537. Эти МС, не обладающие столь большими 
	информационными ёмкостями и более дорогие, тем не менее имеют ряд важных преимуществ. 
	Прежде всего, они не требуют регенерации, поэтому схема ОЗУ получается проще. 
	Но самое главное - потребляемый ток этих МС так мал, что они не только не создают 
	перегрузок блока питания БК, но даже позволяют снабдить такое ОЗУ &laquo;<i>буферным 
	питанием</i>&raquo;. т.е. блоком питания от батарей или аккумуляторов, позволяющим 
	хранить информацию при отключении ЭВМ несколько месяцев или даже лет. Благодаря 
	такому решению уже не приходится каждый раз загружать информацию в ОЗУ заново, 
	однажды считанные туда программы (например отладчик, ассемблер, редактор текста) 
	могут храниться неограниченно долго, при включении ЭВМ они сразу готовы к работе, 
	а при необходимости их очень легко заменить на другие программы. Понятно, что 
	применение статических ОЗУ с малым энергопотреблением и буферным питанием (их 
	ещё называют энергонезависимыми ОЗУ - ЭОЗУ) гораздо предпочтительнее динамических<a href="#_ftn31" name="_ftnref31" title=""><sup>[31]</sup></a>.</p>
	<p>Основным преимуществом в случае расположения рабочих адресов дополнительного 
	ОЗУ в зоне адресов ПЗУ является то, что загруженные в такое ОЗУ программы находятся 
	в адресном пространстве БК и (если они перемещаемые) могут работать непосредственно 
	в дополнительном ОЗУ. Если же требуется переслать такую программу в ОЗУ пользователя, 
	то это тоже очень легко сделать, воспользовавшись, например, директивами МСД. 
	Но существует и другой путь. Можно подключить дополнительное ОЗУ к порту БК-0010 
	и организовать его побайтный обмен информацией с ОЗУ пользователя, получив таким 
	образом внешний накопитель информации - квазидиск. Преимуществом такого решения 
	является относительная простота ОЗУ, но много и недостатков. Это и необходимость 
	использования специальных программ обмена (типа операционных систем), и невозможность 
	свободного подключения к порту других внешних устройств (принтера, манипулятора &laquo;<i>мышь</i>&raquo;), 
	и обязательность пересылки программ для работы в ОЗУ пользователя. Разумное 
	сочетание обоих решений (например, программы обмена и некоторые инструментальные 
	программы - в ЭОЗУ, в общем адресном пространстве, а хранение промежуточной 
	информации - на квазидиске) может дать хорошие результаты. Однако сегодня всё 
	упирается в отсутствие специальных программ, рассчитанных на работу с дополнительными 
	ОЗУ, которые позволили бы в полной мере реализовать преимущества этой доработки 
	БК-0010.</p>
	<p>Появление в последнее время в свободной продаже нескольких типов принтеров 
	привело к тому, что принтер всё чаще становится неотъемлемой частью комплекса 
	на основе БК-0010, чему немало способствует наличие на БК неплохих текстовых 
	и графических редакторов. Про программное обеспечение печати уже было рассказано 
	в разделе &laquo;<i>Концепция системных драйверов</i>&raquo;. Остаётся только 
	указать, какой принтер наиболее предпочтителен. Сегодня это, несомненно, <i>
	МС6313</i> с EPSON-совместимой системой команд. Ничего плохого нельзя сказать 
	и про импортные модели принтеров (например, <i>EPSON LX/FX-800</i>), но где 
	их взять рядовому пользователю БК? Да и цены кусаются. А распространившиеся 
	было термоструйные принтеры <i>МС6312</i> мало кому пришлись по нраву, так как 
	печатающие головки-чернильницы на них одноразовые, довольно дорогие и дефицитные. 
	Одна головка даёт возможность отпечатать не более <span class="nmbr">800</span>-<span class="nmbr">1000</span> 
	страниц, после чего требует замены (придуманные &laquo;<i>умельцами</i>&raquo; 
	способы перезаправки головок стабильных результатов не дают). Таким образом, 
	даже более низкая стоимость <i>МС6312</i> по сравнению с другими моделями не 
	окупает хлопот и расходов при его эксплуатации. Дополнительными недостатками 
	этого принтера являются невозможность печати нескольких экземпляров текста одновременно 
	и очень мелкий шрифт<a href="#_ftn32" name="_ftnref32" title=""><sup>[32]</sup></a>.</p>
	<p>Проблемой номер один на БК считается подключение дисковода, хотя реализована 
	эта доработка пока очень немногими. Обычно для этого используется схема контроллера 
	НГМД для компьютера БК-0011 (основой которого является микросхема К1801ВП1-<span class="nmbr">128</span>). 
	Эта схема неплохо себя зарекомендовала, не требует для подключения почти никаких 
	доработок компьютера и имеет поддержку в виде целого ряда программных средств 
	(операционных систем). Конечно, имеющиеся программные средства поддержки дисковода 
	пока далеки от совершенства. Сильно ограничивает возможности работы с дисководом 
	тот факт, что программа обмена или ОС должна при работе с ним располагаться 
	в ОЗУ пользователя, что делает невозможной работу со многими программами, требующими 
	всего объёма памяти. Обойти эту трудность можно, разместив ОС в дополнительном 
	ОЗУ любого типа, лучше всего, конечно, в ЭОЗУ. Однако следует отметить, что 
	необходимость подключения к БК дисковода часто переоценивается. Разумеется, 
	существует ряд задач, для решения которых дисковод просто необходим. Но для 
	большинства задач вполне достаточно магнитофона, особенно с последними разработками, 
	например разработанным автором МКМ-пакетом, который позволяет вести обмен с 
	магнитофоном на скорости <span class="nmbr">4000</span> бод при высокой надёжности 
	и поддерживает большинство программ пользователя и языков высокого уровня. При 
	размещении такого драйвера в дополнительном ОЗУ удобство работы с магнитофоном 
	возрастает столь заметно, что необходимость подключения дисковода становится 
	неочевидной... на некоторое время.</p>
	<p>&laquo;Сколько на свете людей, столько и мнений&raquo;: старая поговорка 
	права всегда, и, в полном соответствии с ней, мнение редакции журнала в данном 
	случае не совпадает с мнением автора. Конечно, дисковод <b>пока ещё</b> является 
	скорее удобством, чем необходимостью. Но для любого компьютера удобство работы 
	- один из определяющих факторов, к тому же уже сегодня существует немало многофайловых 
	программ, при работе подгружающих в ОЗУ тот или иной программный модуль, и количество 
	таких программ (в связи с растущей популярностью дисководов и удобством самого 
	модульного, или, как ещё говорят, оверлейного, принципа программирования на 
	ЭВМ с ограниченным объёмом памяти) будет увеличиваться с каждым годом. Далее, 
	в настоящее время использование КНГМД от БК-0011, упомянутых автором статьи, 
	почти полностью прекращено, так как прошивка микросхемы ПЗУ в этой модели КНГМД 
	обладает рядом существенных недостатков. (В частности, перед загрузкой операционной 
	системы с диска на БК-0010(.01) требуется вручную переписать содержимое некоторых 
	ячеек ОЗУ). Сейчас к БК-0010(.01) подключают в основном КНГМД от новой модели 
	БК-0011М (&laquo;<i>триста двадцать шестая</i>&raquo; прошивка ПЗУ), соответственным 
	образом доработанный:</p>
	<ul>
		<li>установка перемычек, блокирующих ПЗУ Бейсика при подключении блока КНГМД 
		к разъёму системной магистрали БК-0010.01 (или ПЗУ Фокала и тестов в БК-0010);</li>
		<li>установка дополнительного энергонезависимого ОЗУ ёмкостью от
		<span class="nmbr">8</span> до <span class="nmbr">32</span> Кб (стандарт-<span class="nmbr">16</span> 
		Кб);</li>
		<li>прочие доработки, повышающие удобство общения с БК и расширяющие спектр 
		его возможностей: кнопка &laquo;<span class="cmds">RESET</span>&raquo;, 
		микросхема для временного подключения ПЗУ Бейсика взамен ДОЗУ (&laquo;дисковый 
		Бейсик&raquo;) и т.д.</li>
	</ul>
	<p>Кроме контроллеров от БК-0011М популярны и &laquo;<i>самостоятельные</i>&raquo; 
	разработки, предназначенные специально для БК-0010(.01). Из них наиболее предпочтительными, 
	пожалуй, можно считать контроллеры фирмы &laquo;<i>АльтПро</i>&raquo;, описание 
	которых дано в предыдущем выпуске журнала.</p>
	<p>Вопросам подключения дисковода к БК-0010(.01) посвящён №<span class="nmbr">1</span> 
	за <span class="nmbr">1993</span> г., имеются публикации и в других выпусках 
	(в частности, в №<span class="nmbr">5</span> за <span class="nmbr">1994</span> 
	г. дан ассемблерный листинг прошивки ПЗУ КНГМД и объяснены основные принципы 
	его работы, а в №<span class="nmbr">2</span> за <span class="nmbr">1995</span> 
	г. рассказано о доработке КНГМД для работы с диском в вильнюсском Бейсике БК-0010.01).</p>
	<p>Приобрести контроллеры дисковода для БК-0010(.01) (фирмы &laquo;<i>АльтПро</i>&raquo;) 
	и для БК-0011(М). а также дисководы, блоки питания для них, операционные системы 
	и даже полный комплект &laquo;<i>винчестера</i>&raquo; для БК-0010(.01) и БК-0011(М) 
	(сам жёсткий диск, совмещённый контроллер для него и дисководов, блок питания 
	и программная поддержка) можно в редакции, здесь же вы можете получить справки 
	и консультации. - <em>Прим. ред.</em></p>
	<p>Для БК-0010 в настоящее время разработан и ряд других дополнительных устройств, 
	например серийно выпускаемый манипулятор &laquo;<i>мышь</i>&raquo; (УВК-01 &laquo;<i>Марсианка</i>&raquo;) 
	и несколько видов джойстиков. Если &laquo;<i>мышь</i>&raquo; имеет стандартную 
	цоколёвку, которую нужно учитывать только авторам использующих её программ, 
	то с джойстиками дело обстоит сложнее. Единого стандарта их подключения к БК 
	не существует, так что риск несовпадения распайки у авторов программ и у пользователей 
	довольно велик. Но проблема, как это часто бывает, преувеличена. Подавляющее 
	большинство программ, использующих джойстик (как правило, это игры), дает возможность 
	задания управления перед началом работы, поэтому способ подключения джойстика 
	особого значения не имеет. Надо только найти общий вывод для всех его кнопок 
	и подключить его к общему проводу разъёма порта УП БК (например, к контакту 
	All), остальные же выводы подключаются к произвольным контактам порта ввода 
	(например, к В24, А24, В23, В17, В20, А20, В22 и т.д.)<a href="#_ftn33" name="_ftnref33" title=""><sup>[33]</sup></a>.</p>
	<p>Прочие дополнительные устройства применяются на БК относительно редко и являются 
	более &laquo;<i>экзотическими</i>&raquo;. Например, в Чехословакии (по старой 
	географической терминологии) специально для БК выпускался плоттер (двухкоординатный 
	графопостроитель) типа <i>XY4140</i> (<i>XY4150</i>, <i>XY4160</i>) с соответствующим 
	программным обеспечением, входящим в комплект поставки. Есть и программы, разработанные 
	для него дополнительно. Например, автором этой статьи создана программа &laquo;<i>СКР.4140</i>&raquo;, 
	позволяющая выводить на плоттер любые изображения, подготовленные в графическом 
	редакторе <i>Р1.0М</i> (доработанный <i>БК-PAINT</i>), в том числе и размечать 
	с его помощью печатные платы. Автором также разработана система ввода в БК изображений 
	с телекамеры - телевизионный сканер &laquo;<i>ТВИНТ</i>&raquo;, имеющий очень 
	несложную аппаратную поддержку (не считая, конечно, самой телекамеры типа &laquo;<i>Электроника-841</i>&raquo;!), 
	так как большинство проблем решается программным путём. Разными авторами в разное 
	время разрабатывались на базе БК-0010 многоголосые музыкальные синтезаторы, 
	системы автоматизации, приставки к телефонам и т.п., но все эти устройства были 
	достаточно сложны и не получили заметного распространения
	<a href="#_ftn34" name="_ftnref34" title=""><sup>[34]</sup></a>.</p>
	<p>&laquo;<i>Бичом</i>&raquo; старых БК-0010 была клавиатура. Став более удобной 
	на БК-0010.01, она проиграла в надёжности. Разработано несколько способов подключения 
	к БК внешней клавиатуры (в том числе и от IBM) - на герконах, на магнитодиодных 
	микросхемах и т.п., но все они достаточно сложны и дороги в реализации. Существует 
	и целый ряд приёмов борьбы с дребезгом &laquo;<i>штатной</i>&raquo; клавиатуры, 
	более или менее эффективных. Но с выпуском новой клавиатуры для БК (с многослойной 
	плёночной контактурой и характерными &laquo;<i>ступеньками</i>&raquo; на клавишах 
	управления курсором) эта проблема утрачивает остроту.</p>
	<p>Подводя итоги всему сказанному, можно заметить, что БК-0010 благодаря своей 
	относительно низкой стоимости, широкой распространённости, возможности расширения, 
	удобной системе команд и развитому программному обеспечению ещё достаточно долго &laquo;<i>не 
	сойдёт со сцены</i>&raquo; и будет продолжать радовать своих владельцев всё 
	новыми возможностями, а перед программистами и схемотехниками ставить всё новые 
	задачи.</p>
	<h1><a name="toc_56"></a>ПРИЛОЖЕНИЯ</h1>
	<h2><a name="toc_57"></a>Перечень общепринятых в литературе о БК сокращений</h2>
	<p>DIN - сигнал цикла <b>ввод</b> (чтение) активного устройства.</p>
	<p>DOUT - сигнал цикла <b>вывод</b> (запись) активного устройства.</p>
	<p><span class="regn">PC</span> - программный счётчик, один из регистров общего 
	назначения.</p>
	<p><span class="regn">PS</span> - регистр состояния процессора (в котором хранится 
	слово состояния процессора).</p>
	<p><span class="regn">PSW</span> (ССП) - слово состояния процессора.</p>
	<p>RPLY (СИП) - синхроимпульс (ответ) пассивного устройства.</p>
	<p>SYNC (СИА) - синхроимпульс (синхронизация обмена) активного устройства.</p>
	<p><span class="regn">SP</span> - регистр хранения адреса вершины стека, один 
	из регистров общего назначения.</p>
	<p>WTBT - сигнал байтового обмена цикла <b>вывод</b> (запись) активного устройства.</p>
	<p>АД - адрес-данные (шина, группа линий связи системной магистрали).</p>
	<p>&laquo;<i>АР2</i>&raquo; (&laquo;<i>НР</i>&raquo;) - регистровая клавиша 
	для ввода дополнительных кодов клавиатуры на БК - псевдографики и некоторых 
	команд управления.</p>
	<p>АУс - активное устройство (инициирующее обмен по системной магистрали).</p>
	<p>АЦП - аналого-цифровой преобразователь (устройство, преобразующее сигналы 
	тока или напряжения в цифровой код).</p>
	<p>БК - бытовой компьютер (здесь имеется в виду компьютер БК-0010(.01) или БК-0011 
	(М) )<a href="#_ftn35" name="_ftnref35" title=""><sup>[35]</sup></a>.</p>
	<p>ГТ - графическая точка.</p>
	<p>ДАМП - распечатка содержимого памяти (обычно в коде ASCII) а также специальная 
	программа для такой распечатки.</p>
	<p>ДВК - диалоговый вычислительный комплекс, групповое название распространённых 
	компьютеров конфигурации DEC.</p>
	<p>ДУ - дистанционное управление (магнитофоном или иными устройствами).</p>
	<p>&laquo;ЗАГЛ&raquo; - регистровая клавиша, устанавливающая режим ввода кодов 
	заглавных букв.</p>
	<p>КС - контрольная сумма (файла, блока информации, массива) - специальным образом 
	вычисляемое значение, позволяющее идентифицировать блок информации (как правило, 
	используется для проверки правильности ввода с клавиатуры или чтения с внешнего 
	носителя).</p>
	<p>КУВТ - комплекс учебной вычислительной техники<a href="#_ftn36" name="_ftnref36" title=""><sup>[36]</sup></a>.</p>
	<p>&laquo;<i>ЛАТ</i>&raquo; - регистровая клавиша, устанавливающая режим ввода 
	кодов латинских букв.</p>
	<p>МДС - монитор-драйверная система, часть системного программного обеспечения 
	БК-0010.</p>
	<p>МЛ - магнитная лента.</p>
	<p>МОП - одна из технологий производства микросхем (металл-окисел-полупроводник).</p>
	<p>МПИ - разъем системной магистрали БК.</p>
	<p>МС - микросхема.</p>
	<p>МСД, МСТД - мониторная система тестов и диагностики, часть системного программного 
	обеспечения БК-0010, а также блок (МСТД), подключаемый к разъёму системной магистрали.</p>
	<p>НГМД - накопитель на гибких магнитных дисках.</p>
	<p>НМД - накопитель на жёстком магнитном диске (&laquo;<i>винчестер</i>&raquo;).</p>
	<p>НМЛ - накопитель на магнитной ленте.</p>
	<p>ОЗУ - оперативное запоминающее устройство.</p>
	<p>ОС - операционная система.</p>
	<p>ПДП - устройство (режим) прямого доступа к памяти.</p>
	<p>ПЗУ - постоянное запоминающее устройство.</p>
	<p>ПМ - пусковой монитор (часть системного программного обеспечения, а также 
	один из диалоговых режимов БК-0010).</p>
	<p>ПНЧ - преобразователь напряжения в частоту.</p>
	<p>ПО - программное обеспечение.</p>
	<p>ППЗУ - перепрограммируемое постоянное запоминающее устройство.</p>
	<p>&laquo;<i>ПР</i>&raquo; - регистровая клавиша, устанавливающая режим ввода 
	дополнительных кодов клавиатуры.</p>
	<p>ПУс - пассивное устройство (устройство, подключённое к системной магистрали 
	и работающее под управлением активного устройства).</p>
	<p>РОН - регистр общего назначения центрального процессора.</p>
	<p>РП - режим расширения памяти БК-0010.</p>
	<p>&laquo;<i>РУС</i>&raquo; - регистровая клавиша, устанавливающая режим ввода 
	кодов русских букв.</p>
	<p>СИА (SYNC) - синхроимпульс (синхронизация обмена) активного устройства.</p>
	<p>СиМ - системная магистраль.</p>
	<p>СИП (RPLY) - синхроимпульс (ответ) пассивного устройства.</p>
	<p>СЛ - служебная линия (системной магистрали).</p>
	<p>СР - системный регистр.</p>
	<p>ССД - слово состояния дисплея.</p>
	<p>ССП (<span class="regn">PSW</span>) - слово состояния процессора.</p>
	<p>&laquo;<i>СТР</i>&raquo; - регистровая клавиша, устанавливающая режим ввода 
	кодов строчных букв.</p>
	<p>&laquo;<i>СУ</i>&raquo; - регистровая клавиша, устанавливающая режим ввода 
	кодов символов управления.</p>
	<p>СУБД - система управления базами данных.</p>
	<p>ТЛГ - телеграфный канал связи.</p>
	<p>УсП - установочная (настроечная) последовательность.</p>
	<p>ЦП - центральный процессор.</p>
	<p>ЭВМ - электронно-вычислительная машина (компьютер).</p>
	<h2><a name="toc_58"></a>Цоколёвка разъёмов БК-0010(.01)</h2>
	<table id="mcmd" class="border3">
		<tr>
			<th rowspan="2">
			<p>Вывод разъёма</p>
			</th>
			<th colspan="2">
			<p>Назначение</p>
			</th>
		</tr>
		<tr>
			<th>
			<p>Разъём порта УП</p>
			</th>
			<th>
			<p>Разъём магистрали МПИ</p>
			</th>
		</tr>
		<tr>
			<td>
			<p>А1</p>
			</td>
			<td>
			<p>СБРОС (INIT)</p>
			</td>
			<td>
			<p>ОСТ (рестарт)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А2</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А3</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А4</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>A5</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>ПРТ (IRQ2)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А6</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А7</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">07</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А8</p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А9</p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А10</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>A11</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А12</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А13</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">01</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А14</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>БЛОК (откл. ПЗУ)<sup>1)</sup></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>A15</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А16</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">00</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А17</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А18</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А19</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А20</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">05</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А21</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А22</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А23</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">07</span></p>
			</td>
			<td>
			<p>ВВОД (DIN)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А24</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">01</span></p>
			</td>
			<td>
			<p>ППР2 (предост. прер.)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А25</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">14</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">13</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А26</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">12</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">11</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А27</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">10</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">09</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А28</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">08</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">05</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А29</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">13</span></p>
			</td>
			<td>
			<p>ЕН (блок. СР)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А30</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">15</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А31</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">09</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">00</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>А32</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">11</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В1</p>
			</td>
			<td>
			<p>Вход ПРТ (IRQ2)</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В2</p>
			</td>
			<td>
			<p>Приём ТЛГ<sup>2)</sup></p>
			</td>
			<td>
			<p>Общий</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В3</p>
			</td>
			<td>
			<p>Передача ТЛГ<sup>2)</sup></p>
			</td>
			<td>
			<p>Общий</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В4</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>ППР1 (предост. прер.)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В5</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">04</span></p>
			</td>
			<td>
			<p>ТПР (требован. прер.)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В6</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">06</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В7</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">05</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">15</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В8</p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В9</p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В10</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">03</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В11</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>БАЙТ (WTBT)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В12</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">02</span></p>
			</td>
			<td>
			<p>+<span class="nmbr">5</span> В</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В13</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В14</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В15</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В16</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В17</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">03</span></p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В18</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>-</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В19</p>
			</td>
			<td>
			<p>Общий</p>
			</td>
			<td>
			<p>СБРОС (INIT)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В20</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">04</span></p>
			</td>
			<td>
			<p>СИП (RPLY)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В21</p>
			</td>
			<td>
			<p>-</p>
			</td>
			<td>
			<p>ВЫВОД (DOUT)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В22</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">06</span></p>
			</td>
			<td>
			<p>СИА (SYNC)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В23</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">02</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">14</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В24</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">00</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">12</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В25</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">15</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">10</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В26</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">13</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">08</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В27</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">11</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">06</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В28</p>
			</td>
			<td>
			<p>Вывод <span class="nmbr">09</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">04</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В29</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">14</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">02</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В30</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">12</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">03</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В31</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">08</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">01</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>В32</p>
			</td>
			<td>
			<p>Ввод <span class="nmbr">10</span></p>
			</td>
			<td>
			<p>АД <span class="nmbr">07</span></p>
			</td>
		</tr>
	</table>
	<p>Примечания:</p>
	<p>1) - данный контакт используется только на БК-0010.01 и обеспечивает блокировку 
	ПЗУ Бейсика при подключении блока МСТД.</p>
	<p>2) - на некоторых экземплярах БК для обмена информацией по линии ТЛГ необходимо 
	установить перемычки на печатной плате.</p>
	<h2>Некоторые полезные сведения о подключении к БК-0010(.01) контроллера дисковода</h2>
	<p>Для нормальной работы с БК-0010.01 КНГМД необходимо доработать: контакты 
	А29 и А14 разъёма МПИ нужно соединить с шиной &laquo;+<span class="nmbr">5</span>В&raquo; 
	через резисторы <span class="nmbr">150</span>-<span class="nmbr">200</span> 
	Ом. Этим достигается отключение встроенного ПЗУ Бейсика при подключении КНГМД. 
	Если в БК-0010.01 установлен переключатель для выборочного подключения ПЗУ Бейсика, 
	Фокала и тестов, то такая доработка не требуется, достаточно перед подсоединением 
	КНГМД просто отключить все встроенные ПЗУ. Для БК-0010 отключение ПЗУ по двадцать 
	третьему выводу микросхем является единственным.</p>
	<p>В КНГМД имеется дополнительный вывод шины МПИ (контакты под разъем на боковой 
	стороне платы). К этим контактам можно подключать дополнительные устройства 
	(например, блок энергонезависимого ОЗУ). Но при этом следует помнить, что линия 
	системной магистрали WTBT на дополнительные контакты не выведена (если сигнал 
	WTBT необходим в подключаемом устройстве, его следует снимать непосредственно 
	с вывода В11 разъёма МПИ КНГМД).</p>
	<h2><a name="toc_59"></a>Полный список системных переменных монитора БК-0010</h2>
	<p class="centr">******************** ФАЙЛ &quot;DMBK1-B&quot; **************************</p>
	<p class="centr">&nbsp;</p>
	<p class="centr">СОСТАВИЛ: Эльтерман П.Б.&nbsp; тел.:183-18-39</p>
	<p class="centr">&nbsp;</p>
	<p class="centr">Блок переменных драйвера БК-0010 ( DMBK )</p>
	<p class="centr">(распределение ячеек системной области)</p>
	<table id="mcmd" class="border3">
		<tr>
			<th>
			<p>Мнемоника</p>
			</th>
			<th>
			<p>Формат</p>
			</th>
			<th>
			<p>Адрес</p>
			</th>
			<th>
			<p>Длина</p>
			</th>
			<th>
			<p>Функциональное назначение ячейки</p>
			</th>
		</tr>
		<tr>
			<td colspan="5">
			<p class="centr"><strong>Системные признаки DMBK (SYSPR )</strong></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRCW</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">40</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак цветного режима (формат <span class="nmbr">32</span>)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRINF</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">41</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак инверсии фона</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRRP</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">42</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак расширенной памяти</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRRUS</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">43</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак русского регистра</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRPODC</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">44</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак подчёркивания символа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRINWS</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">45</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак инверсии символа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRISU</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">46</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак индикации су</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRBLR</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">47</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак блокировки редактирования</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRGRAF</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">50</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак графического режима</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRZAP</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">51</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак режима записи</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRSTIR</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">52</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак режима стирания</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRCWSS</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">53</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак цветного режима в служебной строке(СС)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRPSSS</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">54</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак подчёркивания символа в СС</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRISSS</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">55</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак инверсии символа в СС</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRGAHK</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">56</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак гашения курсора</p>
			</td>
		</tr>
		<tr>
			<td colspan="5">
			<p class="centr"><strong>Переменные драйвера клавиатуры ( DLLAW )</strong></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">WPTM</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">100</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Вектор прерывания таймера (ПРТ, IRQ2)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SSPTM</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">102</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Слово состояния процессора (<span class="regn">PS</span>)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFKL</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">104</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Буфер клавиатуры</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRZKB</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">105</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак записи кода в буфер</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BKPOWT</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">106</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер константы повтора (t паузы)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRPOWT</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">110</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак повтора кода</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SCTAB</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">111</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Счётчик табуляции</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">MTAB</span>:</p>
			</td>
			<td>
			<p>BLKW</p>
			</td>
			<td>
			<p><span class="nmbr">112</span></p>
			</td>
			<td>
			<p><span class="nmbr">8</span></p>
			</td>
			<td>
			<p>Маска табуляции</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SCKLC</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">122</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Счётчик ключа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">TAKLC</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">124</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Текущий адрес ключа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">AKLC</span>:</p>
			</td>
			<td>
			<p>BLKW</p>
			</td>
			<td>
			<p><span class="nmbr">126</span></p>
			</td>
			<td>
			<p><span class="nmbr">24</span></p>
			</td>
			<td>
			<p>Адреса ключей (<span class="nmbr">0</span>,<span class="nmbr">1</span>,<span class="nmbr">2</span>...<span class="nmbr">9</span>)</p>
			</td>
		</tr>
		<tr>
			<td colspan="5">
			<p class="centr"><strong>Переменные драйвера ТВ-монитора ( DTWMN )</strong></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRNRUL</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">152</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак нарушения рулона</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRZTCK</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">153</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак записи точки</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">MASPGT</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">154</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Маска позиции графической точки (ГТ)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">NMPGT</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">155</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Начальная маска позиции ГТ</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">NOMSIM</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">156</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Номер символа на экране</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">AS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">160</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес символа</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DSIMB</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">162</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина символа в байтах</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">KSVP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">164</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Количество символов на экране</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">AGTVP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">166</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес (номер) ГТ на экране</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">AGT</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">170</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес ГТ</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DGW</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">172</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина графического вектора</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SCTVS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">174</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Счётчик ТВ-строк</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFX</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">176</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер координаты X</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFY</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">200</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер координаты Y</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">ANVP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">202</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес начала видеопамяти</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BAZVP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">204</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>База видеопамяти</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DVPB</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">206</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина видеопамяти в байтах</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DGPB</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">210</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина графической памяти в байтах</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">FON</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">212</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Фон экрана</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">MASCW</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">214</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Маска цвета</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">FONSS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">216</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Фон служебной строки (СС)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">MSWSS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">220</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Маска цвета СС</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SCKOD</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">222</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Счётчик кодов</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">SCUIND</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">224</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Счётчик установки индикаторов</p>
			</td>
		</tr>
		<tr>
			<td colspan="5">
			<p class="centr"><strong>Переменные драйвера магнитофона ( DMAG )</strong></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PROH</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">300</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Признак ошибки</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRFCT</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">302</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Признак фиктивного чтения</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">INCADR</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">304</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Инкремент адреса массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">ABP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">306</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес блока параметров</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFSP</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">310</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер указателя стека</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFKS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">312</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер контрольной суммы</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">GRDL0</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">314</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Граница длины <span class="nmbr">0</span></p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BPDMAG</span>:</p>
			</td>
			<td>
			<p>-----</p>
			</td>
			<td>
			<p>---</p>
			</td>
			<td>
			<p>--</p>
			</td>
			<td>
			<p>Блок параметров <span class="labl">DMAG</span>:</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
			<td>
			<p>&nbsp;</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">KOM</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">320</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Команда</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">OTWET</span>:</p>
			</td>
			<td>
			<p>BYTE</p>
			</td>
			<td>
			<p><span class="nmbr">321</span></p>
			</td>
			<td>
			<p><span class="nmbr">1</span></p>
			</td>
			<td>
			<p>Ответ</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">ADRMAS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">322</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DLMAS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">324</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина массива на запись</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">IMMAS</span>:</p>
			</td>
			<td>
			<p>BLKB</p>
			</td>
			<td>
			<p><span class="nmbr">326</span></p>
			</td>
			<td>
			<p><span class="nmbr">20</span></p>
			</td>
			<td>
			<p>Имя массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">ADRTM</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">346</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес текущего массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DLTMAS</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">350</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина текущего массива</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">IMTMAS</span>:</p>
			</td>
			<td>
			<p>BLKB</p>
			</td>
			<td>
			<p><span class="nmbr">352</span></p>
			</td>
			<td>
			<p><span class="nmbr">20</span></p>
			</td>
			<td>
			<p>Имя текущего массива</p>
			</td>
		</tr>
		<tr>
			<td colspan="5">
			<p class="centr"><strong>Системные переменные DMBK</strong></p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DLBIT0</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">250</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина <span class="nmbr">0</span> DMAG (в условных единицах)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DLBIT1</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">252</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина <span class="nmbr">1</span> DMAG (в условных единицах)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">DLBIT</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">254</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Длина бита DTLG (в условных единицах)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">KPORT</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">256</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Копия порта</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">APOPKL</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">260</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Адрес программы обработки прерывания от клавиатуры</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">PRWK</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">262</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Признак кода ВК (ввод)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFSTA</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">264</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер стартового адреса</p>
			</td>
		</tr>
		<tr>
			<td>
			<p><span class="labl">BUFDL</span>:</p>
			</td>
			<td>
			<p>WORD</p>
			</td>
			<td>
			<p><span class="nmbr">266</span></p>
			</td>
			<td>
			<p><span class="nmbr">2</span></p>
			</td>
			<td>
			<p>Буфер длины массива</p>
			</td>
		</tr>
	</table>
	<p>&nbsp;</p>
	<p>&nbsp;</p>
	<p class="centr"><em>Автор выражает благодарность всем программистам и пользователям 
	БК, с которыми он вёл переписку и лично встречался за последние
	<span class="nmbr">7</span> лет, и чьи ценные предложения, советы, вопросы и 
	пожелания помогли ему в написании данного материала:</em></p>
	<p class="centr"><em>Б. Ф. Фролкину, С. А. Кумандину и Д Г. Гаеву (Москва),</em></p>
	<p class="centr"><em>А. В. Цаплеву и А. Г. Макееву (С.-Петербург),</em></p>
	<p class="centr"><em>В. А. Михайлову (г Алма-Ата),</em></p>
	<p class="centr"><em>С. К Никанорову (г. Керчь) и другим.</em></p>
	<p>&nbsp;</p>
</div>
</div>
<div id="content">
	<div>
		<br clear="all"><hr size="1" width="33%">
		<div id="ftn1">
			<p><a href="#_ftnref1" name="_ftn1" title=""><sup>[1]</sup></a> Следует 
			отметить, что в Фокале вектор @#<span class="nmbr">10</span> также использован 
			прежде всего для эмуляции команд плавающей арифметики. Аналогичная система 
			реализации расширенной арифметики имеется и в ПЗУ КНГМД, о чём можно 
			прочитать в №<span class="nmbr">5</span> за <span class="nmbr">1994</span> 
			г. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn2">
			<p><a href="#_ftnref2" name="_ftn2" title=""><sup>[2]</sup></a> Прежде 
			чем запускать эту программу, нужно подключить внешний таймер к контакту 
			В1 порта ввода-вывода, иначе на БК ничего выполняться не будет. -
			<em>Прим. ред.</em></p>
		</div>
		<div id="ftn3">
			<p><a href="#_ftnref3" name="_ftn3" title=""><sup>[3]</sup></a> Вместо 
			восстановления стандартного значения @#<span class="nmbr">30</span> 
			и вызова <span class="cmds">EMT</span> <span class="nmbr">14</span> 
			можно просто обратиться к реализующей эту функцию подпрограмме в ПЗУ:
			<span class="cmds">JSR</span> <span class="regn">PC</span>,@#<span class="nmbr">100742</span>. 
			После возврата из неё нужно, как и в приведённом выше примере, вернуть 
			в вектор @#<span class="nmbr">30</span> &laquo;<i>супервизорное</i>&raquo; 
			значение и выйти из прерывания по <span class="cmds">RTI</span>. -
			<em>Прим. ред.</em></p>
		</div>
		<div id="ftn4">
			<p><a href="#_ftnref4" name="_ftn4" title=""><sup>[4]</sup></a> Её работоспособность 
			редакцией не проверялась. - <em>Прим. ред.</em> </p>
		</div>
		<div id="ftn5">
			<p><a href="#_ftnref5" name="_ftn5" title=""><sup>[5]</sup></a> О подобном 
			драйвере можно прочитать в журнале &laquo;<i>Информатика и образование</i>&raquo;, 
			№<span class="nmbr">3</span> за <span class="nmbr">1991</span> г., с.
			<span class="nmbr">52</span>. - <em>Прим. ред.</em> </p>
		</div>
		<div id="ftn6">
			<p><a href="#_ftnref6" name="_ftn6" title=""><sup>[6]</sup></a> Именно 
			так, путем перехвата <span class="cmds">EMT</span>
			<span class="nmbr">36</span>, организован обмен данными с диском практически 
			во всех современных дисковых ОС для БК (NORD, ANDOS и др.). А перехват
			<span class="cmds">EMT</span> <span class="nmbr">36</span> для вывода 
			текста на принтер использован в универсальном драйвере SCREW ANIRAM 
			MIRIADA (см. №<span class="nmbr">1</span> за <span class="nmbr">1994</span> 
			г., с. <span class="nmbr">33</span>, а также вторую страницу обложки). 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn7">
			<p><a href="#_ftnref7" name="_ftn7" title=""><sup>[7]</sup></a> В редакции 
			можно приобрести программы, дающие возможность преобразовывать в текстовый 
			формат листинги программ на Фокале и Бейсике, а также перегонять в текстовый 
			файл дизассемблированные кодовые фрагменты не очень большой длины. -
			<em>Прим. ред.</em></p>
		</div>
		<div id="ftn8">
			<p><a href="#_ftnref8" name="_ftn8" title=""><sup>[8]</sup></a> Стандартный 
			адрес обработчика <span class="nmbr">101136</span>. - <em>Прим. ред.</em>
			</p>
		</div>
		<div id="ftn9">
			<p><a href="#_ftnref9" name="_ftn9" title=""><sup>[9]</sup></a> При 
			очистке данной ячейки командой <span class="cmds">CLRB</span> @#<span class="nmbr">105</span> 
			достигается эффект &laquo;<i>отмены</i>&raquo; предыдущего нажатия клавиши, 
			т.е. последующий вызов <span class="cmds">EMT</span><span class="selc">
			</span><span class="nmbr">6</span> всегда вызывает ожидание нового нажатия. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn10">
			<p><a href="#_ftnref10" name="_ftn10" title=""><sup>[10]</sup></a> Учитывая, 
			что оператор <span class="cmds">SOB</span> вначале вычитает единицу 
			из значения регистра-счётчика цикла, легко понять, что исходное нулевое 
			значение счётчика эквивалентно числу <span class="nmbr">200000</span> 
			(т.е. <span class="nmbr">177777</span>+<span class="nmbr">1</span>). 
			Исходная единица, напротив, вызовет только один проход тела цикла. -
			<em>Прим. ред.</em> </p>
		</div>
		<div id="ftn11">
			<p><a href="#_ftnref11" name="_ftn11" title=""><sup>[11]</sup></a> Содержимое 
			ячейки <span class="nmbr">156</span> можно расценивать как значение 
			координат текущей знаковой позиции, закодированной по формуле: Х+<span class="nmbr">100</span><sub>8</sub>*Y 
			(для <span class="nmbr">64</span> символов в строке) или
			<span class="nmbr">2</span>*Х+<span class="nmbr">100</span><sub>8</sub>*Y 
			(для <span class="nmbr">32</span> символов в строке ). - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn12">
			<p><a href="#_ftnref12" name="_ftn12" title=""><sup>[12]</sup></a> Отметим, 
			что при записи в данную ячейку какого-либо нового значения фон экрана 
			ещё не изменяется. Изменится он лишь после того, как будет нажата, например, 
			клавиша &laquo;<i>СБР</i>&raquo; (разумеется, прежняя информация при 
			этом будет утеряна). Если же выводить на экран какие-либо символы, не 
			очищая его, то фон каждого и этих новых символов будет соответствовать 
			новому содержимому ячейки <span class="nmbr">212</span>, а остальная 
			часть изображения на экране не изменится. Этот приём весьма удобно использовать 
			для организации меню и оконного интерфейса в вильнюсском Бейсике с помощью 
			операторов <span class="cmdf">POKE </span>&amp;<span class="nmbr">0212</span>,... 
			и <span class="cmdf">PRINT</span>. Подробности см. в №<span class="nmbr">3</span> 
			за <span class="nmbr">1994</span> г., с. <span class="nmbr">37</span>. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn13">
			<p><a href="#_ftnref13" name="_ftn13" title=""><sup>[13]</sup></a> Стандартный 
			адрес обработчика <span class="nmbr">101362</span>. - <em>Прим. ред.</em>
			</p>
		</div>
		<div id="ftn14">
			<p><a href="#_ftnref14" name="_ftn14" title=""><sup>[14]</sup></a> Ряд 
			копировщиков, например <i>HELP7</i>, устанавливают значение этой ячейки 
			равным <span class="nmbr">177777</span> (минус один), за счёт чего реализуется 
			загрузка файлов в экранное ОЗУ &laquo;<i>в обратном порядке</i>&raquo; 
			от правого нижнего угла к левому верхнему. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn15">
			<p><a href="#_ftnref15" name="_ftn15" title=""><sup>[15]</sup></a> В 
			новой версии <i>ANDOS v<span class="nmbr">3</span>.<span class="nmbr">1</span></i> 
			специально предусмотрены ещё три пары ячеек, обладающие этим ценным 
			свойством (в каждой паре первая ячейка сохраняет значение, а вторая 
			адрес, по которому это значение должно быть занесено): @#<span class="nmbr">120244</span> 
			и @#<span class="nmbr">120246</span>, @#<span class="nmbr">120250</span> 
			и @#<span class="nmbr">120252</span>, @#<span class="nmbr">120254</span> 
			и @#<span class="nmbr">120256</span>. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn16">
			<p><a href="#_ftnref16" name="_ftn16" title=""><sup>[16]</sup></a> Ещё 
			хуже, если положение вершины стека нарушается внутри подпрограммы или 
			драйвера обработки прерывания. Поскольку адрес возврата хранится в стеке, 
			возврат в основную программу невозможен, если положение вершины стека 
			перед выходом из подпрограммы (или драйвера) не будет тем же, что и 
			после входа. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn17">
			<p><a href="#_ftnref17" name="_ftn17" title=""><sup>[17]</sup></a> Впрочем, 
			если судить по всё возрастающей популярности дополнительного (расширенного) 
			ОЗУ, как в КНГМД, так и в виде отдельных блоков, этот вариант не станет 
			единственно возможным. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn18">
			<p><a href="#_ftnref18" name="_ftn18" title=""><sup>[18]</sup></a> Впрочем, 
			не обязательно &laquo;<i>специальный</i>&raquo;. То же самое можно, 
			при известном умении, сделать с помощью общераспространённых магнитофонных 
			копировщиков <i>HELP</i> и <i>HELP3</i>, а также других. - <em>Прим. 
			ред.</em></p>
		</div>
		<div id="ftn19">
			<p><a href="#_ftnref19" name="_ftn19" title=""><sup>[19]</sup></a> Имеется 
			в виду целочисленное деление, т.е. в <span class="regn">R4</span> возвращается 
			только целая часть результата. Остаток от деления после выхода содержится 
			в регистре <span class="regn">R2</span>. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn20">
			<p><a href="#_ftnref20" name="_ftn20" title=""><sup>[20]</sup></a> Напомним, 
			что умножение и деление на <span class="nmbr">2</span> (или на число, 
			равное <span class="nmbr">2</span> в степени <span class="oprt">N</span>, 
			где <span class="oprt">N</span> целое) на ассемблере реализуется сдвигом 
			исходного числа вправо и влево командами <span class="cmds">ASL</span> 
			и <span class="cmds">ASR</span>. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn21">
			<p><a href="#_ftnref21" name="_ftn21" title=""><sup>[21]</sup></a> Другой 
			способ реализации библиотек стандартных функций, возможно более удобный 
			на практике, создание подгружаемых при компоновке объектных модулей. 
			Подробнее об этом см. в №<span class="nmbr">1</span> за
			<span class="nmbr">1994</span> г., с. <span class="nmbr">37</span>. 
			- <em>Прим. ред.</em> </p>
		</div>
		<div id="ftn22">
			<p><a href="#_ftnref22" name="_ftn22" title=""><sup>[22]</sup></a> На 
			некоторых экземплярах БК-0010(.01) системный (встроенный) таймер отсутствует 
			или неисправен, в этом случае предложенная ниже в качестве ответа на 
			данный вопрос программа не будет работать вовсе или могут наблюдаться 
			различные отклонения от её правильного функционирования (например, итерируемые 
			случайные числа могут превышать #<span class="nmbr">377</span>). -
			<em>Прим. ред.</em></p>
		</div>
		<div id="ftn23">
			<p><a href="#_ftnref23" name="_ftn23" title=""><sup>[23]</sup></a> Более 
			подробно о перемещаемости программ и методике обеспечения этого свойства 
			можно прочитать в статье <em>А.Г. Прудковского</em>, в №<span class="nmbr">4</span> 
			за <span class="nmbr">1994</span> г., с. <span class="nmbr">61</span>. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn24">
			<p><a href="#_ftnref24" name="_ftn24" title=""><sup>[24]</sup></a> Ремонтная 
			документация и техническое описание БК-0010, предоставленные редакции 
			Павлово- Посадским заводом, опубликованы в №<span class="nmbr">2</span>,
			<span class="nmbr">3</span> и <span class="nmbr">4</span> за
			<span class="nmbr">1994</span> г. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn25">
			<p><a href="#_ftnref25" name="_ftn25" title=""><sup>[25]</sup></a> По 
			вопросам ремонта БК и периферийных устройств для неё, а также подключения 
			периферии к компьютеру можно обращаться в редакцию по телефону: (095) 
			151-19-40. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn26">
			<p><a href="#_ftnref26" name="_ftn26" title=""><sup>[26]</sup></a> Вторая 
			установленная в корпусе вычислителя плата служит для размещения клавишных 
			переключателей и установки пьезодинамика (на БК с новой &laquo;<i>плёночной</i>&raquo; 
			клавиатурой пьезодинамик распаян на основной плате). - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn27">
			<p><a href="#_ftnref27" name="_ftn27" title=""><sup>[27]</sup></a> В 
			настоящее время на БК устанавливается так называемая &laquo;<i>плёночная</i>&raquo; 
			клавиатура, отличительным признаком которой являются &laquo;<i>ступеньки</i>&raquo; 
			на клавишах управления курсором &laquo;<b>влево</b>&raquo; и &laquo;<b>вправо</b>&raquo;. 
			Новая клавиатура отличается от прежней более мягким ходом клавиш и отсутствием 
			дребезга. Желающие заменить старую &laquo;<i>кнопочную</i>&raquo; клавиатуру 
			БК-0010(.01) на &laquo;<i>плёночную</i>&raquo; могут обращаться в редакцию. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn28">
			<p><a href="#_ftnref28" name="_ftn28" title=""><sup>[28]</sup></a> На 
			схеме, опубликованной в №<span class="nmbr">2</span> за
			<span class="nmbr">1994</span> г., данный переключатель имеет правильное 
			обозначение SA1. Кроме того, хотя он отсутствует в БК-0010.01, соответствующие 
			ему контактные площадки на плате имеются и могут быть использованы для 
			подключения кнопки перезапуска &laquo;<span class="cmds">RESET</span>&raquo;. 
			О том, как это сделать, рассказано в №<span class="nmbr">1</span> за
			<span class="nmbr">1994</span> г., с. <span class="nmbr">71</span>. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn29">
			<p><a href="#_ftnref29" name="_ftn29" title=""><sup>[29]</sup></a> То 
			же самое можно сделать и без установки &laquo;<i>выключателя ПЗУ</i>&raquo;. 
			Если сразу же после перезапуска нажать на клавишу &laquo;<i>СТОП</i>&raquo; 
			(возможно, несколько раз), происходит выход в монитор. - <em>Прим. ред.</em>
			</p>
		</div>
		<div id="ftn30">
			<p><a href="#_ftnref30" name="_ftn30" title=""><sup>[30]</sup></a> По 
			имеющейся в редакции (к сожалению, пока не подтверждённой) информации, 
			БКманами Брянска ведётся разработка одного весьма интересного устройства 
			на основе ПДП &laquo;<i>телесканера</i>&raquo; (точнее было бы назвать 
			его &laquo;<i>VldeoBlaster</i>&raquo;, по аналогии с одноимённой системой 
			для IBM-совместимых). Основная идея состоит в считывании в ОЗУ экрана 
			БК по нажатию специальной внешней кнопки видеосигнала с соответствующих 
			цепей телевизора (естественно, с оцифровкой сигнала). Поскольку при 
			этом скорость загрузки в ОЗУ является определяющим параметром, режим 
			ПДП здесь обязателен. Редакция приглашает авторов данной разработки 
			(и других аналогичных устройств) поделиться своим опытом с читателями 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn31">
			<p><a href="#_ftnref31" name="_ftn31" title=""><sup>[31]</sup></a> Очевидно, 
			что основное (&laquo;<i>штатное</i>&raquo;) ОЗУ БК сконструировано по &laquo;<i>динамическому</i>&raquo; 
			принципу, а расширенное ОЗУ, устанавливаемое в КНГМД, как правило, статическое. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn32">
			<p><a href="#_ftnref32" name="_ftn32" title=""><sup>[32]</sup></a> Но 
			зато МС6312 печатает абсолютно бесшумно, &laquo;<i>расплывание</i>&raquo; 
			микрокапель чернил на бумаге повышает качество печати графики (отсутствует 
			присущая матричным принтерам &laquo;<i>полосатость</i>&raquo; рисунка), 
			а мелкий шрифт в новых моделях заменён на более крупный. Что же касается 
			МС6313, возможны некоторые проблемы с его подключением к БК (см. ряд 
			публикаций в журналах &laquo;<i>Информатика и образование</i>&raquo; 
			и &laquo;<i>Вычислительная техника и её применение</i>&raquo;). Так 
			что сказанное выше нельзя считать &laquo;<i>не подлежащим обжалованию 
			приговором</i>&raquo; струйным принтерам. Кстати, &laquo;<i>струйники</i>&raquo; 
			в последнее время всё увереннее вытесняют привычные матричные принтеры 
			на IBM-совместимых ПЭВМ, а мнению специалистов этой области нельзя отказать 
			в авторитетности. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn33">
			<p><a href="#_ftnref33" name="_ftn33" title=""><sup>[33]</sup></a> Варианты 
			распайки джойстиков приведены во многих журналах, где публикуются (или 
			публиковались ранее) материалы о БК. Примерами являются таблицы распайки 
			в №<span class="nmbr">4</span> за <span class="nmbr">1994</span> г., 
			с. <span class="nmbr">32</span> нашего издания, а также в журнале &laquo;<i>Вычислительная 
			техника и её применение</i>&raquo;, №<span class="nmbr">8</span> за
			<span class="nmbr">1991</span> г., с. <span class="nmbr">38</span> (вариант, 
			рекомендованный магазином &laquo;<i>Электроника</i>&raquo; на Ленинском 
			проспекте в Москве). - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn34">
			<p><a href="#_ftnref34" name="_ftn34" title=""><sup>[34]</sup></a>&nbsp;&nbsp; 
			О том, как сделать самодельный графопостроитель, рассказано в №<span class="nmbr">4</span> 
			за <span class="nmbr">1994</span> г., а на с. <span class="nmbr">50</span> 
			этого выпуска пользователи БК познакомятся и с разработанной автором 
			данной статьи схемой сканирующей приставки к графопостроителю (или, 
			при соответствующих изменениях в конструкции, к принтеру). Что же касается 
			прочих периферийных устройств, их перечень можно продолжить. Это световое 
			перо, дигитайзер, чувствительный к нажатию планшет, модем... Последний 
			даёт возможность не только обмениваться по телефону программами с другими 
			БКманами, но и работать в профессиональных электронных сетях типа RELCOM 
			или FIDONET, до недавнего времени считавшихся исключительной прерогативой 
			IBM, &laquo;<i>Макинтошей</i>&raquo; и других &laquo;<i>профессионалок</i>&raquo;. 
			- <em>Прим. ред.</em></p>
		</div>
		<div id="ftn35">
			<p><a href="#_ftnref35" name="_ftn35" title=""><sup>[35]</sup></a> Не 
			так давно появился другой домашний компьютер: &laquo;Апогей БК-01&raquo;. 
			Несмотря на похожее имя, он никак не совместим с &laquo;<i>настоящими</i>&raquo; 
			БК. Редакции же остаётся только предостеречь читателей от ошибки и посетовать 
			на невнимание изготовителей &laquo;<i>Апогея</i>&raquo;, привёдшее к 
			путанице. - <em>Прим. ред.</em></p>
		</div>
		<div id="ftn36">
			<p><a href="#_ftnref36" name="_ftn36" title=""><sup>[36]</sup></a> Как 
			правило, имеется в виду состоящий из БК и ДВК (в качестве учительской 
			машины) класс КУВТ-86 или построенный на базе БК-0011(М) комплекс УКНЦ-01 
			(&laquo;<i>спасибо</i>&raquo; изготовителям за ещё одну путаницу в названиях 
			к &laquo;<i>одноимённому</i>&raquo; компьютеру УКНЦ данный класс не 
			имеет никакого отношения!). - <em>Прим. ред.</em></p>
		</div>
	</div>
</div>
<div id="content">
	<div class="mw-content-ltr">
		<p><em>В качестве бонуса - одна из старых глав, не вошедших в эту книгу, 
		возможно по причине спорности содержимого.</em></p>
		<pre>
***************************************************************
**      ОСНОВЫ СИСТЕМНОГО ПРОГРАММИРОВАНИЯ ДЛЯ БК-0010       **
**   ЗАЛЬЦМАН Ю.A., Г.АЛМА-АТА, тел.691797.  Март 1989 г.    **
**УНИВЕРСАЛЬНЫЙ КООПЕРАТИВ-КОММУНА "СОЗИДАНИЕ" ИМ.ВЕРНАДСКОГО**
***************************************************************
	 </pre>
		<h2><a name="toc_60"></a>Раздел <span class="nmbr">26</span>. Стандартизация 
		программного обеспечения.</h2>
		<p>&nbsp;</p>
		<p class="right">-Говорят, эти учёные все ужасно умные?</p>
		<p class="right">-Да.</p>
		<p class="right">-Но почему же они тогда не ходят строем?!</p>
		<p class="right">(Из разговора)</p>
		<p>&nbsp;</p>
		<p>Итак, изучив языки программирования, можно начинать писать программы, 
		не правда ли? Ваши программы разойдутся по всему свету, вы станете знамениты... 
		Хотя бы в среде пользователей БК! Вы &quot;войдёте в историю&quot;! Но смотрите, 
		как бы не &quot;попасть в историю&quot;. Далеко не всё, что пишется, находит &quot;читателя&quot;, 
		а тем более, почитателя. К программному обеспечению (ПО) это относится особо.</p>
		<p>На сегодняшний день острота проблемы с ПО для БК-0010 несколько снизилась: 
		многие кооперативы, в том числе и наш кооператив-коммуна &quot;Созидание&quot;, 
		по договорам с авторами тиражируют довольно широкий набор ПО, по приемлемым 
		ценам. Ещё больше кооперативов и групп, делающих это нелегально, с нарушением 
		авторских прав, но это тема для отдельного разговора, сейчас же речь пойдёт 
		о другом.</p>
		<p>По нашим оценочным данным, на сегодня парк ПО для БК-0010 (БК-0010-01) 
		составляет порядка <span class="nmbr">2</span>-<span class="nmbr">3</span> 
		тыс. файлов, что вполне сравнимо с количеством ПО даже для таких массовых 
		ПК, как, например, &quot;Синклер&quot;, особенно с учётом меньших возможностей 
		БК. Но эти программы создаются в основном любителями, зачастую в условиях 
		дефицита информации о БК-0010 и её ПО, поэтому в основной массе далеки от 
		идеала. Речь не идёт о качестве ПО вообще, где всё зависит от квалификации 
		программиста. Но есть ряд моментов, которые являются независимыми от сложности 
		и характера программы, и в то же время могут свести её потребительские качества 
		к нулю. Это прежде всего стандартность и совместимость ПО. Практически каждый, 
		едва научившись программировать, считает своим долгом написать и выпустить 
		в свет какую-либо игровую, или даже системную программу. Зачастую продукт 
		такого &quot;творчества&quot; не снабжён сколько-нибудь приемлемым описанием, 
		и не имеет ни малейшего пользовательского сервиса, часто в играх даже не 
		указаны клавиши управления. Ещё хуже дело обстоит с инструментальным и системным 
		ПО. Каждый считает своим долгом изобрести собственный формат текста, собственную 
		мнемонику языка, собственный несуразный адрес запуска программы! Дошло до 
		того, что это считается даже некоей доблестью: один программист (не будем 
		называть имён!) снабдил свой пакет для работы с текстами эпиграфом: &quot;каждый 
		делает, что хочет&quot;. Такое положение нетерпимо, т.к. обесценивает массу 
		программных разработок, иногда ценных и даже уникальных, делает их недоступными 
		массовому пользователю, а квалифицированных программистов заставляет тратить 
		массу времени на их доработку и взаимную стыковку.</p>
		<p>В связи со всем этим очень остро стоит вопрос о стандартизации ПО для 
		БК-0010, хотя бы в форме рекомендаций. Личный опыт автора и переписка с 
		очень широким кругом пользователей БК-0010 позволили выработать следующие 
		рекомендации.</p>
		<ol>
			<li>Документирование ПО. Всякая разработанная программа должна быть 
			снабжена описанием, достаточным для работы пользователя, впервые столкнувшегося 
			с данной программой, и даже вообще с программой данного класса. В описании 
			должно быть <span class="nmbr">2</span> основных раздела:
			<ul>
				<li>А)&nbsp;назначение и общее описание программы, позволяющее новичку 
				понять, для чего сие произведение служит;</li>
				<li>Б)&nbsp;описание правил пользования данной конкретной программой, 
				с указанием всех режимов, клавиш управления, и т.п.</li>
			</ul>
			<p>Допустимо сводить пункт А) всего к одной фразе, например, &quot;программа 
			для копирования любых файлов БК-0010, кроме файлов с автозапуском&quot;, 
			а пункт Б) - к перечню директив, например: &quot;СУ/А - листать вперёд, 
			СУ/Б - листать назад&quot;, и т.п., но совершенно недопустимо предоставить 
			поиск назначения и директив пользователю. Очень полезно включать инструкцию, 
			если позволяет объём ОЗУ, непосредственно в загрузочный модуль, т.к. 
			отдельные описания, как правило, &quot;отстают&quot; от программ. Если 
			же это невозможно, то необходимо соблюдать определённые правила, обеспечивающие 
			доступность описания любому пользователю, независимо от имеющихся в 
			его распоряжении языков или редакторов текста, т.е. описания должны 
			быть скомпонованы для загрузки и прямого чтения в пусковом мониторе 
			или МСД. Совершенно нелогично делать описание какого-либо редактора 
			текста в нём самом, ибо, раньше, чем прочитать такое описание, нужно 
			уметь пользоваться редактором, а для этого нужно прочитать описание, 
			а для этого нужно уметь пользоваться редактором, и т.д.</p>
			</li>
			<li>Запуск программ. Программа на любом языке при запуске должна автоматически 
			проверять, и при необходимости устанавливать нужный для её работы режим 
			микро-ЭВМ: формат, цвет, наличие служебной строки и курсора, и т.п. 
			Любой язык БК-0010 позволяет выполнить эти операции, и только незнание 
			программиста делает необходимым до запуска программы ручную установку, 
			например, формата &quot;32 символа в строке&quot;. Порядок загрузки 
			и запуска программ на языке высокого уровня, понятно, определён этим 
			языком. Но порядок загрузки и запуска программ в кодах определяется 
			самим программистом, и тут необходимо соблюдать хотя бы элементарные 
			правила:
			<ul>
				<li>любая программа должна иметь естественный адрес загрузки, заданный 
				в оглавлении файла на МЛ, т.е. недопустимо, например, программу, 
				скомпонованную для работы по адресу <span class="nmbr">1000</span>, 
				записать на МЛ с адреса <span class="nmbr">12000</span> (это не 
				относится, конечно, к перемещаемым программам). Если программа должна 
				работать в &quot;экзотической&quot; зоне адресов, например,
				<span class="nmbr">77000</span>-<span class="nmbr">100000</span> 
				в режиме &quot;РП&quot;, она должна грузиться с &quot;нормального&quot; 
				адреса, например, <span class="nmbr">1000</span>, а после запуска 
				сама себя перегружать в нужную зону;</li>
				<li>адрес запуска любой программы должен быть равен естественному 
				адресу загрузки. например, задание адреса запуска
				<span class="nmbr">30700</span>, когда программа грузится с адреса
				<span class="nmbr">1000</span>, следует считать недопустимым, и 
				расценивать либо как признак низкой квалификации программиста, либо 
				как намеренное издевательство над пользователем;</li>
				<li>адрес &quot;холодного&quot; запуска программ следует задавать 
				не произвольным, или удобным программисту, а равным &lt;адрес загрузки+<span class="nmbr">2</span>&gt;, 
				что достигается с помощью единственного лишнего оператора &lt;<span class="cmds">BR</span>&gt;, 
				или, в крайнем случае, двух операторов.</li>
			</ul>
			</li>
			<li>Останов программ. Многие программы изменяют при работе системную 
			область БК-0010, режимы дисплея, и т.п. При их останове клавишей &lt;СТОП&gt; 
			либо специальной директивой выхода, программист обязан позаботится о 
			восстановлении всех исходных данных и режимов: восстановить векторы 
			прерывания и стек, обеспечить выход в нужный режим микро-ЭВМ, восстановить 
			курсор и служебную строку, задать исходные цвета экрана и фона. Если 
			это не сделано, дальнейшее использование микро-ЭВМ без перезапуска зачастую 
			невозможно, и квалификации такого программиста можно дать соответствующую 
			оценку.</li>
			<li>Форматы данных в программах. Если программа написана на языке высокого 
			уровня, выбор формата входных и выходных данных зачастую определяет 
			этот язык, и тут ничего не поделаешь. Но в программе в кодах выбор опять-таки 
			за программистом. Желательно, конечно, иметь набор программ, полностью 
			совместимых по формату данных, например, иметь возможность отредактировать 
			листинг программы на ассемблере в мощном редакторе текста, или исправить 
			каталог файлов, составленный каталогизатором, в том же редакторе. На 
			БК-0010 этой совместимости нет совершенно. Известно по крайней мере
			<span class="nmbr">5</span>-<span class="nmbr">6</span> форматов текста, 
			абсолютно несовместимых между собой, и ещё <span class="nmbr">5</span>-<span class="nmbr">6</span> 
			форматов, несовместимых частично, в зависимости от соблюдения при их 
			написании специальных условий. Не будем описывать эти форматы, все их, 
			наверное, знают, а лишь сошлёмся на примеры. В этих форматах отличаются:
			<ul>
				<li>код перевода строки: <span class="nmbr">0</span> (<i>EDASP</i>);
				<span class="nmbr">12</span> (большинство редакторов); код не обязателен 
				(<i>МАШКОД</i>);</li>
				<li>код пробела: прямое кодирование (EDASP.<span class="nmbr">10</span>); 
				с применением операции &lt;ГТ&gt; (<i>EDASP</i>, <i>МИКРО.К</i>); 
				специальный девятиричный код (<i>МИКРО#С</i>);</li>
				<li>возможность использования того или иного набора символов и режимов 
				БК: формат <span class="nmbr">32</span> и <span class="nmbr">64</span>, 
				графика и псевдографика, управляющие коды, коды конца страницы, 
				коды меток и форматирования, коды символов КОИ-<span class="nmbr">7</span> 
				или КОИ-<span class="nmbr">8</span>, спецалфавиты и спецсимволы, 
				и масса других взаимно несовместимых сервисных удобств (а скорее, 
				неудобств) (все редакторы);</li>
				<li>объём буфера текста: от <span class="nmbr">20000</span> для 
				ассемблеров до <span class="nmbr">30000</span> и более для некоторых 
				редакторов;</li>
				<li>упаковка данных: прямое представление или самые невероятные 
				способы упаковки, особенно для графических редакторов.</li>
			</ul>
			<p>Понятно поэтому, что для того, чтобы наверняка иметь возможность 
			прочесть текст описания или вывести на экран графический файл, необходимо 
			иметь именно тот редактор, в котором он создан, а таких редакторов в 
			настоящее время, включая и графические, для БК-0010 известно несколько 
			десятков!</p>
			<p>Что тут можно предпринять? ответ очень труден, т.к. любой из ходовых 
			форматов данных имеет свои достоинства, и лишить программиста возможности 
			работать с ним - значит, что-то потерять. Но всё же можно рискнуть наметить 
			некоторый стандартный формат:</p>
			<ul>
				<li>код перевода строки обязателен в конце каждой строки любой длины, 
				и равен <span class="nmbr">12</span>;</li>
				<li>код пробела допустим равный <span class="nmbr">40</span>, по 
				числу пробелов, либо с использованием кода &lt;ГТ&gt;, равного
				<span class="nmbr">11</span>, что значит: переместить курсор до 
				ближайшей справа позиции строки, номер знакоместа которой кратен
				<span class="nmbr">10</span> (система счисления у нас восьмеричная, 
				вы помните?). Отказаться от использования &lt;ГТ&gt;, как советуют 
				некоторые, невозможно как из соображений экономии памяти (ведь у 
				нас БК-0010, а не IBM PC!), так и из соображений сервисных удобств, 
				которые при использовании &lt;ГТ&gt; очень ощутимы;</li>
				<li>отказаться от страничной организации редакторов и систем для 
				чтения, и использовать только построчную организацию, тем более, 
				что она удобнее и при создании текстов, и при их чтении;</li>
				<li>использовать для создания текстовых файлов весь набор символов 
				кода КОИ-<span class="nmbr">8</span>, исключив только управляющие 
				коды (<span class="nmbr">0</span>...<span class="nmbr">37</span>,
				<span class="nmbr">200</span>...<span class="nmbr">237</span>), 
				а следовательно, и режим графики. Учитывая малый формат экрана БК-0010 
				(<span class="nmbr">64</span>х<span class="nmbr">24</span> символа), 
				не применять формат &lt;<span class="nmbr">32</span>&gt;, т.к. при 
				этом количество информации, выводимой на экран одномоментно, слишком 
				мало, а лицам, которым формат &lt;<span class="nmbr">64</span>&gt; 
				кажется слишком мелким, рекомендовать использовать монитор с экраном 
				большего размера (напомним, что стандартный формат на всех распространённых 
				советских мониторах - <span class="nmbr">80</span> символов в строке). 
				Так как установлено специальными исследованиями, что инверсный режим 
				экрана вреден для зрения, не применять инверсию в текстах и цветные 
				тексты (кроме игр);</li>
				<li>размер буфера редакторов не стремиться делать предельно большим: 
				конечно, удобно работать с большим буфером, но такой текст пригоден 
				опять-таки только для своего редактора. Вполне достаточен и удобен 
				объём буфера <span class="nmbr">20000</span>, т.е. примерно три 
				страницы текста через <span class="nmbr">1</span>,<span class="nmbr">5</span> 
				интервала на стандартном листе. Возможно, альтернативным является 
				решение: при большем буфере обязательно иметь возможность выдачи 
				текста на МЛ по частям, а части эти стараться делать не более
				<span class="nmbr">20000</span>. Это даже ещё удобнее: допустим, 
				мы работаем в редакторе с буфером <span class="nmbr">30000</span>. 
				Написав текст длиной почти <span class="nmbr">30000</span> и обнаружив, 
				что нужно продолжать, &quot;сбросим&quot; на МЛ первые
				<span class="nmbr">20000</span> текста, затем удалим их из редактора, 
				оставив в нём &quot;хвост&quot; текста. Можно писать дальше, это 
				тем удобнее, что конец предыдущего отрывка - перед глазами;</li>
				<li>т.к. восстановление текста из упакованного формата как правило, 
				невозможно, если неизвестен алгоритм упаковки, то упакованный формат 
				стараться не применять. Это не относится к упаковке изображений 
				в граф.редакторах, что, видимо, неизбежно, но такие файлы должны 
				в обязательном порядке снабжаться блоками для воспроизведения графической 
				информации на экране, без редактора, если только они поставляются 
				кому-либо изолированно, а не используются, например, лишь для оформления 
				игр.</li>
			</ul>
			<p>Можно отметить, что наведение порядка с форматами текстов не только 
			исключило бы из обращения многие слабые разработки редакторов, но и 
			резко облегчило бы вывод текстов на печать, с чем дело на сегодня тоже 
			обстоит далеко не благополучно.</p>
			</li>
			<li>Автозапуск программ. Этого вопроса мы уже касались в данном руководстве, 
			добавить можно следующее.
			<p>Известно, что автозапуск может быть осуществлён записью адреса запуска 
			в ячейки <span class="nmbr">732</span> для МСД и <span class="nmbr">
			766</span> для пускового монитора при загрузке программы с МЛ. Принято 
			уже как стандарт, что программы с запуском по ячейке
			<span class="nmbr">766</span> имеют адрес загрузки
			<span class="nmbr">760</span>, это удобно. Но с запуском по ячейке
			<span class="nmbr">732</span> стандарта нет - встречаются адреса загрузки
			<span class="nmbr">600</span>, <span class="nmbr">700</span>, но чаще 
			всего <span class="nmbr">732</span>. Наверное, неразумно вводить адрес 
			загрузки меньше <span class="nmbr">732</span>, т.к. при загрузке такой 
			программы портится стек, её останов становится невозможен, а главное, 
			с ней не работают многие программы копирования. И это вовсе не является 
			защитой от копирования, т.к. скопировать такую программу мало-мальски 
			грамотному пользователю всё равно ничего не стоит, только автозапуск 
			будет отсутствовать. Поэтому рекомендуется остановиться на стандартном 
			адресе загрузки программ с автозапуском из МСД, равном
			<span class="nmbr">732</span>.</p>
			<p>И ещё один момент. Программа с автозапуском из МСД запускается независимо 
			от ошибок чтения с МЛ, что недопустимо. Поэтому в программах, рассчитанных 
			на автозапуск, следует после запуска первым делом проверить ячейку (<span class="nmbr">301</span>) 
			системной области на ошибку чтения, и разрешить работу программы только, 
			если содержимое её равно <span class="nmbr">0</span>.</p>
			</li>
			<li>Директивы и клавиши управления. Вот где простор для фантазии горе-программистов! 
			Один, владеющий лучше левой рукой, чем правой, отводит под директивы 
			клавиши Q, ^, S. Другой, сидящий на очень высоком стуле - клавиши &lt;ГРАФ, 
			ЗАП, СТИР&gt;. Одному нравится играть с компьютером двумя руками, соответственно 
			и <span class="nmbr">2</span> клавиши управления - &lt;РУС, ЛАТ&gt;. 
			Другой же размещает <span class="nmbr">9</span> (!) клавиш управления 
			игрой под одну руку - например, все <span class="nmbr">9</span> клавиш 
			управления курсором. Чудеса, да и только! Возникает вопрос: а не стоит 
			ли вместе с такой игрой поставлять пользователю и руки её создателя, 
			раз это так удобно ему?
			<p>Где же тут выход? Он прост и логичен, и многие создатели прекрасных 
			игр для БК-0010 им уже широко пользуются: управляющие клавиши должен 
			задавать сам пользователь в начале игры, тем более что программно решается 
			это весьма просто, и не только в кодах, но и на любом из языков высокого 
			уровня.</p>
			<p>Что же касается инструментальных программ, то тут задание клавиш 
			пользователем будет, мягко говоря, неудобно. Директив ассемблера, например, 
			больше <span class="nmbr">20</span>, и не всякий пользователь сможет 
			их правильно выбрать, да и объём программы недопустимо возрастёт. Лучше 
			уж задать директивы фиксированно при создании системы. Но при этом нужно 
			хорошо помнить, что на сегодня почти половина пользователей - владельцы 
			БК-0010-01, а их клавиатура не имеет многих клавиш, которые есть на 
			БК-0010. На БК-0010-01 отсутствуют клавиши: ГРАФ, ЗАП, СТИР, УСТ.ТАБ, 
			СБР.ТАБ, ГТ, клавиши диагонального перемещения курсора, и &quot;<i>курсор 
			в левый верхний угол</i>&quot;, называемая &quot;<i>HOME</i>&quot; (от 
			англ. &quot;<i>GO HOME</i>&quot; - &quot;<i>домой</i>&quot;). Кроме 
			того, на БК-0010-01 нет обозначений символов псевдографики на клавишах. 
			Конечно, все отсутствующие клавиши могут быть заменены нажатием некоторых 
			символьных клавиш по регистру &lt;СУ&gt;, но не слишком удобно, например, 
			вместо префиксной клавиши &quot;<i>HOME</i>&quot; (в ассемблерах) каждый 
			раз нажимать &lt;СУ/R&gt;! поэтому авторам инструментальных программ 
			следует либо применять символику команд, удобную на обеих моделях БК, 
			либо определять любую директиву дважды, для БК-0010 и БК-0010-01, либо 
			просто создать <span class="nmbr">2</span> варианта программы. Первый 
			выход, конечно, предпочтительнее, а последний приходится применять для 
			программ, созданных ещё до выпуска БК-0010-01.</p>
			</li>
			<li>Мнемоника языков программирования. Есть <span class="nmbr">2</span> 
			мнения по вопросу о приоритете в области программирования и ЭВМ. Представители 
			первого никогда не забывают, что первой ЭВМ в прямом смысле этого слова 
			была машина &quot;<i>ЭНИАК</i>&quot;, а местом её рождения была англоязычная 
			страна. Они помнят также, что наша страна, к великому сожалению, отстаёт 
			от ведущих компьютерных держав, как минимум на <span class="nmbr">8</span>-<span class="nmbr">10</span> 
			лет. Представители же <span class="nmbr">2</span>-го направления ссылаются 
			на то, как в жертву архитектуре и языку ЭВМ IBM/<span class="nmbr">360</span> 
			в своё время принесли такие оригинальные отечественные разработки, как &quot;<i>МИР-2</i>&quot; 
			и &quot;<i>БЭСМ-6</i>&quot;, в то время, возможно, лучшие в мире и уникальные 
			по структуре, заставив тем самым нас всех &quot;встать в затылок&quot; 
			американским программистам, а не идти с ними рядом. Но это лирика. Практика 
			же такова, что раздаётся всё больше голосов с призывом перейти на русский 
			язык в программировании. Создан отладчик &quot;<i>ПРОТ</i>&quot; с русской(!) 
			мнемоникой ассемблера. Создан язык &quot;<i>Рапира</i>&quot;. Переведён 
			всеми уважаемым, и, увы, покойным академиком Ершовым, на русский язык
			<i>Алгол</i>. Создан (аппаратно!) русский диалект Бейсика на машине &quot;<i>Искра-1256</i>&quot;. 
			Ходят слухи, что разрабатывается язык <i>FORTH-83</i> с русской мнемоникой. 
			Что же, перейти поголовно на русский язык? Прежде, чем ответить на этот 
			вопрос, нужно заметить, что у каждого должна быть свобода выбора, и 
			заставлять программировать на том или ином языке в приказном порядке 
			просто глупо. Однако, против перехода на русскую мнемонику есть ряд 
			серьёзнейших возражений, кстати, не имеющих прямого отношения к программированию 
			на том или ином языке.
			<p>Во-первых, английский язык в программировании на сегодня является 
			мировым стандартом, и пытаться его заменить с позиции компьютерно-отсталой 
			страны просто смешно. Созданное на русском языке ПО не найдёт сбыта 
			ни в одной стране мира, а сейчас, когда расширяются международные контакты, 
			это недопустимо.</p>
			<p>Во-вторых, чем русский язык лучше сотен других языков, применяемых 
			в нашей стране? Завтра кому-то покажется целесообразным создать мнемонику 
			на казахском или литовском языке!</p>
			<p>В-третьих, и это самое главное, русская мнемоника менее удобна, чем 
			английская! знаем ли мы вообще русский язык? Конечно, скажете вы. Но 
			вот любой лингвист подтвердит, что из всех языков мира у русского - 
			чуть ли не самые развитые ассоциативные связи, и чуть ли не самая большая 
			способность к ассимиляции иностранных слов. Каждое второе употребляемое 
			нами слово иностранного происхождения, а мы даже не замечаем этого! 
			Далее, русский язык - язык, резко персонифицирующий все слова. Например, 
			фамилия &quot;Смит&quot; в англоязычных странах - самая распространённая, 
			но как режет слух её русский перевод, особенно в контексте: &quot;мистер 
			кузнец&quot;! И, наконец, словарный запас русского языка огромен, это 
			один из самых мощных языков мира, и &quot;пустых комбинаций&quot;, особенно 
			в корнях слов, в нём почти нет, а значит, почти для каждого сокращения 
			или аббревиатуры найдётся аналог.</p>
			<p>Поэтому введение русской мнемоники неизбежно приведёт при программировании 
			к возникновению множества ложных ассоциативных связей, порождённых фонетическим 
			сходством мнемонических терминов с обиходными словами, и тем сильнее, 
			чем лучше программист владеет русским языком. Это, в свою очередь, ослабит 
			абстрактное ассоциирование, которое является важнейшим элементом мышления 
			при создании программы, и в конечном итоге значительно затруднит работу 
			над программным продуктом и снизит его качество. а потому не беда наша 
			- английская мнемоника, а, напротив, величайшее благо, и все попытки 
			ввести иной стандарт заранее обречены на провал, как вредящие программированию, 
			и как не приносящие большой славы русскому языку. Чтобы окончательно 
			убедить в этом, достаточно привести русскую мнемонику команд ассемблера: &quot;ПЕР(Б), 
			СТЕ(Б), ЗЕДН, ЗНОЛ, ПЛЮ, МИН&quot;. Это есть ни что иное, как сокращённый 
			перевод команд ассемблера &quot;<span class="cmds">MOV</span>(<span class="cmds">B</span>),
			<span class="cmds">CLR</span>(<span class="cmds">B</span>),
			<span class="cmds">BIS</span>, <span class="cmds">BIC</span>,
			<span class="cmds">ADD</span>, <span class="cmds">SUB</span>&quot;, 
			всем привычных и не режущих слух, тогда как набор русских мнемонических 
			терминов, будучи произнесён в серьёзной атмосфере какого-либо ИВЦ, наведёт 
			на мысли о психическом неблагополучии говорящего. Поэтому представляется, 
			что лучше запомнить английскую мнемонику (что при знании английского 
			языка вообще очень легко), чем смириться с мыслью, что все тебя будут 
			считать не совсем нормальным!</p>
			</li>
			<li>Запись файлов на магнитную ленту. Если что и осложняет людям жизнь, 
			то в <span class="nmbr">9</span> случаях из <span class="nmbr">10</span> 
			они сами это придумали. Например, обмен программами. Чего, казалось 
			бы, проще? Записал свою программу на кассету и послал (или просто передал) 
			другу. Но кое-кто вспомнил, что на БК-0010 адаптивный драйвер магнитофона. 
			А это значит, что можно читать магнитную ленту на любой скорости, а 
			не только на той, на которой записали. И вот, так как кассеты с магнитной 
			лентой достать труднее, чем БК-0010, решили, что нашли отличный выход: 
			можно писать на скорости, например, <span class="nmbr">2</span> см/сек, 
			а читать на <span class="nmbr">4</span>! Экономия ленты в
			<span class="nmbr">2</span> раза, ура! А вскоре кто-то решил, что придумал 
			ещё лучше: можно изменить скорость выдачи информации с БК-0010 на МЛ. 
			В самом деле, это не так сложно, особенно если знаешь системное программирование, 
			хотя драйвер МГ - самый сложный из драйверов. Чуть-чуть терпения, и, 
			как грибы после дождя, полезли программы копирования с повышенной скоростью 
			записи. Сначала все обрадовались, но... Словом, как в поговорке: &quot;торговали 
			- веселились, подсчитали - прослезились&quot;. Что же получается? Неужели 
			создатели БК-0010 не додумали, и не учли такой простой возможности экономии 
			магнитной ленты? Неужели Ярошенко, Соколов и другие оказались умнее? 
			Да нет, всё проще. Выбранная на БК-0010 скорость магнитной записи
			<span class="nmbr">1200</span> бод как раз оптимальна, и рассчитана 
			на реальные советские магнитофоны, даже с некоторым запасом. А вот повышенная 
			скорость (нет проблем увеличить скорость выдачи информации на выход &quot;МГ&quot; 
			хоть в <span class="nmbr">10</span> раз!) рассчитана на магнитофоны 
			получше &quot;ширпотребовских&quot;. Кроме того, ширина зазора головки 
			любого магнитофона чуть-чуть варьирует, не говоря уже о её наклоне. 
			Пока мы пишем со скоростью <span class="nmbr">1200</span> бод, каждый 
			бит занимает на ленте примерно <span class="nmbr">40</span> мкм. Если 
			же писать с двойной скоростью, то всего <span class="nmbr">20</span> 
			мкм, а это уже на уровне ширины зазора! Уровень намагничивания ленты 
			падает примерно вдвое, но не это самое плохое. Хуже то, что малейшие 
			колебания ширины зазора (например, при чтении на другом магнитофоне, 
			или просто при износе головки), и малейшие загрязнения или деформации 
			ленты начинают сильно искажать запись. Как показали специальные исследования, 
			число ошибок при чтении файлов равной длины на удвоенной скорости возрастает 
			ровно в <span class="nmbr">2</span> раза! Вот и смотрите, есть ли здесь 
			экономия. Число ошибок же при чтении на другом магнитофоне растёт даже 
			при специальной подстройке головок просто катастрофически - в
			<span class="nmbr">4</span> - <span class="nmbr">5</span> раз. Аналогичные 
			результаты получены и при записи на скорости ленты
			<span class="nmbr">2</span> см/сек.
			<p>Словом, из этого следует одна рекомендация - не пользоваться повышенной 
			скоростью записи и пониженной скоростью ленты, особенно при обмене программами.</p>
			<p>К аналогичным печальным последствиям, и по той же причине - конечная 
			ширина и низкая точность зазора головок - приводят попытки использовать 
			для записи стереомагнитофоны, а читать на обычных, монофонических. Две 
			дорожки на стереомагнитофоне, как правило, чуть-чуть расходятся по фазе 
			записанного сигнала. Это не страшно при записи даже &quot;самой симфонической&quot; 
			музыки, но &quot;смертельно&quot; для записи цифровой информации. Правда, 
			запись цифрового сигнала, сделанную на стереомагнитофоне, всегда можно 
			считать на другом стереомагнитофоне, если подать на БК сигнал с выхода 
			только <span class="nmbr">1</span> канала.</p>
			</li>
		</ol>
		<p>Однако мы отклонились от темы: стандарты. Что ещё можно стандартизировать 
		при записи файлов на МЛ? Имена!</p>
		<p>Не стоит, конечно, сильно ограничивать фантазию автора, назвать свою 
		программу как угодно - его право. Но всё-таки, если программа для расчётов 
		по теоретическим основам электротехники названа &quot;MAFIA&quot;, невольно 
		мороз проходит по коже. Аналогичную реакцию вызывает имя версии Бейсика &quot;Стресс&quot;, 
		и многие другие имена файлов. Конечно, можно изменить имя, но делать это 
		не следует, в дальнейшем это сильно затруднит идентификацию файлов. Лучше 
		плохое имя, чем чужое! Поэтому нужно стараться избегать плохих имён с самого 
		начала. Имя файла должно отражать не настроение программиста (конечно, любой 
		студент подтвердит, что преподаватели ТОЭ - это самая настоящая мафия!), 
		а существенные признаки программы. От дальнейших рекомендаций можно воздержаться, 
		предоставив всё фантазии автора. Но фантазия не должна быть бешеной!</p>
		<p>А на каком языке лучше давать имена? Это - серьёзный вопрос. Язык, на 
		котором написано имя файла, несёт большую информацию. Например, программа 
		на Фокале, как правило, должна иметь имя в латинском регистре, что избавит 
		от лишних переключений регистров при её загрузке и запуске. А программа, 
		запускаемая из МСД, должна иметь по тем же причинам имя русское. Давайте 
		договоримся: если имя русское, то программа в кодах запускается только из 
		МСД, и, возможно, требует для работы подключения блока МСТД (использует 
		подпрограммы тест-ПЗУ). Если же имя латинское, то запуск - из произвольного 
		режима. Такое соглашение избавит от многих неприятностей. Если же оно кому-либо 
		не по душе, то что же, любая программа, рассчитанная на запуск из пускового 
		монитора, может быть запущена и из МСД.</p>
		<p>&nbsp;</p>
		<p class="centr">Итак, рекомендации.</p>
		<p>Латинские имена должны иметь файлы:</p>
		<ul>
			<li>программы на языках высокого уровня;</li>
			<li>листинги и объектные модули ассемблеров;</li>
			<li>программы в кодах с запуском из любого режима БК-0010.</li>
		</ul>
		<p>Русские имена должны иметь:</p>
		<ul>
			<li>программы в кодах с обязательным запуском из МСД.</li>
		</ul>
		<p>Любые имена могут иметь:</p>
		<ul>
			<li>текстовые файлы редакторов.</li>
		</ul>
		<p>Не рекомендуются очень короткие имена (например, из одной буквы или цифры), 
		такое имя ничего не говорит о сути программы и плохо запоминается. Не рекомендуются 
		и очень длинные имена, их трудно набирать на клавиатуре, и легко ошибиться. 
		Очень неудобны имена, в которые входят строчные и заглавные буквы, ошибка 
		при наборе такого имени весьма вероятна. И совсем неприемлемы имена, сочетающие 
		русские и латинские символы, правильно набрать такое имя можно только методом 
		проб и ошибок. Иногда для защиты программ от несанкционированной загрузки 
		(а, значит, и копирования) вводят специальным образом в имя файла управляющий 
		код, который невозможно ввести с клавиатуры, например, нулевой байт. Но 
		это уже относится к методам защиты ПО от копирования, до которых мы тоже 
		когда-нибудь доберёмся.</p>
		<p>В заключение же можно только сказать, что стандартизация в области ПО 
		- это нечто совсем иное, чем ходьба строем. Это перечень правил и соглашений, 
		удобный большинству пользователей, и нетрудный для соблюдения программистами. 
		Ни одна сколько-нибудь серьёзная область человеческой деятельности не избежала 
		стандартизации, несмотря на сопротивление, иногда яростное, её противников. 
		И, хотим мы, или нет, мы все живём по стандарту: стул наш высотой
		<span class="nmbr">45</span> см, клавиатура на компьютере - &quot;JCUKEN...&quot;, 
		напряжение в сети - <span class="nmbr">220</span>В. А правила нашей речи, 
		разве это не стандарт? А правила уличного движения? И даже футбол стандартизован 
		ничуть не меньше, чем любой язык программирования. Поэтому бессмысленно 
		бороться против стандартизации, лучше стараться сделать стандарты более 
		удобными большинству, и не слишком стеснительными для меньшинства, а тут 
		есть, над чем подумать в любой области!</p>
		<div style="padding: 12pt 0 0;">
			<p style="text-align: right; color: #999999; font-size: 80%">Performed 
			by &copy; gid, 2012-2020. </p>
		</div>
	</div>
</div>

</body>

</html>
